/*
  File autogenerated by gengetopt version 2.22.6
  generated with the following command:
  gengetopt --input=cmdline.ggo --include-getopt --show-required --unamed-opts=FILE --no-handle-error

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif


#include "cmdline.h"

const char *gengetopt_args_info_purpose = "";

const char *gengetopt_args_info_usage = "Usage: " CMDLINE_PARSER_PACKAGE " [FILE] [--formula=FORMULA] [OPTIONS]...";

const char *gengetopt_args_info_versiontext = "";

const char *gengetopt_args_info_description = "About LoLA:";

const char *gengetopt_args_info_detailed_help[] = {
  "  -h, --help                    Print help and exit",
  "      --detailed-help           Print help, including all details and hidden\n                                  options, and exit",
  "      --full-help               Print help, including hidden options, and exit",
  "  -V, --version                 Print version and exit",
  "\nVerification Problem:",
  "  \n  The verification problem specifies the question that LoLA is supposed to\n  answer.\n",
  "  -c, --check=PROPERTY          Verify a property  (possible values=\"none\",\n                                  \"full\", \"modelchecking\"\n                                  default=`modelchecking')",
  "  \n  The type of property to be verified by LoLA is selected:\n\n  * modelchecking: A given temporal logic formula (specified using the\n    mandatory `--formula' or `--buechi' option) is evaluated while generating\n    the state space. Search terminates as soon as the value of the formula is\n    determined.\n  * full: All reachable states are computed without evaluating any property.\n    This is useful for determining the size of a (reduced) state space.\n  * none: No state space search is performed at all. This is useful for just\n    getting statistical data for the net and pre-processing information.\n\n",
  "  -f, --formula=FORMULA         Check a formula",
  "  \n  If the given string is a formula in one of the temporal logics CTL or LTL,\n  this formula is verified during state space exploration. Otherwise, if the\n  given string is a file name, such a formula is expected as content of that\n  file (requires `--check=modelchecking').\n\n",
  "      --buechi=AUTOMATON        Check a linear time property specified as a\n                                  Büchi automaton",
  "  \n  The given string is expected to be a file name that contains the description\n  of a Büchi automaton. During state space exploration, LoLA searches for a\n  path that is accepted by that automaton (requires `--check=modelchecking').\n",
  "\nReduction Techniques:",
  "  \n  LoLA offers several techniques for alleviating the state space explosion\n  problem. Many of them can be applied in combination.\n",
  "      --search=STRATEGY         Search the state space using a particular\n                                  strategy  (possible values=\"depth\",\n                                  \"sweepline\", \"covergraph\"\n                                  default=`depth')",
  "  \n  The search strategy determines (1) the order in which states are explored,\n  and (2) whether or not computed states are kept in memory.\n\n  * depth: States are explored using the depth-first strategy and kept in\n    memory forever.\n  * sweepline: States are explored in ascending progress value order determined\n    by a pre-processed progress measure. They are released from memory as soon\n    as their progress value is smaller those of than any unprocessed states,\n    unless the search algorithm has marked them as persistent (for assuring\n    termination). Search is exhaustive.\n  * covergraph: States are explored using the coverability graph constructions,\n   \n    i.e. sequences of states are abstracted to their limit. Evaluation of \n    properties may lead to inconclusive results.\n\n",
  "      --findpath=POSITION       Perform repeated runs without storing states\n                                  (possible values=\"seq\", \"par\", \"alone\",\n                                  \"off\" default=`off')",
  "  \n  This technique can be applied to simple properties such as reachability\n  of a state predicate or deadlock. It repeatedly generates firing sequences\n  and checks if the target property is satisfied. States are not stored, hence\n  sequence generation is very fast. On the other hand, this method is\n  inherently\n  incomplete. The value of the property determines, where the technique is\n  placed w.r.t. exhaustive search.\n\n  * seq: apply it before executing exhaustive search \n  * par: apply it in parallel to exhaustive search\n  * alone: apply it instead of exhaustive search\n  * off: do not apply it at all (default)\n",
  "      --stubborn=STUBBORN       Apply a particular scheme for computing\n                                  stubborn sets.  (possible values=\"tarjan\",\n                                  \"deletion\", \"off\" default=`tarjan')",
  "  \n  If LoLA searches for deadlocks or reduces a temporal logic property to a\n  simple reachability problem, it always uses the stubborn set method (a\n  partial order reduction technique). There are several ways to compute\n  stubborn sets which have different performance.\n\n  * tarjan: Stubborn sets are computed by an incremental method that\n    investigates strongly connected components in a dependency graph. It has\n    linear complexity (in the number of transitions) and leads to superior\n    performance if a target state (or deadlock) is actually reachable).\n  * deletion: Stubborn sets are computed by repeated deletion of transitions.\n    It has quadratic complexity (in the number of transitions) but produces\n    smaller stubborn sets. It has superior performance if no target state (or\n    deadlock) is actually reachable.\n\n",
  "      --cycle                   Apply transition invariant based reduction.\n                                  (default=off)",
  "  \n  States are computed but only some of them are stored. Stored states are\n  sufficient to cover at least one state for each cycle in the state space,\n  thus guaranteeing termination of the search. Information about cycles in the\n  state space is obtained from transition invariants of the Petri net that are\n  determined in preprocessing.\n\n",
  "      --symmetry                Apply symmetry reduction.  (default=off)",
  "  \n  A generating set for the symmetries of the given net (respecting the given\n  formula, if applicable) is computed during pre-processing. During state space\n  exploration, markings are transformed into (approximated) canonical\n  representatives of their respective equivalence classes before storing. This\n  way, only few members of an equivalence class are physically present in the\n  set of stored markings.\n",
  "      --ltlstubborn=ONorOFF     Apply computing stubborn sets for LTL.\n                                  (possible values=\"off\", \"on\"\n                                  default=`off')",
  "  ",
  "\nStructural Analysis:",
  "  \n  For some problems, LoLA can execute structural checks that yield necessary\n  or sufficient conditions. They are applied concurrently to the state\n  space exploration. \n",
  "      --siphontrap=ORDER        Check for deadlock freedom by exploring the\n                                  siphon/trap property  (possible\n                                  values=\"off\", \"seq\", \"par\", \"alone\"\n                                  default=`off')",
  "  \n  A Petri net where all input arcs to transitions have multiplicity 1\n  is deadlock-free if every siphon (set of places S where post(S) is subset\n  of pre(S)) includes a marked trap (set of places S' where pre(S') is subset\n  of post(S')). LoLA translates the problem into a propositional formula and\n  evaluates it using the integrated Minisat SAT solver. If the net does not\n  satisfy the multiplicity condition, LoLA skips the check.\n\n  * off: do not apply this check (default)\n  * seq: apply this check before the main search\n  * par: apply this check in parallel to the main search\n  * alone: apply only this check (and no other check)\n",
  "      --siphondepth=INT         Control the length of the formula for the\n                                  siphon/trap check.  (default=`1073741824')",
  "  \n  If the value is smaller than the number of places of the net, a shorter\n  formula for the siphon/trap problem is generated. It may then yield \n  inconclusive results. Shorter value means smaller formula, higher\n  probability of an inconclusive result but on the other hand less memory\n  consumption and quicker result. LoLA will never make false decisions on\n  an inconclusive outcome.\n",
  "      --minisatargs=STRING      Pass options to the integrated Minisat SAT\n                                  solver.  (default=`')",
  "  \n  The string is passed to Minisat as if it were its command line string.\n  This way, you can modify the way Minisat is solving the siphon/trap problem.\n  Do not try to give a filename as the input comes from LoLA.\n",
  "      --siphonwitness[=FILE]    Print witness siphon and trap  (default=`-')",
  "  \n  If the siphon/trap property does not hold, print a siphon that does not\n  contain \n  a marked trap and the unique maximal trap included. This option is only\n  useful\n  when siphontrap != off. If the siphon/trap propert happens to hold, or the\n  result is inconclusive, no witness is printed.\n",
  "\nStateEquationTask:",
  "  ",
  "      --stateequation=ORDER     Checking reachability of petri net state\n                                  equation  (possible values=\"off\", \"seq\",\n                                  \"par\", \"alone\" default=`off')",
  "  \n  Using this option invokes Sara, which sends the results back.\n  There are four values to set stateequation: off, seq, par and alone.\n\n  * off: do not apply this check (default)\n  * seq: apply this check before the main search\n  * par: apply this check in parallel to the main search\n  * alone: do only this check without the main search\n",
  "\nInput:",
  "  \n  Input can be given in several formats.\n",
  "      --compressed              Read a compressed file  (default=off)",
  "  \n  In compressed format, net elements are reduced to indices, thus making it\n  easier to transform an input file into internal data structures. This is\n  useful for repeated use of the same net, but not at all readable for humans.\n",
  "\nOutput:",
  "  \n  Apart from the answer to the verification problem, LoLA can output other\n  useful information. This information can help in understanding the result\n  produced by LoLA.\n",
  "  -s, --state[=FILE]            Print witness state  (default=`-')",
  "  \n  If the verification problem asks for the reachability of a state, and such a\n  state is indeed reachable, this option forces LoLA to write such a state to\n  the specified file, or to the standard output stream (-).\n\n",
  "  -p, --path[=FILE]             Print witness path  (default=`-')",
  "  \n  If the verification problem asks for the existence of a path (e.g. to a given\n  state, or accepted by a Büchi automaton), this option forces LoLA to write\n  such a path to the specified file, or to the standard output stream (-).\n\n",
  "      --pathshape[=SHAPE]       Select the shape of the witness path  (possible\n                                  values=\"linear\", \"run\", \"fullrun\",\n                                  \"eventstructure\" default=`linear')",
  "  \n  If a path is written using the `--path' option, several formats are available\n  to control the way in which concurrency is expressed, and how much redundant\n  information is provided.\n\n  * linear: Print all transitions in path in sequential order, i.e. no\n    concurrency information is given.\n  * fullrun: The path is expressed as a partially ordered run (an unrolling of\n    the net) consisting of conditions (places) and events (transitions).\n  * run: Same as fullrun, but obvious places and transitions (e.g. plain\n    sequences) are suppressed.\n  * eventstructure: Same as run, bit places are not reported.\n\n",
  "      --writeCompressed[=PREFIX]\n                                Write a compressed file\n                                  (default=`compressedOutput')",
  "  \n  The net structure is written using indices instead of identifiers. Thus,\n  subsequent reading is more efficient.\n",
  "      --writeBuechi[=PREFIX]    Write a Buechi automaton  (default=`automaton')",
  "  \n  If a formula classified as LTL problem is given, this option writes a text\n  file\n  containing the corresponding Buechi automaton (accepting the negation of the\n  given problem)\n",
  "\nLogging:",
  "  \n  During search, LoLA generates tons of messages concerning results of\n  preprocessing, progress information during search, or statistical data.\n",
  "  -q, --quiet                   Suppress messages.  (default=off)",
  "  \n  In quiet mode, nothing is reported (except of error messages). This option is\n  in particular useful in combination with the JSON output.\n\n",
  "  -r, --reporter=REPORTER       Select a reporting procedure.  (possible\n                                  values=\"stream\", \"socket\", \"silent\"\n                                  default=`stream')",
  "  \n  LoLA has different ways to emit log messages.\n\n  * stream: Messages are sent to the standard error stream (stderr) of the\n    process that runs LoLA.\n  * socket: Messages are sent to a remote process (`listener') via socket\n    communication.\n  * silent: All messages are suppressed.\n\n",
  "  -j, --json[=FILE]             Output structured data in JSON format.\n                                  (default=`-')",
  "  \n  Creates structured output in JSON format (JavaScript Object Notation). This\n  format is designed to be easily consumable by other programs. The used keys\n  are described in LoLA's manual. The output is written into the specified\n  file, or by default to the standard output stream (-).\n\n",
  "      --jsoninclude=DATA        Control which data should be included in the\n                                  JSON output.  (possible values=\"path\",\n                                  \"state\")",
  "  \n  This option controls whether additional aspects should be included in the\n  JSON output.\n\n",
  "      --nolog                   Do not send logging information  (default=off)",
  "  \n  LoLA sends statistical data to a logging server. This function switches off\n  logging.\n\n",
  "      --outputport=PORT         Define output port number  (default=`5555')",
  "  \n  This option specifies a port number for outgoing messages. This port is used\n  to communicate with a listener process which displays LoLA's reports.\n\n",
  "      --inputport=PORT          Define input port number  (default=`5556')",
  "  \n  This option specifies a port number for incoming messages. This port is used\n  to remotely terminate LoLA in case the option `--remoteTermination' is used.\n\n",
  "      --address=HOSTNAME        Define hostname or IP for reports\n                                  (default=`localhost')",
  "  \n  The hostname or IP address of a listener process to which LoLA will send\n  reports to.\n",
  "      --remoteTermination[=SECRET]\n                                Allow remote termination  (default=`goodbye')",
  "  \n  This option installs a termination handler that allows to remotely terminate\n  LoLA by sending a specified SECRET to the input port.\n",
  "\nDebugging:",
  "      --printNet                Print the net  (default=off)",
  "      --stats                   Print memory statistics  (default=off)",
  "      --tscc                    Use TSCC exploration  (default=off)",
  "\nLimits:",
  "  \n  To avoid negative effects of physically exceeding the resources of the\n  machine that runs LoLA, artificial limits can be set that force LoLA to\n  terminate when exceeded.\n",
  "      --timelimit=SECONDS       Abort LoLA after the given time has passed",
  "  \n  LoLA is aborted when the given number of seconds have passed.\n\n",
  "      --localtimelimit=SECONDS  Abort a child process of LoLA that executes a\n                                  subtask,\n                                     after the given time has passed. Use 0 to\n                                  use a dynamic calculated limit.",
  "  \n  A child process of LoLA is aborted when the given number of seconds have\n  passed. \n  The process returns UNKNOWN as result. LoLA continues with the execution of\n  the next subproblem.\n  If 0 is passed as argument a dynamic calculated local time limit is used. It\n  is calculated \n  based on the remaining time, if a globel time limit (--timelimit) is set. \n",
  "      --symmtimelimit=SECONDS   Abort symmetry computation after the given time\n                                  has passed",
  "  \n  When the given time limit is exceeded, LoLA stops exploration of symmetries\n  and continues with those generators that have been found so far.\n\n",
  "      --markinglimit=MARKINGS   Abort LoLA after the given number of markings\n                                  have been explored",
  "  \n  LoLA is aborted as soon as it reports a number of explored markings that is\n  larger than the specified number.\n",
  "\nAdvanced:",
  "  \n  A lot of other aspects of LoLA can be controlled with command line\n  parameters. A complete list can be shown with `--detailed-help'.\n",
  "      --store=STORE             Manage visited states using the specified data\n                                  structure  (possible values=\"comp\",\n                                  \"prefix\", \"stl\", \"bloom\"\n                                  default=`prefix')",
  "  \n  LoLA supports several structures for managing the stored states:\n\n  * comp: for internal (debugging) use only\n  * prefix: Store states as a prefix tree\n  * stl: Store states using the set class in the C++ standard template library\n    (STL).\n  * bloom: do not store states, but record hash values of visited states. When\n    hash collisions occur, search is not exhaustive. The probability of hash\n    collisions can be reduced by increasing the number of concurrently used\n    hash functions.\n\n",
  "      --encoder=ENCODER         Code visited states using the specified coding\n                                  scheme  (possible values=\"bit\", \"copy\",\n                                  \"simplecompressed\", \"fullcopy\"\n                                  default=`bit')",
  "  \n  LoLA supports several strategies for transforming a marking into a sequence\n  of bits to be finally stored. Some schemes represent only significant places.\n  The marking of insignificant places is fully determined by the significant\n  ones via place invariants of the Petri net. Information about significance of\n  places is computed in pre-processing.\n\n  * bit: Marking of significant places is packed such that each place gets only\n    as many bits as necessary according to its capacity.\n  * copy: Marking of significant places is transformed using one word per\n    place.\n  * simplecompressed: Marking of significant places is encoded using a variable\n    length coding scheme that assigns small codes to low marking values and\n    large codes to bigger marking values.\n  * fullcopy: Marking of all places is transformed using one word per place.\n\n",
  "      --bucketing[=BUCKETS]     Activate bucketing, if the selected store\n                                  supports it.  (default=`16')",
  "  \n  The argument is valid for the sweep-line method only, should be a power of 2,\n  and determines the number of buckets per progress value.\n\n",
  "      --hashfunctions=SHORT     Activate the specified number of hash functions\n                                  for the Bloom filter  (default=`2')",
  "  \n  Using the `--store=bloom' option, only the hash values of visited states are\n  recorded. This option controls, for how many (stochastically independent)\n  hash functions, the hash value is recorded. Increased number reduces the\n  probability of hash collisions thus getting search closer to exhaustion of\n  the state space.\n\n",
  "      --ltlmode=LTLMODE         Select LTL-state storage mode  (possible\n                                  values=\"tree\", \"flat\" default=`tree')",
  "      --sweepfronts=FRONTS      Number of fronts that may run simultaneously in\n                                  the SweepLine method.  (default=`1')",
  "  \n  In addition, a higher number of threads can be selected to sweep through\n  states inside any single front concurrently.\n\n",
  "      --sweeplinedelay=PERCENTAGE\n                                Parameter for the SweepLine search strategy\n                                  (default=`100')",
  "  \n  Percentage of transitions with negative progress values for which\n  non-persistent states are remembered.\n\n",
  "      --sweeplinespread=MULTIPLIER\n                                Allow spreading of progress values over a\n                                  larger range.  (default=`1')",
  "      --cycleheuristic=K        Heuristical parameter for transition invariant\n                                  based analysis.  (default=`-1')",
  "      --retrylimit=RETRIES      Set number of retries (0 for infinite retries;\n                                  relevant only for `--search=findpath')\n                                  (default=`0')",
  "  \n  Using `--search=findpath', randomly selected transitions are fired without\n  storing states. Occasionally, search resumes at the initial marking (see\n  `--depthlimit'). After RETRIES resets to the initial marking, LoLA terminates\n  and assumes that the target state is not reachable (which is not necessarily\n  the correct result as search is not exhaustive).\n\n",
  "      --depthlimit=DEPTH        Set number of transitions to fire before search\n                                  is aborted or retried (relevant for\n                                  `--search=findpath').  (default=`1000000')",
  "  \n  Using `--search=findpath', randomly selected transitions are fired without\n  storing states. When DEPTH is reached, search resumes at the initial marking\n  thus exploring another path.\n\n",
  "      --threads=THREADS         Set number of threads to be used for\n                                  parallelization  (default=`1')",
  "  \n  If the machine running LoLA has several cores, LoLA can parallelize the\n  access to the stored markings to the given number of threads.\n",
    0
};
static void
init_full_help_array(void)
{
  gengetopt_args_info_full_help[0] = gengetopt_args_info_detailed_help[0];
  gengetopt_args_info_full_help[1] = gengetopt_args_info_detailed_help[1];
  gengetopt_args_info_full_help[2] = gengetopt_args_info_detailed_help[2];
  gengetopt_args_info_full_help[3] = gengetopt_args_info_detailed_help[3];
  gengetopt_args_info_full_help[4] = gengetopt_args_info_detailed_help[4];
  gengetopt_args_info_full_help[5] = gengetopt_args_info_detailed_help[5];
  gengetopt_args_info_full_help[6] = gengetopt_args_info_detailed_help[6];
  gengetopt_args_info_full_help[7] = gengetopt_args_info_detailed_help[8];
  gengetopt_args_info_full_help[8] = gengetopt_args_info_detailed_help[10];
  gengetopt_args_info_full_help[9] = gengetopt_args_info_detailed_help[12];
  gengetopt_args_info_full_help[10] = gengetopt_args_info_detailed_help[13];
  gengetopt_args_info_full_help[11] = gengetopt_args_info_detailed_help[14];
  gengetopt_args_info_full_help[12] = gengetopt_args_info_detailed_help[16];
  gengetopt_args_info_full_help[13] = gengetopt_args_info_detailed_help[18];
  gengetopt_args_info_full_help[14] = gengetopt_args_info_detailed_help[20];
  gengetopt_args_info_full_help[15] = gengetopt_args_info_detailed_help[22];
  gengetopt_args_info_full_help[16] = gengetopt_args_info_detailed_help[24];
  gengetopt_args_info_full_help[17] = gengetopt_args_info_detailed_help[26];
  gengetopt_args_info_full_help[18] = gengetopt_args_info_detailed_help[27];
  gengetopt_args_info_full_help[19] = gengetopt_args_info_detailed_help[28];
  gengetopt_args_info_full_help[20] = gengetopt_args_info_detailed_help[30];
  gengetopt_args_info_full_help[21] = gengetopt_args_info_detailed_help[32];
  gengetopt_args_info_full_help[22] = gengetopt_args_info_detailed_help[34];
  gengetopt_args_info_full_help[23] = gengetopt_args_info_detailed_help[36];
  gengetopt_args_info_full_help[24] = gengetopt_args_info_detailed_help[37];
  gengetopt_args_info_full_help[25] = gengetopt_args_info_detailed_help[38];
  gengetopt_args_info_full_help[26] = gengetopt_args_info_detailed_help[40];
  gengetopt_args_info_full_help[27] = gengetopt_args_info_detailed_help[41];
  gengetopt_args_info_full_help[28] = gengetopt_args_info_detailed_help[42];
  gengetopt_args_info_full_help[29] = gengetopt_args_info_detailed_help[44];
  gengetopt_args_info_full_help[30] = gengetopt_args_info_detailed_help[45];
  gengetopt_args_info_full_help[31] = gengetopt_args_info_detailed_help[46];
  gengetopt_args_info_full_help[32] = gengetopt_args_info_detailed_help[48];
  gengetopt_args_info_full_help[33] = gengetopt_args_info_detailed_help[50];
  gengetopt_args_info_full_help[34] = gengetopt_args_info_detailed_help[52];
  gengetopt_args_info_full_help[35] = gengetopt_args_info_detailed_help[54];
  gengetopt_args_info_full_help[36] = gengetopt_args_info_detailed_help[56];
  gengetopt_args_info_full_help[37] = gengetopt_args_info_detailed_help[57];
  gengetopt_args_info_full_help[38] = gengetopt_args_info_detailed_help[58];
  gengetopt_args_info_full_help[39] = gengetopt_args_info_detailed_help[60];
  gengetopt_args_info_full_help[40] = gengetopt_args_info_detailed_help[62];
  gengetopt_args_info_full_help[41] = gengetopt_args_info_detailed_help[64];
  gengetopt_args_info_full_help[42] = gengetopt_args_info_detailed_help[66];
  gengetopt_args_info_full_help[43] = gengetopt_args_info_detailed_help[68];
  gengetopt_args_info_full_help[44] = gengetopt_args_info_detailed_help[70];
  gengetopt_args_info_full_help[45] = gengetopt_args_info_detailed_help[72];
  gengetopt_args_info_full_help[46] = gengetopt_args_info_detailed_help[74];
  gengetopt_args_info_full_help[47] = gengetopt_args_info_detailed_help[76];
  gengetopt_args_info_full_help[48] = gengetopt_args_info_detailed_help[77];
  gengetopt_args_info_full_help[49] = gengetopt_args_info_detailed_help[78];
  gengetopt_args_info_full_help[50] = gengetopt_args_info_detailed_help[79];
  gengetopt_args_info_full_help[51] = gengetopt_args_info_detailed_help[80];
  gengetopt_args_info_full_help[52] = gengetopt_args_info_detailed_help[81];
  gengetopt_args_info_full_help[53] = gengetopt_args_info_detailed_help[82];
  gengetopt_args_info_full_help[54] = gengetopt_args_info_detailed_help[84];
  gengetopt_args_info_full_help[55] = gengetopt_args_info_detailed_help[86];
  gengetopt_args_info_full_help[56] = gengetopt_args_info_detailed_help[88];
  gengetopt_args_info_full_help[57] = gengetopt_args_info_detailed_help[90];
  gengetopt_args_info_full_help[58] = gengetopt_args_info_detailed_help[91];
  gengetopt_args_info_full_help[59] = gengetopt_args_info_detailed_help[92];
  gengetopt_args_info_full_help[60] = gengetopt_args_info_detailed_help[94];
  gengetopt_args_info_full_help[61] = gengetopt_args_info_detailed_help[96];
  gengetopt_args_info_full_help[62] = gengetopt_args_info_detailed_help[98];
  gengetopt_args_info_full_help[63] = gengetopt_args_info_detailed_help[100];
  gengetopt_args_info_full_help[64] = gengetopt_args_info_detailed_help[101];
  gengetopt_args_info_full_help[65] = gengetopt_args_info_detailed_help[103];
  gengetopt_args_info_full_help[66] = gengetopt_args_info_detailed_help[105];
  gengetopt_args_info_full_help[67] = gengetopt_args_info_detailed_help[106];
  gengetopt_args_info_full_help[68] = gengetopt_args_info_detailed_help[107];
  gengetopt_args_info_full_help[69] = gengetopt_args_info_detailed_help[109];
  gengetopt_args_info_full_help[70] = gengetopt_args_info_detailed_help[111];
  gengetopt_args_info_full_help[71] = 0; 
  
}

const char *gengetopt_args_info_full_help[72];

static void
init_help_array(void)
{
  gengetopt_args_info_help[0] = gengetopt_args_info_detailed_help[0];
  gengetopt_args_info_help[1] = gengetopt_args_info_detailed_help[1];
  gengetopt_args_info_help[2] = gengetopt_args_info_detailed_help[2];
  gengetopt_args_info_help[3] = gengetopt_args_info_detailed_help[3];
  gengetopt_args_info_help[4] = gengetopt_args_info_detailed_help[4];
  gengetopt_args_info_help[5] = gengetopt_args_info_detailed_help[5];
  gengetopt_args_info_help[6] = gengetopt_args_info_detailed_help[6];
  gengetopt_args_info_help[7] = gengetopt_args_info_detailed_help[8];
  gengetopt_args_info_help[8] = gengetopt_args_info_detailed_help[10];
  gengetopt_args_info_help[9] = gengetopt_args_info_detailed_help[12];
  gengetopt_args_info_help[10] = gengetopt_args_info_detailed_help[13];
  gengetopt_args_info_help[11] = gengetopt_args_info_detailed_help[14];
  gengetopt_args_info_help[12] = gengetopt_args_info_detailed_help[16];
  gengetopt_args_info_help[13] = gengetopt_args_info_detailed_help[18];
  gengetopt_args_info_help[14] = gengetopt_args_info_detailed_help[20];
  gengetopt_args_info_help[15] = gengetopt_args_info_detailed_help[22];
  gengetopt_args_info_help[16] = gengetopt_args_info_detailed_help[24];
  gengetopt_args_info_help[17] = gengetopt_args_info_detailed_help[26];
  gengetopt_args_info_help[18] = gengetopt_args_info_detailed_help[27];
  gengetopt_args_info_help[19] = gengetopt_args_info_detailed_help[28];
  gengetopt_args_info_help[20] = gengetopt_args_info_detailed_help[30];
  gengetopt_args_info_help[21] = gengetopt_args_info_detailed_help[32];
  gengetopt_args_info_help[22] = gengetopt_args_info_detailed_help[34];
  gengetopt_args_info_help[23] = gengetopt_args_info_detailed_help[36];
  gengetopt_args_info_help[24] = gengetopt_args_info_detailed_help[37];
  gengetopt_args_info_help[25] = gengetopt_args_info_detailed_help[38];
  gengetopt_args_info_help[26] = gengetopt_args_info_detailed_help[44];
  gengetopt_args_info_help[27] = gengetopt_args_info_detailed_help[45];
  gengetopt_args_info_help[28] = gengetopt_args_info_detailed_help[46];
  gengetopt_args_info_help[29] = gengetopt_args_info_detailed_help[48];
  gengetopt_args_info_help[30] = gengetopt_args_info_detailed_help[56];
  gengetopt_args_info_help[31] = gengetopt_args_info_detailed_help[57];
  gengetopt_args_info_help[32] = gengetopt_args_info_detailed_help[58];
  gengetopt_args_info_help[33] = gengetopt_args_info_detailed_help[80];
  gengetopt_args_info_help[34] = gengetopt_args_info_detailed_help[81];
  gengetopt_args_info_help[35] = gengetopt_args_info_detailed_help[82];
  gengetopt_args_info_help[36] = gengetopt_args_info_detailed_help[84];
  gengetopt_args_info_help[37] = gengetopt_args_info_detailed_help[86];
  gengetopt_args_info_help[38] = gengetopt_args_info_detailed_help[88];
  gengetopt_args_info_help[39] = gengetopt_args_info_detailed_help[90];
  gengetopt_args_info_help[40] = gengetopt_args_info_detailed_help[91];
  gengetopt_args_info_help[41] = gengetopt_args_info_detailed_help[92];
  gengetopt_args_info_help[42] = gengetopt_args_info_detailed_help[107];
  gengetopt_args_info_help[43] = gengetopt_args_info_detailed_help[109];
  gengetopt_args_info_help[44] = gengetopt_args_info_detailed_help[111];
  gengetopt_args_info_help[45] = 0; 
  
}

const char *gengetopt_args_info_help[46];

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
  , ARG_INT
  , ARG_SHORT
  , ARG_ENUM
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error);

static int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

const char *cmdline_parser_check_values[] = {"none", "full", "modelchecking", 0}; /*< Possible values for check. */
const char *cmdline_parser_search_values[] = {"depth", "sweepline", "covergraph", 0}; /*< Possible values for search. */
const char *cmdline_parser_findpath_values[] = {"seq", "par", "alone", "off", 0}; /*< Possible values for findpath. */
const char *cmdline_parser_stubborn_values[] = {"tarjan", "deletion", "off", 0}; /*< Possible values for stubborn. */
const char *cmdline_parser_ltlstubborn_values[] = {"off", "on", 0}; /*< Possible values for ltlstubborn. */
const char *cmdline_parser_siphontrap_values[] = {"off", "seq", "par", "alone", 0}; /*< Possible values for siphontrap. */
const char *cmdline_parser_stateequation_values[] = {"off", "seq", "par", "alone", 0}; /*< Possible values for stateequation. */
const char *cmdline_parser_pathshape_values[] = {"linear", "run", "fullrun", "eventstructure", 0}; /*< Possible values for pathshape. */
const char *cmdline_parser_reporter_values[] = {"stream", "socket", "silent", 0}; /*< Possible values for reporter. */
const char *cmdline_parser_jsoninclude_values[] = {"path", "state", 0}; /*< Possible values for jsoninclude. */
const char *cmdline_parser_store_values[] = {"comp", "prefix", "stl", "bloom", 0}; /*< Possible values for store. */
const char *cmdline_parser_encoder_values[] = {"bit", "copy", "simplecompressed", "fullcopy", 0}; /*< Possible values for encoder. */
const char *cmdline_parser_ltlmode_values[] = {"tree", "flat", 0}; /*< Possible values for ltlmode. */

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->detailed_help_given = 0 ;
  args_info->full_help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->check_given = 0 ;
  args_info->formula_given = 0 ;
  args_info->buechi_given = 0 ;
  args_info->search_given = 0 ;
  args_info->findpath_given = 0 ;
  args_info->stubborn_given = 0 ;
  args_info->cycle_given = 0 ;
  args_info->symmetry_given = 0 ;
  args_info->ltlstubborn_given = 0 ;
  args_info->siphontrap_given = 0 ;
  args_info->siphondepth_given = 0 ;
  args_info->minisatargs_given = 0 ;
  args_info->siphonwitness_given = 0 ;
  args_info->stateequation_given = 0 ;
  args_info->compressed_given = 0 ;
  args_info->state_given = 0 ;
  args_info->path_given = 0 ;
  args_info->pathshape_given = 0 ;
  args_info->writeCompressed_given = 0 ;
  args_info->writeBuechi_given = 0 ;
  args_info->quiet_given = 0 ;
  args_info->reporter_given = 0 ;
  args_info->json_given = 0 ;
  args_info->jsoninclude_given = 0 ;
  args_info->nolog_given = 0 ;
  args_info->outputport_given = 0 ;
  args_info->inputport_given = 0 ;
  args_info->address_given = 0 ;
  args_info->remoteTermination_given = 0 ;
  args_info->printNet_given = 0 ;
  args_info->stats_given = 0 ;
  args_info->tscc_given = 0 ;
  args_info->timelimit_given = 0 ;
  args_info->localtimelimit_given = 0 ;
  args_info->symmtimelimit_given = 0 ;
  args_info->markinglimit_given = 0 ;
  args_info->store_given = 0 ;
  args_info->encoder_given = 0 ;
  args_info->bucketing_given = 0 ;
  args_info->hashfunctions_given = 0 ;
  args_info->ltlmode_given = 0 ;
  args_info->sweepfronts_given = 0 ;
  args_info->sweeplinedelay_given = 0 ;
  args_info->sweeplinespread_given = 0 ;
  args_info->cycleheuristic_given = 0 ;
  args_info->retrylimit_given = 0 ;
  args_info->depthlimit_given = 0 ;
  args_info->threads_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->check_arg = check_arg_modelchecking;
  args_info->check_orig = NULL;
  args_info->formula_arg = NULL;
  args_info->formula_orig = NULL;
  args_info->buechi_arg = NULL;
  args_info->buechi_orig = NULL;
  args_info->search_arg = search_arg_depth;
  args_info->search_orig = NULL;
  args_info->findpath_arg = findpath_arg_off;
  args_info->findpath_orig = NULL;
  args_info->stubborn_arg = stubborn_arg_tarjan;
  args_info->stubborn_orig = NULL;
  args_info->cycle_flag = 0;
  args_info->symmetry_flag = 0;
  args_info->ltlstubborn_arg = ltlstubborn_arg_off;
  args_info->ltlstubborn_orig = NULL;
  args_info->siphontrap_arg = siphontrap_arg_off;
  args_info->siphontrap_orig = NULL;
  args_info->siphondepth_arg = 1073741824;
  args_info->siphondepth_orig = NULL;
  args_info->minisatargs_arg = gengetopt_strdup ("");
  args_info->minisatargs_orig = NULL;
  args_info->siphonwitness_arg = gengetopt_strdup ("-");
  args_info->siphonwitness_orig = NULL;
  args_info->stateequation_arg = stateequation_arg_off;
  args_info->stateequation_orig = NULL;
  args_info->compressed_flag = 0;
  args_info->state_arg = gengetopt_strdup ("-");
  args_info->state_orig = NULL;
  args_info->path_arg = gengetopt_strdup ("-");
  args_info->path_orig = NULL;
  args_info->pathshape_arg = pathshape_arg_linear;
  args_info->pathshape_orig = NULL;
  args_info->writeCompressed_arg = gengetopt_strdup ("compressedOutput");
  args_info->writeCompressed_orig = NULL;
  args_info->writeBuechi_arg = gengetopt_strdup ("automaton");
  args_info->writeBuechi_orig = NULL;
  args_info->quiet_flag = 0;
  args_info->reporter_arg = reporter_arg_stream;
  args_info->reporter_orig = NULL;
  args_info->json_arg = gengetopt_strdup ("-");
  args_info->json_orig = NULL;
  args_info->jsoninclude_arg = NULL;
  args_info->jsoninclude_orig = NULL;
  args_info->nolog_flag = 0;
  args_info->outputport_arg = 5555;
  args_info->outputport_orig = NULL;
  args_info->inputport_arg = 5556;
  args_info->inputport_orig = NULL;
  args_info->address_arg = gengetopt_strdup ("localhost");
  args_info->address_orig = NULL;
  args_info->remoteTermination_arg = gengetopt_strdup ("goodbye");
  args_info->remoteTermination_orig = NULL;
  args_info->printNet_flag = 0;
  args_info->stats_flag = 0;
  args_info->tscc_flag = 0;
  args_info->timelimit_orig = NULL;
  args_info->localtimelimit_orig = NULL;
  args_info->symmtimelimit_orig = NULL;
  args_info->markinglimit_orig = NULL;
  args_info->store_arg = store_arg_prefix;
  args_info->store_orig = NULL;
  args_info->encoder_arg = encoder_arg_bit;
  args_info->encoder_orig = NULL;
  args_info->bucketing_arg = 16;
  args_info->bucketing_orig = NULL;
  args_info->hashfunctions_arg = 2;
  args_info->hashfunctions_orig = NULL;
  args_info->ltlmode_arg = ltlmode_arg_tree;
  args_info->ltlmode_orig = NULL;
  args_info->sweepfronts_arg = 1;
  args_info->sweepfronts_orig = NULL;
  args_info->sweeplinedelay_arg = 100;
  args_info->sweeplinedelay_orig = NULL;
  args_info->sweeplinespread_arg = 1;
  args_info->sweeplinespread_orig = NULL;
  args_info->cycleheuristic_arg = -1;
  args_info->cycleheuristic_orig = NULL;
  args_info->retrylimit_arg = 0;
  args_info->retrylimit_orig = NULL;
  args_info->depthlimit_arg = 1000000;
  args_info->depthlimit_orig = NULL;
  args_info->threads_arg = 1;
  args_info->threads_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{
  init_full_help_array(); 
  init_help_array(); 
  args_info->help_help = gengetopt_args_info_detailed_help[0] ;
  args_info->detailed_help_help = gengetopt_args_info_detailed_help[1] ;
  args_info->full_help_help = gengetopt_args_info_detailed_help[2] ;
  args_info->version_help = gengetopt_args_info_detailed_help[3] ;
  args_info->check_help = gengetopt_args_info_detailed_help[6] ;
  args_info->formula_help = gengetopt_args_info_detailed_help[8] ;
  args_info->buechi_help = gengetopt_args_info_detailed_help[10] ;
  args_info->search_help = gengetopt_args_info_detailed_help[14] ;
  args_info->findpath_help = gengetopt_args_info_detailed_help[16] ;
  args_info->stubborn_help = gengetopt_args_info_detailed_help[18] ;
  args_info->cycle_help = gengetopt_args_info_detailed_help[20] ;
  args_info->symmetry_help = gengetopt_args_info_detailed_help[22] ;
  args_info->ltlstubborn_help = gengetopt_args_info_detailed_help[24] ;
  args_info->siphontrap_help = gengetopt_args_info_detailed_help[28] ;
  args_info->siphondepth_help = gengetopt_args_info_detailed_help[30] ;
  args_info->minisatargs_help = gengetopt_args_info_detailed_help[32] ;
  args_info->siphonwitness_help = gengetopt_args_info_detailed_help[34] ;
  args_info->stateequation_help = gengetopt_args_info_detailed_help[38] ;
  args_info->compressed_help = gengetopt_args_info_detailed_help[42] ;
  args_info->state_help = gengetopt_args_info_detailed_help[46] ;
  args_info->path_help = gengetopt_args_info_detailed_help[48] ;
  args_info->pathshape_help = gengetopt_args_info_detailed_help[50] ;
  args_info->writeCompressed_help = gengetopt_args_info_detailed_help[52] ;
  args_info->writeBuechi_help = gengetopt_args_info_detailed_help[54] ;
  args_info->quiet_help = gengetopt_args_info_detailed_help[58] ;
  args_info->reporter_help = gengetopt_args_info_detailed_help[60] ;
  args_info->json_help = gengetopt_args_info_detailed_help[62] ;
  args_info->jsoninclude_help = gengetopt_args_info_detailed_help[64] ;
  args_info->jsoninclude_min = 0;
  args_info->jsoninclude_max = 0;
  args_info->nolog_help = gengetopt_args_info_detailed_help[66] ;
  args_info->outputport_help = gengetopt_args_info_detailed_help[68] ;
  args_info->inputport_help = gengetopt_args_info_detailed_help[70] ;
  args_info->address_help = gengetopt_args_info_detailed_help[72] ;
  args_info->remoteTermination_help = gengetopt_args_info_detailed_help[74] ;
  args_info->printNet_help = gengetopt_args_info_detailed_help[77] ;
  args_info->stats_help = gengetopt_args_info_detailed_help[78] ;
  args_info->tscc_help = gengetopt_args_info_detailed_help[79] ;
  args_info->timelimit_help = gengetopt_args_info_detailed_help[82] ;
  args_info->localtimelimit_help = gengetopt_args_info_detailed_help[84] ;
  args_info->symmtimelimit_help = gengetopt_args_info_detailed_help[86] ;
  args_info->markinglimit_help = gengetopt_args_info_detailed_help[88] ;
  args_info->store_help = gengetopt_args_info_detailed_help[92] ;
  args_info->encoder_help = gengetopt_args_info_detailed_help[94] ;
  args_info->bucketing_help = gengetopt_args_info_detailed_help[96] ;
  args_info->hashfunctions_help = gengetopt_args_info_detailed_help[98] ;
  args_info->ltlmode_help = gengetopt_args_info_detailed_help[100] ;
  args_info->sweepfronts_help = gengetopt_args_info_detailed_help[101] ;
  args_info->sweeplinedelay_help = gengetopt_args_info_detailed_help[103] ;
  args_info->sweeplinespread_help = gengetopt_args_info_detailed_help[105] ;
  args_info->cycleheuristic_help = gengetopt_args_info_detailed_help[106] ;
  args_info->retrylimit_help = gengetopt_args_info_detailed_help[107] ;
  args_info->depthlimit_help = gengetopt_args_info_detailed_help[109] ;
  args_info->threads_help = gengetopt_args_info_detailed_help[111] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
     CMDLINE_PARSER_VERSION);

  if (strlen(gengetopt_args_info_versiontext) > 0)
    printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void) {
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_print_full_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_full_help[i])
    printf("%s\n", gengetopt_args_info_full_help[i++]);
}

void
cmdline_parser_print_detailed_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_detailed_help[i])
    printf("%s\n", gengetopt_args_info_detailed_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);

  args_info->inputs = 0;
  args_info->inputs_num = 0;
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params = 
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}

/** @brief generic value variable */
union generic_value {
    int int_arg;
    short short_arg;
    char *string_arg;
    const char *default_string_arg;
};

/** @brief holds temporary values for multiple options */
struct generic_list
{
  union generic_value arg;
  char *orig;
  struct generic_list *next;
};

/**
 * @brief add a node at the head of the list 
 */
static void add_node(struct generic_list **list) {
  struct generic_list *new_node = (struct generic_list *) malloc (sizeof (struct generic_list));
  new_node->next = *list;
  *list = new_node;
  new_node->arg.string_arg = 0;
  new_node->orig = 0;
}

/**
 * The passed arg parameter is NOT set to 0 from this function
 */
static void
free_multiple_field(unsigned int len, void *arg, char ***orig)
{
  unsigned int i;
  if (arg) {
    for (i = 0; i < len; ++i)
      {
        free_string_field(&((*orig)[i]));
      }

    free (arg);
    free (*orig);
    *orig = 0;
  }
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{
  unsigned int i;
  free_string_field (&(args_info->check_orig));
  free_string_field (&(args_info->formula_arg));
  free_string_field (&(args_info->formula_orig));
  free_string_field (&(args_info->buechi_arg));
  free_string_field (&(args_info->buechi_orig));
  free_string_field (&(args_info->search_orig));
  free_string_field (&(args_info->findpath_orig));
  free_string_field (&(args_info->stubborn_orig));
  free_string_field (&(args_info->ltlstubborn_orig));
  free_string_field (&(args_info->siphontrap_orig));
  free_string_field (&(args_info->siphondepth_orig));
  free_string_field (&(args_info->minisatargs_arg));
  free_string_field (&(args_info->minisatargs_orig));
  free_string_field (&(args_info->siphonwitness_arg));
  free_string_field (&(args_info->siphonwitness_orig));
  free_string_field (&(args_info->stateequation_orig));
  free_string_field (&(args_info->state_arg));
  free_string_field (&(args_info->state_orig));
  free_string_field (&(args_info->path_arg));
  free_string_field (&(args_info->path_orig));
  free_string_field (&(args_info->pathshape_orig));
  free_string_field (&(args_info->writeCompressed_arg));
  free_string_field (&(args_info->writeCompressed_orig));
  free_string_field (&(args_info->writeBuechi_arg));
  free_string_field (&(args_info->writeBuechi_orig));
  free_string_field (&(args_info->reporter_orig));
  free_string_field (&(args_info->json_arg));
  free_string_field (&(args_info->json_orig));
  free_multiple_field (args_info->jsoninclude_given, (void *)(args_info->jsoninclude_arg), &(args_info->jsoninclude_orig));
  args_info->jsoninclude_arg = 0;
  free_string_field (&(args_info->outputport_orig));
  free_string_field (&(args_info->inputport_orig));
  free_string_field (&(args_info->address_arg));
  free_string_field (&(args_info->address_orig));
  free_string_field (&(args_info->remoteTermination_arg));
  free_string_field (&(args_info->remoteTermination_orig));
  free_string_field (&(args_info->timelimit_orig));
  free_string_field (&(args_info->localtimelimit_orig));
  free_string_field (&(args_info->symmtimelimit_orig));
  free_string_field (&(args_info->markinglimit_orig));
  free_string_field (&(args_info->store_orig));
  free_string_field (&(args_info->encoder_orig));
  free_string_field (&(args_info->bucketing_orig));
  free_string_field (&(args_info->hashfunctions_orig));
  free_string_field (&(args_info->ltlmode_orig));
  free_string_field (&(args_info->sweepfronts_orig));
  free_string_field (&(args_info->sweeplinedelay_orig));
  free_string_field (&(args_info->sweeplinespread_orig));
  free_string_field (&(args_info->cycleheuristic_orig));
  free_string_field (&(args_info->retrylimit_orig));
  free_string_field (&(args_info->depthlimit_orig));
  free_string_field (&(args_info->threads_orig));
  
  
  for (i = 0; i < args_info->inputs_num; ++i)
    free (args_info->inputs [i]);

  if (args_info->inputs_num)
    free (args_info->inputs);

  clear_given (args_info);
}

/**
 * @param val the value to check
 * @param values the possible values
 * @return the index of the matched value:
 * -1 if no value matched,
 * -2 if more than one value has matched
 */
static int
check_possible_values(const char *val, const char *values[])
{
  int i, found, last;
  size_t len;

  if (!val)   /* otherwise strlen() crashes below */
    return -1; /* -1 means no argument for the option */

  found = last = 0;

  for (i = 0, len = strlen(val); values[i]; ++i)
    {
      if (strncmp(val, values[i], len) == 0)
        {
          ++found;
          last = i;
          if (strlen(values[i]) == len)
            return i; /* exact macth no need to check more */
        }
    }

  if (found == 1) /* one match: OK */
    return last;

  return (found ? -2 : -1); /* return many values or none matched */
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  int found = -1;
  if (arg) {
    if (values) {
      found = check_possible_values(arg, values);      
    }
    if (found >= 0)
      fprintf(outfile, "%s=\"%s\" # %s\n", opt, arg, values[found]);
    else
      fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}

static void
write_multiple_into_file(FILE *outfile, int len, const char *opt, char **arg, const char *values[])
{
  int i;
  
  for (i = 0; i < len; ++i)
    write_into_file(outfile, opt, (arg ? arg[i] : 0), values);
}

int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->detailed_help_given)
    write_into_file(outfile, "detailed-help", 0, 0 );
  if (args_info->full_help_given)
    write_into_file(outfile, "full-help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->check_given)
    write_into_file(outfile, "check", args_info->check_orig, cmdline_parser_check_values);
  if (args_info->formula_given)
    write_into_file(outfile, "formula", args_info->formula_orig, 0);
  if (args_info->buechi_given)
    write_into_file(outfile, "buechi", args_info->buechi_orig, 0);
  if (args_info->search_given)
    write_into_file(outfile, "search", args_info->search_orig, cmdline_parser_search_values);
  if (args_info->findpath_given)
    write_into_file(outfile, "findpath", args_info->findpath_orig, cmdline_parser_findpath_values);
  if (args_info->stubborn_given)
    write_into_file(outfile, "stubborn", args_info->stubborn_orig, cmdline_parser_stubborn_values);
  if (args_info->cycle_given)
    write_into_file(outfile, "cycle", 0, 0 );
  if (args_info->symmetry_given)
    write_into_file(outfile, "symmetry", 0, 0 );
  if (args_info->ltlstubborn_given)
    write_into_file(outfile, "ltlstubborn", args_info->ltlstubborn_orig, cmdline_parser_ltlstubborn_values);
  if (args_info->siphontrap_given)
    write_into_file(outfile, "siphontrap", args_info->siphontrap_orig, cmdline_parser_siphontrap_values);
  if (args_info->siphondepth_given)
    write_into_file(outfile, "siphondepth", args_info->siphondepth_orig, 0);
  if (args_info->minisatargs_given)
    write_into_file(outfile, "minisatargs", args_info->minisatargs_orig, 0);
  if (args_info->siphonwitness_given)
    write_into_file(outfile, "siphonwitness", args_info->siphonwitness_orig, 0);
  if (args_info->stateequation_given)
    write_into_file(outfile, "stateequation", args_info->stateequation_orig, cmdline_parser_stateequation_values);
  if (args_info->compressed_given)
    write_into_file(outfile, "compressed", 0, 0 );
  if (args_info->state_given)
    write_into_file(outfile, "state", args_info->state_orig, 0);
  if (args_info->path_given)
    write_into_file(outfile, "path", args_info->path_orig, 0);
  if (args_info->pathshape_given)
    write_into_file(outfile, "pathshape", args_info->pathshape_orig, cmdline_parser_pathshape_values);
  if (args_info->writeCompressed_given)
    write_into_file(outfile, "writeCompressed", args_info->writeCompressed_orig, 0);
  if (args_info->writeBuechi_given)
    write_into_file(outfile, "writeBuechi", args_info->writeBuechi_orig, 0);
  if (args_info->quiet_given)
    write_into_file(outfile, "quiet", 0, 0 );
  if (args_info->reporter_given)
    write_into_file(outfile, "reporter", args_info->reporter_orig, cmdline_parser_reporter_values);
  if (args_info->json_given)
    write_into_file(outfile, "json", args_info->json_orig, 0);
  write_multiple_into_file(outfile, args_info->jsoninclude_given, "jsoninclude", args_info->jsoninclude_orig, cmdline_parser_jsoninclude_values);
  if (args_info->nolog_given)
    write_into_file(outfile, "nolog", 0, 0 );
  if (args_info->outputport_given)
    write_into_file(outfile, "outputport", args_info->outputport_orig, 0);
  if (args_info->inputport_given)
    write_into_file(outfile, "inputport", args_info->inputport_orig, 0);
  if (args_info->address_given)
    write_into_file(outfile, "address", args_info->address_orig, 0);
  if (args_info->remoteTermination_given)
    write_into_file(outfile, "remoteTermination", args_info->remoteTermination_orig, 0);
  if (args_info->printNet_given)
    write_into_file(outfile, "printNet", 0, 0 );
  if (args_info->stats_given)
    write_into_file(outfile, "stats", 0, 0 );
  if (args_info->tscc_given)
    write_into_file(outfile, "tscc", 0, 0 );
  if (args_info->timelimit_given)
    write_into_file(outfile, "timelimit", args_info->timelimit_orig, 0);
  if (args_info->localtimelimit_given)
    write_into_file(outfile, "localtimelimit", args_info->localtimelimit_orig, 0);
  if (args_info->symmtimelimit_given)
    write_into_file(outfile, "symmtimelimit", args_info->symmtimelimit_orig, 0);
  if (args_info->markinglimit_given)
    write_into_file(outfile, "markinglimit", args_info->markinglimit_orig, 0);
  if (args_info->store_given)
    write_into_file(outfile, "store", args_info->store_orig, cmdline_parser_store_values);
  if (args_info->encoder_given)
    write_into_file(outfile, "encoder", args_info->encoder_orig, cmdline_parser_encoder_values);
  if (args_info->bucketing_given)
    write_into_file(outfile, "bucketing", args_info->bucketing_orig, 0);
  if (args_info->hashfunctions_given)
    write_into_file(outfile, "hashfunctions", args_info->hashfunctions_orig, 0);
  if (args_info->ltlmode_given)
    write_into_file(outfile, "ltlmode", args_info->ltlmode_orig, cmdline_parser_ltlmode_values);
  if (args_info->sweepfronts_given)
    write_into_file(outfile, "sweepfronts", args_info->sweepfronts_orig, 0);
  if (args_info->sweeplinedelay_given)
    write_into_file(outfile, "sweeplinedelay", args_info->sweeplinedelay_orig, 0);
  if (args_info->sweeplinespread_given)
    write_into_file(outfile, "sweeplinespread", args_info->sweeplinespread_orig, 0);
  if (args_info->cycleheuristic_given)
    write_into_file(outfile, "cycleheuristic", args_info->cycleheuristic_orig, 0);
  if (args_info->retrylimit_given)
    write_into_file(outfile, "retrylimit", args_info->retrylimit_orig, 0);
  if (args_info->depthlimit_given)
    write_into_file(outfile, "depthlimit", args_info->depthlimit_orig, 0);
  if (args_info->threads_given)
    write_into_file(outfile, "threads", args_info->threads_orig, 0);
  

  i = EXIT_SUCCESS;
  return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

static char *
get_multiple_arg_token(const char *arg)
{
  const char *tok;
  char *ret;
  size_t len, num_of_escape, i, j;

  if (!arg)
    return 0;

  tok = strchr (arg, ',');
  num_of_escape = 0;

  /* make sure it is not escaped */
  while (tok)
    {
      if (*(tok-1) == '\\')
        {
          /* find the next one */
          tok = strchr (tok+1, ',');
          ++num_of_escape;
        }
      else
        break;
    }

  if (tok)
    len = (size_t)(tok - arg + 1);
  else
    len = strlen (arg) + 1;

  len -= num_of_escape;

  ret = (char *) malloc (len);

  i = 0;
  j = 0;
  while (arg[i] && (j < len-1))
    {
      if (arg[i] == '\\' && 
	  arg[ i + 1 ] && 
	  arg[ i + 1 ] == ',')
        ++i;

      ret[j++] = arg[i++];
    }

  ret[len-1] = '\0';

  return ret;
}

static const char *
get_multiple_arg_token_next(const char *arg)
{
  const char *tok;

  if (!arg)
    return 0;

  tok = strchr (arg, ',');

  /* make sure it is not escaped */
  while (tok)
    {
      if (*(tok-1) == '\\')
        {
          /* find the next one */
          tok = strchr (tok+1, ',');
        }
      else
        break;
    }

  if (! tok || strlen(tok) == 1)
    return 0;

  return tok+1;
}

static int
check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc);

int
check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc)
{
  int error_occurred = 0;

  if (option_given && (min > 0 || max > 0))
    {
      if (min > 0 && max > 0)
        {
          if (min == max)
            {
              /* specific occurrences */
              if (option_given != (unsigned int) min)
                {
                  fprintf (stderr, "%s: %s option occurrences must be %d\n",
                    prog_name, option_desc, min);
                  error_occurred = 1;
                }
            }
          else if (option_given < (unsigned int) min
                || option_given > (unsigned int) max)
            {
              /* range occurrences */
              fprintf (stderr, "%s: %s option occurrences must be between %d and %d\n",
                prog_name, option_desc, min, max);
              error_occurred = 1;
            }
        }
      else if (min > 0)
        {
          /* at least check */
          if (option_given < min)
            {
              fprintf (stderr, "%s: %s option occurrences must be at least %d\n",
                prog_name, option_desc, min);
              error_occurred = 1;
            }
        }
      else if (max > 0)
        {
          /* at most check */
          if (option_given > max)
            {
              fprintf (stderr, "%s: %s option occurrences must be at most %d\n",
                prog_name, option_desc, max);
              error_occurred = 1;
            }
        }
    }
    
  return error_occurred;
}
int
cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, 0);

  return result;
}

int
cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);

  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (cmdline_parser_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  return result;
}

int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error_occurred = 0;
  FIX_UNUSED (additional_error);

  /* checks for required options */
  if (check_multiple_option_occurrences(prog_name, args_info->jsoninclude_given, args_info->jsoninclude_min, args_info->jsoninclude_max, "'--jsoninclude'"))
     error_occurred = 1;
  
  
  /* checks for dependences among options */
  if (args_info->pathshape_given && ! args_info->path_given)
    {
      fprintf (stderr, "%s: '--pathshape' option depends on option 'path'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  if (args_info->jsoninclude_given && ! args_info->json_given)
    {
      fprintf (stderr, "%s: '--jsoninclude' option depends on option 'json'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }

  return error_occurred;
}

/*
 * Extracted from the glibc source tree, version 2.3.6
 *
 * Licensed under the GPL as per the whole glibc source tree.
 *
 * This file was modified so that getopt_long can be called
 * many times without risking previous memory to be spoiled.
 *
 * Modified by Andre Noll and Lorenzo Bettini for use in
 * GNU gengetopt generated files.
 *
 */

/* 
 * we must include anything we need since this file is not thought to be
 * inserted in a file already using getopt.h
 *
 * Lorenzo
 */

struct option
{
  const char *name;
  /* has_arg can't be an enum because some compilers complain about
     type mismatches in all the code that assumes it is an int.  */
  int has_arg;
  int *flag;
  int val;
};

/* This version of `getopt' appears to the caller like standard Unix `getopt'
   but it behaves differently for the user, since it allows the user
   to intersperse the options with the other arguments.

   As `getopt' works, it permutes the elements of ARGV so that,
   when it is done, all the options precede everything else.  Thus
   all application programs are extended to handle flexible argument order.
*/
/*
   If the field `flag' is not NULL, it points to a variable that is set
   to the value given in the field `val' when the option is found, but
   left unchanged if the option is not found.

   To have a long-named option do something other than set an `int' to
   a compiled-in constant, such as set a value from `custom_optarg', set the
   option's `flag' field to zero and its `val' field to a nonzero
   value (the equivalent single-letter option character, if there is
   one).  For long options that have a zero `flag' field, `getopt'
   returns the contents of the `val' field.  */

/* Names for the values of the `has_arg' field of `struct option'.  */
#ifndef no_argument
#define no_argument		0
#endif

#ifndef required_argument
#define required_argument	1
#endif

#ifndef optional_argument
#define optional_argument	2
#endif

struct custom_getopt_data {
	/*
	 * These have exactly the same meaning as the corresponding global variables,
	 * except that they are used for the reentrant versions of getopt.
	 */
	int custom_optind;
	int custom_opterr;
	int custom_optopt;
	char *custom_optarg;

	/* True if the internal members have been initialized.  */
	int initialized;

	/*
	 * The next char to be scanned in the option-element in which the last option
	 * character we returned was found.  This allows us to pick up the scan where
	 * we left off.  If this is zero, or a null string, it means resume the scan by
	 * advancing to the next ARGV-element.
	 */
	char *nextchar;

	/*
	 * Describe the part of ARGV that contains non-options that have been skipped.
	 * `first_nonopt' is the index in ARGV of the first of them; `last_nonopt' is
	 * the index after the last of them.
	 */
	int first_nonopt;
	int last_nonopt;
};

/*
 * the variables optarg, optind, opterr and optopt are renamed with
 * the custom_ prefix so that they don't interfere with getopt ones.
 *
 * Moreover they're static so they are visible only from within the
 * file where this very file will be included.
 */

/*
 * For communication from `custom_getopt' to the caller.  When `custom_getopt' finds an
 * option that takes an argument, the argument value is returned here.
 */
static char *custom_optarg;

/*
 * Index in ARGV of the next element to be scanned.  This is used for
 * communication to and from the caller and for communication between
 * successive calls to `custom_getopt'.
 *
 * On entry to `custom_getopt', 1 means this is the first call; initialize.
 *
 * When `custom_getopt' returns -1, this is the index of the first of the non-option
 * elements that the caller should itself scan.
 *
 * Otherwise, `custom_optind' communicates from one call to the next how much of ARGV
 * has been scanned so far.
 *
 * 1003.2 says this must be 1 before any call.
 */
static int custom_optind = 1;

/*
 * Callers store zero here to inhibit the error message for unrecognized
 * options.
 */
static int custom_opterr = 1;

/*
 * Set to an option character which was unrecognized.  This must be initialized
 * on some systems to avoid linking in the system's own getopt implementation.
 */
static int custom_optopt = '?';

/*
 * Exchange two adjacent subsequences of ARGV.  One subsequence is elements
 * [first_nonopt,last_nonopt) which contains all the non-options that have been
 * skipped so far.  The other is elements [last_nonopt,custom_optind), which contains
 * all the options processed since those non-options were skipped.
 * `first_nonopt' and `last_nonopt' are relocated so that they describe the new
 * indices of the non-options in ARGV after they are moved.
 */
static void exchange(char **argv, struct custom_getopt_data *d)
{
	int bottom = d->first_nonopt;
	int middle = d->last_nonopt;
	int top = d->custom_optind;
	char *tem;

	/*
	 * Exchange the shorter segment with the far end of the longer segment.
	 * That puts the shorter segment into the right place.  It leaves the
	 * longer segment in the right place overall, but it consists of two
	 * parts that need to be swapped next.
	 */
	while (top > middle && middle > bottom) {
		if (top - middle > middle - bottom) {
			/* Bottom segment is the short one.  */
			int len = middle - bottom;
			int i;

			/* Swap it with the top part of the top segment.  */
			for (i = 0; i < len; i++) {
				tem = argv[bottom + i];
				argv[bottom + i] =
					argv[top - (middle - bottom) + i];
				argv[top - (middle - bottom) + i] = tem;
			}
			/* Exclude the moved bottom segment from further swapping.  */
			top -= len;
		} else {
			/* Top segment is the short one.  */
			int len = top - middle;
			int i;

			/* Swap it with the bottom part of the bottom segment.  */
			for (i = 0; i < len; i++) {
				tem = argv[bottom + i];
				argv[bottom + i] = argv[middle + i];
				argv[middle + i] = tem;
			}
			/* Exclude the moved top segment from further swapping.  */
			bottom += len;
		}
	}
	/* Update records for the slots the non-options now occupy.  */
	d->first_nonopt += (d->custom_optind - d->last_nonopt);
	d->last_nonopt = d->custom_optind;
}

/* Initialize the internal data when the first call is made.  */
static void custom_getopt_initialize(struct custom_getopt_data *d)
{
	/*
	 * Start processing options with ARGV-element 1 (since ARGV-element 0
	 * is the program name); the sequence of previously skipped non-option
	 * ARGV-elements is empty.
	 */
	d->first_nonopt = d->last_nonopt = d->custom_optind;
	d->nextchar = NULL;
	d->initialized = 1;
}

#define NONOPTION_P (argv[d->custom_optind][0] != '-' || argv[d->custom_optind][1] == '\0')

/* return: zero: continue, nonzero: return given value to user */
static int shuffle_argv(int argc, char *const *argv,const struct option *longopts,
	struct custom_getopt_data *d)
{
	/*
	 * Give FIRST_NONOPT & LAST_NONOPT rational values if CUSTOM_OPTIND has been
	 * moved back by the user (who may also have changed the arguments).
	 */
	if (d->last_nonopt > d->custom_optind)
		d->last_nonopt = d->custom_optind;
	if (d->first_nonopt > d->custom_optind)
		d->first_nonopt = d->custom_optind;
	/*
	 * If we have just processed some options following some
	 * non-options, exchange them so that the options come first.
	 */
	if (d->first_nonopt != d->last_nonopt &&
			d->last_nonopt != d->custom_optind)
		exchange((char **) argv, d);
	else if (d->last_nonopt != d->custom_optind)
		d->first_nonopt = d->custom_optind;
	/*
	 * Skip any additional non-options and extend the range of
	 * non-options previously skipped.
	 */
	while (d->custom_optind < argc && NONOPTION_P)
		d->custom_optind++;
	d->last_nonopt = d->custom_optind;
	/*
	 * The special ARGV-element `--' means premature end of options.  Skip
	 * it like a null option, then exchange with previous non-options as if
	 * it were an option, then skip everything else like a non-option.
	 */
	if (d->custom_optind != argc && !strcmp(argv[d->custom_optind], "--")) {
		d->custom_optind++;
		if (d->first_nonopt != d->last_nonopt
				&& d->last_nonopt != d->custom_optind)
			exchange((char **) argv, d);
		else if (d->first_nonopt == d->last_nonopt)
			d->first_nonopt = d->custom_optind;
		d->last_nonopt = argc;
		d->custom_optind = argc;
	}
	/*
	 * If we have done all the ARGV-elements, stop the scan and back over
	 * any non-options that we skipped and permuted.
	 */
	if (d->custom_optind == argc) {
		/*
		 * Set the next-arg-index to point at the non-options that we
		 * previously skipped, so the caller will digest them.
		 */
		if (d->first_nonopt != d->last_nonopt)
			d->custom_optind = d->first_nonopt;
		return -1;
	}
	/*
	 * If we have come to a non-option and did not permute it, either stop
	 * the scan or describe it to the caller and pass it by.
	 */
	if (NONOPTION_P) {
		d->custom_optarg = argv[d->custom_optind++];
		return 1;
	}
	/*
	 * We have found another option-ARGV-element. Skip the initial
	 * punctuation.
	 */
	d->nextchar = (argv[d->custom_optind] + 1 + (longopts != NULL && argv[d->custom_optind][1] == '-'));
	return 0;
}

/*
 * Check whether the ARGV-element is a long option.
 *
 * If there's a long option "fubar" and the ARGV-element is "-fu", consider
 * that an abbreviation of the long option, just like "--fu", and not "-f" with
 * arg "u".
 *
 * This distinction seems to be the most useful approach.
 *
 */
static int check_long_opt(int argc, char *const *argv, const char *optstring,
		const struct option *longopts, int *longind,
		int print_errors, struct custom_getopt_data *d)
{
	char *nameend;
	const struct option *p;
	const struct option *pfound = NULL;
	int exact = 0;
	int ambig = 0;
	int indfound = -1;
	int option_index;

	for (nameend = d->nextchar; *nameend && *nameend != '='; nameend++)
		/* Do nothing.  */ ;

	/* Test all long options for either exact match or abbreviated matches */
	for (p = longopts, option_index = 0; p->name; p++, option_index++)
		if (!strncmp(p->name, d->nextchar, nameend - d->nextchar)) {
			if ((unsigned int) (nameend - d->nextchar)
					== (unsigned int) strlen(p->name)) {
				/* Exact match found.  */
				pfound = p;
				indfound = option_index;
				exact = 1;
				break;
			} else if (pfound == NULL) {
				/* First nonexact match found.  */
				pfound = p;
				indfound = option_index;
			} else if (pfound->has_arg != p->has_arg
					|| pfound->flag != p->flag
					|| pfound->val != p->val)
				/* Second or later nonexact match found.  */
				ambig = 1;
		}
	if (ambig && !exact) {
		if (print_errors) {
			fprintf(stderr,
				"%s: option `%s' is ambiguous\n",
				argv[0], argv[d->custom_optind]);
		}
		d->nextchar += strlen(d->nextchar);
		d->custom_optind++;
		d->custom_optopt = 0;
		return '?';
	}
	if (pfound) {
		option_index = indfound;
		d->custom_optind++;
		if (*nameend) {
			if (pfound->has_arg != no_argument)
				d->custom_optarg = nameend + 1;
			else {
				if (print_errors) {
					if (argv[d->custom_optind - 1][1] == '-') {
						/* --option */
						fprintf(stderr, "%s: option `--%s' doesn't allow an argument\n",
							argv[0], pfound->name);
					} else {
						/* +option or -option */
						fprintf(stderr, "%s: option `%c%s' doesn't allow an argument\n",
							argv[0], argv[d->custom_optind - 1][0], pfound->name);
					}

				}
				d->nextchar += strlen(d->nextchar);
				d->custom_optopt = pfound->val;
				return '?';
			}
		} else if (pfound->has_arg == required_argument) {
			if (d->custom_optind < argc)
				d->custom_optarg = argv[d->custom_optind++];
			else {
				if (print_errors) {
					fprintf(stderr,
						"%s: option `%s' requires an argument\n",
						argv[0],
						argv[d->custom_optind - 1]);
				}
				d->nextchar += strlen(d->nextchar);
				d->custom_optopt = pfound->val;
				return optstring[0] == ':' ? ':' : '?';
			}
		}
		d->nextchar += strlen(d->nextchar);
		if (longind != NULL)
			*longind = option_index;
		if (pfound->flag) {
			*(pfound->flag) = pfound->val;
			return 0;
		}
		return pfound->val;
	}
	/*
	 * Can't find it as a long option.  If this is not getopt_long_only, or
	 * the option starts with '--' or is not a valid short option, then
	 * it's an error.  Otherwise interpret it as a short option.
	 */
	if (print_errors) {
		if (argv[d->custom_optind][1] == '-') {
			/* --option */
			fprintf(stderr,
				"%s: unrecognized option `--%s'\n",
				argv[0], d->nextchar);
		} else {
			/* +option or -option */
			fprintf(stderr,
				"%s: unrecognized option `%c%s'\n",
				argv[0], argv[d->custom_optind][0],
				d->nextchar);
		}
	}
	d->nextchar = (char *) "";
	d->custom_optind++;
	d->custom_optopt = 0;
	return '?';
}

static int check_short_opt(int argc, char *const *argv, const char *optstring,
		int print_errors, struct custom_getopt_data *d)
{
	char c = *d->nextchar++;
	const char *temp = strchr(optstring, c);

	/* Increment `custom_optind' when we start to process its last character.  */
	if (*d->nextchar == '\0')
		++d->custom_optind;
	if (!temp || c == ':') {
		if (print_errors)
			fprintf(stderr, "%s: invalid option -- %c\n", argv[0], c);

		d->custom_optopt = c;
		return '?';
	}
	if (temp[1] == ':') {
		if (temp[2] == ':') {
			/* This is an option that accepts an argument optionally.  */
			if (*d->nextchar != '\0') {
				d->custom_optarg = d->nextchar;
				d->custom_optind++;
			} else
				d->custom_optarg = NULL;
			d->nextchar = NULL;
		} else {
			/* This is an option that requires an argument.  */
			if (*d->nextchar != '\0') {
				d->custom_optarg = d->nextchar;
				/*
				 * If we end this ARGV-element by taking the
				 * rest as an arg, we must advance to the next
				 * element now.
				 */
				d->custom_optind++;
			} else if (d->custom_optind == argc) {
				if (print_errors) {
					fprintf(stderr,
						"%s: option requires an argument -- %c\n",
						argv[0], c);
				}
				d->custom_optopt = c;
				if (optstring[0] == ':')
					c = ':';
				else
					c = '?';
			} else
				/*
				 * We already incremented `custom_optind' once;
				 * increment it again when taking next ARGV-elt
				 * as argument.
				 */
				d->custom_optarg = argv[d->custom_optind++];
			d->nextchar = NULL;
		}
	}
	return c;
}

/*
 * Scan elements of ARGV for option characters given in OPTSTRING.
 *
 * If an element of ARGV starts with '-', and is not exactly "-" or "--",
 * then it is an option element.  The characters of this element
 * (aside from the initial '-') are option characters.  If `getopt'
 * is called repeatedly, it returns successively each of the option characters
 * from each of the option elements.
 *
 * If `getopt' finds another option character, it returns that character,
 * updating `custom_optind' and `nextchar' so that the next call to `getopt' can
 * resume the scan with the following option character or ARGV-element.
 *
 * If there are no more option characters, `getopt' returns -1.
 * Then `custom_optind' is the index in ARGV of the first ARGV-element
 * that is not an option.  (The ARGV-elements have been permuted
 * so that those that are not options now come last.)
 *
 * OPTSTRING is a string containing the legitimate option characters.
 * If an option character is seen that is not listed in OPTSTRING,
 * return '?' after printing an error message.  If you set `custom_opterr' to
 * zero, the error message is suppressed but we still return '?'.
 *
 * If a char in OPTSTRING is followed by a colon, that means it wants an arg,
 * so the following text in the same ARGV-element, or the text of the following
 * ARGV-element, is returned in `custom_optarg'.  Two colons mean an option that
 * wants an optional arg; if there is text in the current ARGV-element,
 * it is returned in `custom_optarg', otherwise `custom_optarg' is set to zero.
 *
 * If OPTSTRING starts with `-' or `+', it requests different methods of
 * handling the non-option ARGV-elements.
 * See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
 *
 * Long-named options begin with `--' instead of `-'.
 * Their names may be abbreviated as long as the abbreviation is unique
 * or is an exact match for some defined option.  If they have an
 * argument, it follows the option name in the same ARGV-element, separated
 * from the option name by a `=', or else the in next ARGV-element.
 * When `getopt' finds a long-named option, it returns 0 if that option's
 * `flag' field is nonzero, the value of the option's `val' field
 * if the `flag' field is zero.
 *
 * The elements of ARGV aren't really const, because we permute them.
 * But we pretend they're const in the prototype to be compatible
 * with other systems.
 *
 * LONGOPTS is a vector of `struct option' terminated by an
 * element containing a name which is zero.
 *
 * LONGIND returns the index in LONGOPT of the long-named option found.
 * It is only valid when a long-named option has been found by the most
 * recent call.
 *
 * Return the option character from OPTS just read.  Return -1 when there are
 * no more options.  For unrecognized options, or options missing arguments,
 * `custom_optopt' is set to the option letter, and '?' is returned.
 *
 * The OPTS string is a list of characters which are recognized option letters,
 * optionally followed by colons, specifying that that letter takes an
 * argument, to be placed in `custom_optarg'.
 *
 * If a letter in OPTS is followed by two colons, its argument is optional.
 * This behavior is specific to the GNU `getopt'.
 *
 * The argument `--' causes premature termination of argument scanning,
 * explicitly telling `getopt' that there are no more options.  If OPTS begins
 * with `--', then non-option arguments are treated as arguments to the option
 * '\0'.  This behavior is specific to the GNU `getopt'.
 */

static int getopt_internal_r(int argc, char *const *argv, const char *optstring,
		const struct option *longopts, int *longind,
		struct custom_getopt_data *d)
{
	int ret, print_errors = d->custom_opterr;

	if (optstring[0] == ':')
		print_errors = 0;
	if (argc < 1)
		return -1;
	d->custom_optarg = NULL;

	/* 
	 * This is a big difference with GNU getopt, since optind == 0
	 * means initialization while here 1 means first call.
	 */
	if (d->custom_optind == 0 || !d->initialized) {
		if (d->custom_optind == 0)
			d->custom_optind = 1;	/* Don't scan ARGV[0], the program name.  */
		custom_getopt_initialize(d);
	}
	if (d->nextchar == NULL || *d->nextchar == '\0') {
		ret = shuffle_argv(argc, argv, longopts, d);
		if (ret)
			return ret;
	}
	if (longopts && (argv[d->custom_optind][1] == '-' ))
		return check_long_opt(argc, argv, optstring, longopts,
			longind, print_errors, d);
	return check_short_opt(argc, argv, optstring, print_errors, d);
}

static int custom_getopt_internal(int argc, char *const *argv, const char *optstring,
	const struct option *longopts, int *longind)
{
	int result;
	/* Keep a global copy of all internal members of d */
	static struct custom_getopt_data d;

	d.custom_optind = custom_optind;
	d.custom_opterr = custom_opterr;
	result = getopt_internal_r(argc, argv, optstring, longopts,
		longind, &d);
	custom_optind = d.custom_optind;
	custom_optarg = d.custom_optarg;
	custom_optopt = d.custom_optopt;
	return result;
}

static int custom_getopt_long (int argc, char *const *argv, const char *options,
	const struct option *long_options, int *opt_index)
{
	return custom_getopt_internal(argc, argv, options, long_options,
		opt_index);
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  if (possible_values && (found = check_possible_values((value ? value : default_value), possible_values)) < 0)
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s' (`-%c')%s\n", 
          package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt, short_opt,
          (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s'%s\n", 
          package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt,
          (additional_error ? additional_error : ""));
      return 1; /* failure */
    }
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_SHORT:
    if (val) *((short *)field) = (short)strtol (val, &stop_char, 0);
    break;
  case ARG_ENUM:
    if (val) *((int *)field) = found;
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
  case ARG_SHORT:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}

/**
 * @brief store information about a multiple option in a temporary list
 * @param list where to (temporarily) store multiple options
 */
static
int update_multiple_arg_temp(struct generic_list **list,
               unsigned int *prev_given, const char *val,
               const char *possible_values[], const char *default_value,
               cmdline_parser_arg_type arg_type,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  /* store single arguments */
  char *multi_token;
  const char *multi_next;

  if (arg_type == ARG_NO) {
    (*prev_given)++;
    return 0; /* OK */
  }

  multi_token = get_multiple_arg_token(val);
  multi_next = get_multiple_arg_token_next (val);

  while (1)
    {
      add_node (list);
      if (update_arg((void *)&((*list)->arg), &((*list)->orig), 0,
          prev_given, multi_token, possible_values, default_value, 
          arg_type, 0, 1, 1, 1, long_opt, short_opt, additional_error)) {
        if (multi_token) free(multi_token);
        return 1; /* failure */
      }

      if (multi_next)
        {
          multi_token = get_multiple_arg_token(multi_next);
          multi_next = get_multiple_arg_token_next (multi_next);
        }
      else
        break;
    }

  return 0; /* OK */
}

/**
 * @brief free the passed list (including possible string argument)
 */
static
void free_list(struct generic_list *list, short string_arg)
{
  if (list) {
    struct generic_list *tmp;
    while (list)
      {
        tmp = list;
        if (string_arg && list->arg.string_arg)
          free (list->arg.string_arg);
        if (list->orig)
          free (list->orig);
        list = list->next;
        free (tmp);
      }
  }
}

/**
 * @brief updates a multiple option starting from the passed list
 */
static
void update_multiple_arg(void *field, char ***orig_field,
               unsigned int field_given, unsigned int prev_given, union generic_value *default_value,
               cmdline_parser_arg_type arg_type,
               struct generic_list *list)
{
  int i;
  struct generic_list *tmp;

  if (prev_given && list) {
    *orig_field = (char **) realloc (*orig_field, (field_given + prev_given) * sizeof (char *));

    switch(arg_type) {
    case ARG_INT:
    case ARG_ENUM:
      *((int **)field) = (int *)realloc (*((int **)field), (field_given + prev_given) * sizeof (int)); break;
    case ARG_SHORT:
      *((short **)field) = (short *)realloc (*((short **)field), (field_given + prev_given) * sizeof (short)); break;
    case ARG_STRING:
      *((char ***)field) = (char **)realloc (*((char ***)field), (field_given + prev_given) * sizeof (char *)); break;
    default:
      break;
    };
    
    for (i = (prev_given - 1); i >= 0; --i)
      {
        tmp = list;
        
        switch(arg_type) {
        case ARG_INT:
          (*((int **)field))[i + field_given] = tmp->arg.int_arg; break;
        case ARG_SHORT:
          (*((short **)field))[i + field_given] = tmp->arg.short_arg; break;
        case ARG_ENUM:
          (*((int **)field))[i + field_given] = tmp->arg.int_arg; break;
        case ARG_STRING:
          (*((char ***)field))[i + field_given] = tmp->arg.string_arg; break;
        default:
          break;
        }        
        (*orig_field) [i + field_given] = list->orig;
        list = list->next;
        free (tmp);
      }
  } else { /* set the default value */
    if (default_value && ! field_given) {
      switch(arg_type) {
      case ARG_INT:
      case ARG_ENUM:
        if (! *((int **)field)) {
          *((int **)field) = (int *)malloc (sizeof (int));
          (*((int **)field))[0] = default_value->int_arg; 
        }
        break;
      case ARG_SHORT:
        if (! *((short **)field)) {
          *((short **)field) = (short *)malloc (sizeof (short));
          (*((short **)field))[0] = default_value->short_arg;
        }
        break;
      case ARG_STRING:
        if (! *((char ***)field)) {
          *((char ***)field) = (char **)malloc (sizeof (char *));
          (*((char ***)field))[0] = gengetopt_strdup(default_value->string_arg);
        }
        break;
      default: break;
      }
      if (!(*orig_field)) {
        *orig_field = (char **) malloc (sizeof (char *));
        (*orig_field)[0] = 0;
      }
    }
  }
}

int
cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  struct generic_list * jsoninclude_list = NULL;
  int error_occurred = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;

  char *optarg;
  int optind;
  int opterr;
  int optopt;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "detailed-help",	0, NULL, 0 },
        { "full-help",	0, NULL, 0 },
        { "version",	0, NULL, 'V' },
        { "check",	1, NULL, 'c' },
        { "formula",	1, NULL, 'f' },
        { "buechi",	1, NULL, 0 },
        { "search",	1, NULL, 0 },
        { "findpath",	1, NULL, 0 },
        { "stubborn",	1, NULL, 0 },
        { "cycle",	0, NULL, 0 },
        { "symmetry",	0, NULL, 0 },
        { "ltlstubborn",	1, NULL, 0 },
        { "siphontrap",	1, NULL, 0 },
        { "siphondepth",	1, NULL, 0 },
        { "minisatargs",	1, NULL, 0 },
        { "siphonwitness",	2, NULL, 0 },
        { "stateequation",	1, NULL, 0 },
        { "compressed",	0, NULL, 0 },
        { "state",	2, NULL, 's' },
        { "path",	2, NULL, 'p' },
        { "pathshape",	2, NULL, 0 },
        { "writeCompressed",	2, NULL, 0 },
        { "writeBuechi",	2, NULL, 0 },
        { "quiet",	0, NULL, 'q' },
        { "reporter",	1, NULL, 'r' },
        { "json",	2, NULL, 'j' },
        { "jsoninclude",	1, NULL, 0 },
        { "nolog",	0, NULL, 0 },
        { "outputport",	1, NULL, 0 },
        { "inputport",	1, NULL, 0 },
        { "address",	1, NULL, 0 },
        { "remoteTermination",	2, NULL, 0 },
        { "printNet",	0, NULL, 0 },
        { "stats",	0, NULL, 0 },
        { "tscc",	0, NULL, 0 },
        { "timelimit",	1, NULL, 0 },
        { "localtimelimit",	1, NULL, 0 },
        { "symmtimelimit",	1, NULL, 0 },
        { "markinglimit",	1, NULL, 0 },
        { "store",	1, NULL, 0 },
        { "encoder",	1, NULL, 0 },
        { "bucketing",	2, NULL, 0 },
        { "hashfunctions",	1, NULL, 0 },
        { "ltlmode",	1, NULL, 0 },
        { "sweepfronts",	1, NULL, 0 },
        { "sweeplinedelay",	1, NULL, 0 },
        { "sweeplinespread",	1, NULL, 0 },
        { "cycleheuristic",	1, NULL, 0 },
        { "retrylimit",	1, NULL, 0 },
        { "depthlimit",	1, NULL, 0 },
        { "threads",	1, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      custom_optarg = optarg;
      custom_optind = optind;
      custom_opterr = opterr;
      custom_optopt = optopt;

      c = custom_getopt_long (argc, argv, "hVc:f:s::p::qr:j::", long_options, &option_index);

      optarg = custom_optarg;
      optind = custom_optind;
      opterr = custom_opterr;
      optopt = custom_optopt;

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'c':	/* Verify a property.  */
        
        
          if (update_arg( (void *)&(args_info->check_arg), 
               &(args_info->check_orig), &(args_info->check_given),
              &(local_args_info.check_given), optarg, cmdline_parser_check_values, "modelchecking", ARG_ENUM,
              check_ambiguity, override, 0, 0,
              "check", 'c',
              additional_error))
            goto failure;
        
          break;
        case 'f':	/* Check a formula.  */
        
        
          if (update_arg( (void *)&(args_info->formula_arg), 
               &(args_info->formula_orig), &(args_info->formula_given),
              &(local_args_info.formula_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "formula", 'f',
              additional_error))
            goto failure;
        
          break;
        case 's':	/* Print witness state.  */
        
        
          if (update_arg( (void *)&(args_info->state_arg), 
               &(args_info->state_orig), &(args_info->state_given),
              &(local_args_info.state_given), optarg, 0, "-", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "state", 's',
              additional_error))
            goto failure;
        
          break;
        case 'p':	/* Print witness path.  */
        
        
          if (update_arg( (void *)&(args_info->path_arg), 
               &(args_info->path_orig), &(args_info->path_given),
              &(local_args_info.path_given), optarg, 0, "-", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "path", 'p',
              additional_error))
            goto failure;
        
          break;
        case 'q':	/* Suppress messages..  */
        
        
          if (update_arg((void *)&(args_info->quiet_flag), 0, &(args_info->quiet_given),
              &(local_args_info.quiet_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "quiet", 'q',
              additional_error))
            goto failure;
        
          break;
        case 'r':	/* Select a reporting procedure..  */
        
        
          if (update_arg( (void *)&(args_info->reporter_arg), 
               &(args_info->reporter_orig), &(args_info->reporter_given),
              &(local_args_info.reporter_given), optarg, cmdline_parser_reporter_values, "stream", ARG_ENUM,
              check_ambiguity, override, 0, 0,
              "reporter", 'r',
              additional_error))
            goto failure;
        
          break;
        case 'j':	/* Output structured data in JSON format..  */
        
        
          if (update_arg( (void *)&(args_info->json_arg), 
               &(args_info->json_orig), &(args_info->json_given),
              &(local_args_info.json_given), optarg, 0, "-", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "json", 'j',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          if (strcmp (long_options[option_index].name, "detailed-help") == 0) {
            cmdline_parser_print_detailed_help ();
            cmdline_parser_free (&local_args_info);
            exit (EXIT_SUCCESS);
          }

          if (strcmp (long_options[option_index].name, "full-help") == 0) {
            cmdline_parser_print_full_help ();
            cmdline_parser_free (&local_args_info);
            exit (EXIT_SUCCESS);
          }

          /* Check a linear time property specified as a Büchi automaton.  */
          if (strcmp (long_options[option_index].name, "buechi") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->buechi_arg), 
                 &(args_info->buechi_orig), &(args_info->buechi_given),
                &(local_args_info.buechi_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "buechi", '-',
                additional_error))
              goto failure;
          
          }
          /* Search the state space using a particular strategy.  */
          else if (strcmp (long_options[option_index].name, "search") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->search_arg), 
                 &(args_info->search_orig), &(args_info->search_given),
                &(local_args_info.search_given), optarg, cmdline_parser_search_values, "depth", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "search", '-',
                additional_error))
              goto failure;
          
          }
          /* Perform repeated runs without storing states.  */
          else if (strcmp (long_options[option_index].name, "findpath") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->findpath_arg), 
                 &(args_info->findpath_orig), &(args_info->findpath_given),
                &(local_args_info.findpath_given), optarg, cmdline_parser_findpath_values, "off", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "findpath", '-',
                additional_error))
              goto failure;
          
          }
          /* Apply a particular scheme for computing stubborn sets..  */
          else if (strcmp (long_options[option_index].name, "stubborn") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->stubborn_arg), 
                 &(args_info->stubborn_orig), &(args_info->stubborn_given),
                &(local_args_info.stubborn_given), optarg, cmdline_parser_stubborn_values, "tarjan", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "stubborn", '-',
                additional_error))
              goto failure;
          
          }
          /* Apply transition invariant based reduction..  */
          else if (strcmp (long_options[option_index].name, "cycle") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->cycle_flag), 0, &(args_info->cycle_given),
                &(local_args_info.cycle_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "cycle", '-',
                additional_error))
              goto failure;
          
          }
          /* Apply symmetry reduction..  */
          else if (strcmp (long_options[option_index].name, "symmetry") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->symmetry_flag), 0, &(args_info->symmetry_given),
                &(local_args_info.symmetry_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "symmetry", '-',
                additional_error))
              goto failure;
          
          }
          /* Apply computing stubborn sets for LTL..  */
          else if (strcmp (long_options[option_index].name, "ltlstubborn") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ltlstubborn_arg), 
                 &(args_info->ltlstubborn_orig), &(args_info->ltlstubborn_given),
                &(local_args_info.ltlstubborn_given), optarg, cmdline_parser_ltlstubborn_values, "off", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "ltlstubborn", '-',
                additional_error))
              goto failure;
          
          }
          /* Check for deadlock freedom by exploring the siphon/trap property.  */
          else if (strcmp (long_options[option_index].name, "siphontrap") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->siphontrap_arg), 
                 &(args_info->siphontrap_orig), &(args_info->siphontrap_given),
                &(local_args_info.siphontrap_given), optarg, cmdline_parser_siphontrap_values, "off", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "siphontrap", '-',
                additional_error))
              goto failure;
          
          }
          /* Control the length of the formula for the siphon/trap check..  */
          else if (strcmp (long_options[option_index].name, "siphondepth") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->siphondepth_arg), 
                 &(args_info->siphondepth_orig), &(args_info->siphondepth_given),
                &(local_args_info.siphondepth_given), optarg, 0, "1073741824", ARG_INT,
                check_ambiguity, override, 0, 0,
                "siphondepth", '-',
                additional_error))
              goto failure;
          
          }
          /* Pass options to the integrated Minisat SAT solver..  */
          else if (strcmp (long_options[option_index].name, "minisatargs") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->minisatargs_arg), 
                 &(args_info->minisatargs_orig), &(args_info->minisatargs_given),
                &(local_args_info.minisatargs_given), optarg, 0, "", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "minisatargs", '-',
                additional_error))
              goto failure;
          
          }
          /* Print witness siphon and trap.  */
          else if (strcmp (long_options[option_index].name, "siphonwitness") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->siphonwitness_arg), 
                 &(args_info->siphonwitness_orig), &(args_info->siphonwitness_given),
                &(local_args_info.siphonwitness_given), optarg, 0, "-", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "siphonwitness", '-',
                additional_error))
              goto failure;
          
          }
          /* Checking reachability of petri net state equation.  */
          else if (strcmp (long_options[option_index].name, "stateequation") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->stateequation_arg), 
                 &(args_info->stateequation_orig), &(args_info->stateequation_given),
                &(local_args_info.stateequation_given), optarg, cmdline_parser_stateequation_values, "off", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "stateequation", '-',
                additional_error))
              goto failure;
          
          }
          /* Read a compressed file.  */
          else if (strcmp (long_options[option_index].name, "compressed") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->compressed_flag), 0, &(args_info->compressed_given),
                &(local_args_info.compressed_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "compressed", '-',
                additional_error))
              goto failure;
          
          }
          /* Select the shape of the witness path.  */
          else if (strcmp (long_options[option_index].name, "pathshape") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->pathshape_arg), 
                 &(args_info->pathshape_orig), &(args_info->pathshape_given),
                &(local_args_info.pathshape_given), optarg, cmdline_parser_pathshape_values, "linear", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "pathshape", '-',
                additional_error))
              goto failure;
          
          }
          /* Write a compressed file.  */
          else if (strcmp (long_options[option_index].name, "writeCompressed") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->writeCompressed_arg), 
                 &(args_info->writeCompressed_orig), &(args_info->writeCompressed_given),
                &(local_args_info.writeCompressed_given), optarg, 0, "compressedOutput", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "writeCompressed", '-',
                additional_error))
              goto failure;
          
          }
          /* Write a Buechi automaton.  */
          else if (strcmp (long_options[option_index].name, "writeBuechi") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->writeBuechi_arg), 
                 &(args_info->writeBuechi_orig), &(args_info->writeBuechi_given),
                &(local_args_info.writeBuechi_given), optarg, 0, "automaton", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "writeBuechi", '-',
                additional_error))
              goto failure;
          
          }
          /* Control which data should be included in the JSON output..  */
          else if (strcmp (long_options[option_index].name, "jsoninclude") == 0)
          {
          
            if (update_multiple_arg_temp(&jsoninclude_list, 
                &(local_args_info.jsoninclude_given), optarg, cmdline_parser_jsoninclude_values, 0, ARG_ENUM,
                "jsoninclude", '-',
                additional_error))
              goto failure;
          
          }
          /* Do not send logging information.  */
          else if (strcmp (long_options[option_index].name, "nolog") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->nolog_flag), 0, &(args_info->nolog_given),
                &(local_args_info.nolog_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "nolog", '-',
                additional_error))
              goto failure;
          
          }
          /* Define output port number.  */
          else if (strcmp (long_options[option_index].name, "outputport") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->outputport_arg), 
                 &(args_info->outputport_orig), &(args_info->outputport_given),
                &(local_args_info.outputport_given), optarg, 0, "5555", ARG_SHORT,
                check_ambiguity, override, 0, 0,
                "outputport", '-',
                additional_error))
              goto failure;
          
          }
          /* Define input port number.  */
          else if (strcmp (long_options[option_index].name, "inputport") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->inputport_arg), 
                 &(args_info->inputport_orig), &(args_info->inputport_given),
                &(local_args_info.inputport_given), optarg, 0, "5556", ARG_SHORT,
                check_ambiguity, override, 0, 0,
                "inputport", '-',
                additional_error))
              goto failure;
          
          }
          /* Define hostname or IP for reports.  */
          else if (strcmp (long_options[option_index].name, "address") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->address_arg), 
                 &(args_info->address_orig), &(args_info->address_given),
                &(local_args_info.address_given), optarg, 0, "localhost", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "address", '-',
                additional_error))
              goto failure;
          
          }
          /* Allow remote termination.  */
          else if (strcmp (long_options[option_index].name, "remoteTermination") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->remoteTermination_arg), 
                 &(args_info->remoteTermination_orig), &(args_info->remoteTermination_given),
                &(local_args_info.remoteTermination_given), optarg, 0, "goodbye", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "remoteTermination", '-',
                additional_error))
              goto failure;
          
          }
          /* Print the net.  */
          else if (strcmp (long_options[option_index].name, "printNet") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->printNet_flag), 0, &(args_info->printNet_given),
                &(local_args_info.printNet_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "printNet", '-',
                additional_error))
              goto failure;
          
          }
          /* Print memory statistics.  */
          else if (strcmp (long_options[option_index].name, "stats") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->stats_flag), 0, &(args_info->stats_given),
                &(local_args_info.stats_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "stats", '-',
                additional_error))
              goto failure;
          
          }
          /* Use TSCC exploration.  */
          else if (strcmp (long_options[option_index].name, "tscc") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->tscc_flag), 0, &(args_info->tscc_given),
                &(local_args_info.tscc_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "tscc", '-',
                additional_error))
              goto failure;
          
          }
          /* Abort LoLA after the given time has passed.  */
          else if (strcmp (long_options[option_index].name, "timelimit") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->timelimit_arg), 
                 &(args_info->timelimit_orig), &(args_info->timelimit_given),
                &(local_args_info.timelimit_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "timelimit", '-',
                additional_error))
              goto failure;
          
          }
          /* Abort a child process of LoLA that executes a subtask,
             after the given time has passed. Use 0 to use a dynamic calculated limit..  */
          else if (strcmp (long_options[option_index].name, "localtimelimit") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->localtimelimit_arg), 
                 &(args_info->localtimelimit_orig), &(args_info->localtimelimit_given),
                &(local_args_info.localtimelimit_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "localtimelimit", '-',
                additional_error))
              goto failure;
          
          }
          /* Abort symmetry computation after the given time has passed.  */
          else if (strcmp (long_options[option_index].name, "symmtimelimit") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->symmtimelimit_arg), 
                 &(args_info->symmtimelimit_orig), &(args_info->symmtimelimit_given),
                &(local_args_info.symmtimelimit_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "symmtimelimit", '-',
                additional_error))
              goto failure;
          
          }
          /* Abort LoLA after the given number of markings have been explored.  */
          else if (strcmp (long_options[option_index].name, "markinglimit") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->markinglimit_arg), 
                 &(args_info->markinglimit_orig), &(args_info->markinglimit_given),
                &(local_args_info.markinglimit_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "markinglimit", '-',
                additional_error))
              goto failure;
          
          }
          /* Manage visited states using the specified data structure.  */
          else if (strcmp (long_options[option_index].name, "store") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->store_arg), 
                 &(args_info->store_orig), &(args_info->store_given),
                &(local_args_info.store_given), optarg, cmdline_parser_store_values, "prefix", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "store", '-',
                additional_error))
              goto failure;
          
          }
          /* Code visited states using the specified coding scheme.  */
          else if (strcmp (long_options[option_index].name, "encoder") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->encoder_arg), 
                 &(args_info->encoder_orig), &(args_info->encoder_given),
                &(local_args_info.encoder_given), optarg, cmdline_parser_encoder_values, "bit", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "encoder", '-',
                additional_error))
              goto failure;
          
          }
          /* Activate bucketing, if the selected store supports it..  */
          else if (strcmp (long_options[option_index].name, "bucketing") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->bucketing_arg), 
                 &(args_info->bucketing_orig), &(args_info->bucketing_given),
                &(local_args_info.bucketing_given), optarg, 0, "16", ARG_INT,
                check_ambiguity, override, 0, 0,
                "bucketing", '-',
                additional_error))
              goto failure;
          
          }
          /* Activate the specified number of hash functions for the Bloom filter.  */
          else if (strcmp (long_options[option_index].name, "hashfunctions") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->hashfunctions_arg), 
                 &(args_info->hashfunctions_orig), &(args_info->hashfunctions_given),
                &(local_args_info.hashfunctions_given), optarg, 0, "2", ARG_SHORT,
                check_ambiguity, override, 0, 0,
                "hashfunctions", '-',
                additional_error))
              goto failure;
          
          }
          /* Select LTL-state storage mode.  */
          else if (strcmp (long_options[option_index].name, "ltlmode") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ltlmode_arg), 
                 &(args_info->ltlmode_orig), &(args_info->ltlmode_given),
                &(local_args_info.ltlmode_given), optarg, cmdline_parser_ltlmode_values, "tree", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "ltlmode", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of fronts that may run simultaneously in the SweepLine method..  */
          else if (strcmp (long_options[option_index].name, "sweepfronts") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->sweepfronts_arg), 
                 &(args_info->sweepfronts_orig), &(args_info->sweepfronts_given),
                &(local_args_info.sweepfronts_given), optarg, 0, "1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "sweepfronts", '-',
                additional_error))
              goto failure;
          
          }
          /* Parameter for the SweepLine search strategy.  */
          else if (strcmp (long_options[option_index].name, "sweeplinedelay") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->sweeplinedelay_arg), 
                 &(args_info->sweeplinedelay_orig), &(args_info->sweeplinedelay_given),
                &(local_args_info.sweeplinedelay_given), optarg, 0, "100", ARG_INT,
                check_ambiguity, override, 0, 0,
                "sweeplinedelay", '-',
                additional_error))
              goto failure;
          
          }
          /* Allow spreading of progress values over a larger range..  */
          else if (strcmp (long_options[option_index].name, "sweeplinespread") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->sweeplinespread_arg), 
                 &(args_info->sweeplinespread_orig), &(args_info->sweeplinespread_given),
                &(local_args_info.sweeplinespread_given), optarg, 0, "1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "sweeplinespread", '-',
                additional_error))
              goto failure;
          
          }
          /* Heuristical parameter for transition invariant based analysis..  */
          else if (strcmp (long_options[option_index].name, "cycleheuristic") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->cycleheuristic_arg), 
                 &(args_info->cycleheuristic_orig), &(args_info->cycleheuristic_given),
                &(local_args_info.cycleheuristic_given), optarg, 0, "-1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "cycleheuristic", '-',
                additional_error))
              goto failure;
          
          }
          /* Set number of retries (0 for infinite retries; relevant only for `--search=findpath').  */
          else if (strcmp (long_options[option_index].name, "retrylimit") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->retrylimit_arg), 
                 &(args_info->retrylimit_orig), &(args_info->retrylimit_given),
                &(local_args_info.retrylimit_given), optarg, 0, "0", ARG_INT,
                check_ambiguity, override, 0, 0,
                "retrylimit", '-',
                additional_error))
              goto failure;
          
          }
          /* Set number of transitions to fire before search is aborted or retried (relevant for `--search=findpath')..  */
          else if (strcmp (long_options[option_index].name, "depthlimit") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->depthlimit_arg), 
                 &(args_info->depthlimit_orig), &(args_info->depthlimit_given),
                &(local_args_info.depthlimit_given), optarg, 0, "1000000", ARG_INT,
                check_ambiguity, override, 0, 0,
                "depthlimit", '-',
                additional_error))
              goto failure;
          
          }
          /* Set number of threads to be used for parallelization.  */
          else if (strcmp (long_options[option_index].name, "threads") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->threads_arg), 
                 &(args_info->threads_orig), &(args_info->threads_given),
                &(local_args_info.threads_given), optarg, 0, "1", ARG_SHORT,
                check_ambiguity, override, 0, 0,
                "threads", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */


  update_multiple_arg((void *)&(args_info->jsoninclude_arg),
    &(args_info->jsoninclude_orig), args_info->jsoninclude_given,
    local_args_info.jsoninclude_given, 0,
    ARG_ENUM, jsoninclude_list);

  args_info->jsoninclude_given += local_args_info.jsoninclude_given;
  local_args_info.jsoninclude_given = 0;
  
  if (check_required)
    {
      error_occurred += cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  cmdline_parser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  if (optind < argc)
    {
      int i = 0 ;
      int found_prog_name = 0;
      /* whether program name, i.e., argv[0], is in the remaining args
         (this may happen with some implementations of getopt,
          but surely not with the one included by gengetopt) */


      args_info->inputs_num = argc - optind - found_prog_name;
      args_info->inputs =
        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;
      while (optind < argc)
        args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind++]) ;
    }

  return 0;

failure:
  free_list (jsoninclude_list, 0 );
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
