/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#define KC_TYPES

#include "ast-system-k.h"
#include <stdio.h>
#include <ctype.h>
#include <string>
#include <sys/types.h>
#include <stdlib.h>

#ifdef _MSC_VER
#pragma warning( disable : 4786 )
#endif
#include <new>
#include <set>
#include <list>
#include <algorithm>

#if !defined(USE_HASHSET) && (defined(__GNUC__) || defined(__ICC) || defined(__ECC)) \
&& !defined(DONT_USE_HASHSET)
#  define USE_HASHSET
#endif
#ifdef USE_HASHSET
#  if defined(__GNUC__) && __GNUC__>2
#    include <ext/hash_set>
#  else
#    include <hash_set>
#  endif
#endif

using namespace std;

namespace kc {

inline bool
ht_less(casestring p1, casestring p2){
    return kc_strcmp(p1->name, p2->name)<0;
}

inline bool
ht_less(nocasestring p1, nocasestring p2){
    return kc_strcasecmp(p1->name, p2->name)<0;
}

inline bool
ht_less(real p1, real p2){
    return p1->value < p2->value;
}

inline bool
ht_less(integer p1, integer p2){
    return p1->value < p2->value;
}

inline bool
ht_less(voidptr p1, voidptr p2){
    return p1->pointer < p2->pointer;
}

bool
ht_less(abstract_phylum p1, abstract_phylum p2)
{
    enum_operators prod_sel=p1->prod_sel();
    enum_operators prod_sel2=p2->prod_sel();
    if(prod_sel<prod_sel2)
	return true;
    if(prod_sel>prod_sel2)
	return false;
    switch(prod_sel) {
	case sel_NoCaseStr:
	    return ht_less(static_cast<nocasestring>(p1),static_cast<nocasestring>(p2));
	case sel__Str:
	    return ht_less(static_cast<casestring>(p1),static_cast<casestring>(p2));
	case sel__Real:
	    return ht_less(static_cast<real>(p1),static_cast<real>(p2));
	case sel__Int:
	    return ht_less(static_cast<integer>(p1),static_cast<integer>(p2));
	case sel__VoidPtr:
	    return ht_less(static_cast<voidptr>(p1),static_cast<voidptr>(p2));
	default: {
	    int i=0;
	    bool still_unique = kc_storageclass_still_uniq[phylum_info[p1->phylum()].uniq_stored];
	    abstract_phylum sub1=0;
	    do {
		sub1=p1->subphylum(i);
		abstract_phylum sub2=p2->subphylum(i);
		if(still_unique) {
		    if(sub1<sub2)
			return true;
		    if(sub2<sub1)
			return false;
		}
		else {
		    if(ht_less(sub1, sub2))
			return true;
		    if(ht_less(sub2, sub1))
			return false;
		}
		++i;
	    } while(sub1);
	}
    }
    return false;
}

template<typename T>
class phylum_less : std::binary_function<T, T, bool>
{
    public:
    bool operator()(const T& X, const T& Y) const
	{ return ht_less(X,Y); }
};

inline void deletefun(c_abstract_phylum t){
    delete const_cast<abstract_phylum>(t);
}


#ifdef USE_HASHSET
struct hashitem {
    size_t hashvalue;
    casestring contents;
    hashitem(casestring cs): contents(cs) {
	unsigned long h = 0;
	kc_char_t const *s = cs->name;
	for ( ; *s; ++s)
	    h = 5*h + *s;
	hashvalue=(size_t)h;
    }
};

inline void deletefunhashitem(hashitem t) {
    delete t.contents;
}

#  ifdef __GNUC__
struct eq_hashitem { bool operator()(hashitem hi1, hashitem hi2) const {
	return kc_strcmp(hi1.contents->name, hi2.contents->name) == 0; } };

struct hash_hashitem { size_t operator()(hashitem hi) const {
	return hi.hashvalue; } };

#  else
struct comp_hashitem {
    enum { bucket_size = 4, min_buckets = 8 };
    // bucket_size and min_buckets are just guesses
    size_t operator()(const hashitem hi) const {
	return hi.hashvalue; }
    bool operator()(const hashitem hi1, const hashitem hi2) const {
	return kc_strcmp(hi1.contents->name, hi2.contents->name) < 0; }
};
#  endif // Whether gcc or icc
#endif // Whether hash or not

struct hashtable_level
{
    hashtable_level(bool cod = true): clean_on_destruction(cod) { }
    void clear(bool free_entries=true) {
	if(free_entries)
	    clear_entries();
	_casestring.clear();
	_nocasestring.clear();
	_integer.clear();
	_real.clear();
	_voidptr.clear();
	_abstract_phylum.clear();
    }
    void clear_entries() {
#ifdef USE_HASHSET
	std::for_each(_casestring.begin(),_casestring.end(),deletefunhashitem);
#else
	std::for_each(_casestring.begin(),_casestring.end(),deletefun);
#endif
	std::for_each(_nocasestring.begin(),_nocasestring.end(),deletefun);
	std::for_each(_integer.begin(),_integer.end(),deletefun);
	std::for_each(_real.begin(),_real.end(),deletefun);
	std::for_each(_voidptr.begin(),_voidptr.end(),deletefun);
	std::for_each(_abstract_phylum.begin(),_abstract_phylum.end(),deletefun);
    }
    ~hashtable_level() {
	clear(clean_on_destruction);
    }
    abstract_phylum check_insert(abstract_phylum t) {
	return *_abstract_phylum.insert(t).first;
    }
    casestring check_insert(casestring t) {
#ifdef USE_HASHSET
	return (*_casestring.insert(hashitem(t)).first).contents;
#else
	return *_casestring.insert(t).first;
#endif
    }
    nocasestring check_insert(nocasestring t) {
	return *_nocasestring.insert(t).first;
    }
    integer check_insert(integer t) {
	return *_integer.insert(t).first;
    }
    real check_insert(real t) {
	return *_real.insert(t).first;
    }
    voidptr check_insert(voidptr t) {
	return *_voidptr.insert(t).first;
    }
private:
    bool clean_on_destruction;
#ifdef USE_HASHSET
#  ifdef __GNUC__
#    if __GNUC__==2 || (__GNUC__==3 && __GNUC_MINOR__==0)
    std::hash_set<hashitem, hash_hashitem, eq_hashitem> _casestring;
#    else
    __gnu_cxx::hash_set<hashitem, hash_hashitem, eq_hashitem> _casestring;
#    endif
#  else
    std::hash_set<hashitem, comp_hashitem> _casestring;
#  endif
#else
    std::set<casestring, phylum_less<casestring> > _casestring;
#endif
    std::set<nocasestring, phylum_less<nocasestring> > _nocasestring;
    std::set<integer, phylum_less<integer> > _integer;
    std::set<real, phylum_less<real> > _real;
    std::set<voidptr, phylum_less<voidptr> > _voidptr;
    std::set<abstract_phylum, phylum_less<abstract_phylum> > _abstract_phylum;
};

class hashtable_stack: public std::list<hashtable_level> {
public:
    hashtable_stack(): _pos(begin()) { }

    void inc_level() { _pos=insert(_pos, hashtable_level()); }
    void dec_level() { if(valid() && _pos!=end()) ++_pos; }
    void free_level() { if(_pos!=begin()) { erase(begin(),_pos);_pos=begin(); } }

    bool valid() const { return !empty(); }
    hashtable_level& get_level() { return *_pos; }

    template<typename T>
    T check_insert(T t) {
	return dynamic_cast<T>((*_pos).check_insert(t));
    }
private:
    iterator _pos;
};

class hashtable_struct_t {
public:
    // don't clean _static_level on destruction (program ends)
    hashtable_struct_t(): _static_level(false), _to_be_freed(false),  _dynamic(false) { }

    template <typename T>
    T ht_check_insert(T t) {
	if(_dynamic && _dynamic_level.valid())
	    return _dynamic_level.check_insert(t);
	else
	    return dynamic_cast<T>(_static_level.check_insert(t));
    }
    void ht_static() {_dynamic=false; }
    void ht_dynamic() {
	_dynamic=true;
	if(!_dynamic_level.valid())
	    _dynamic_level.inc_level();
    }
    void ht_inc_level() { _dynamic_level.inc_level(); }
    void ht_dec_level() { _dynamic_level.dec_level(); }
    void ht_free_level() { _dynamic_level.free_level(); }
    void ht_clear() { _static_level.clear(); _dynamic_level.clear(); _dynamic=false; }

    bool to_be_freed() { return _to_be_freed; }
    void set_to_be_freed(bool b=true) { _to_be_freed=b; }
private:
    hashtable_level _static_level;
    hashtable_stack _dynamic_level;
    bool _to_be_freed; /* should be true for dynamic, false for statically allocated structures */
    bool _dynamic;
};

impl_nocasestring_NoCaseStr::impl_nocasestring_NoCaseStr(const kc_char_t* _name) : name(_name) { }
void impl_nocasestring_NoCaseStr::make_own(int length) {
    kc_char_t *newname=new kc_char_t[length+1];
    for (int i=0; i < length && name[i]; ++i)
    newname[i] = kc_tolower(name[i]);
    newname[length]=0;
    name=newname;
}

impl_casestring__Str::impl_casestring__Str(const kc_char_t* _name) : name(_name) { }
void impl_casestring__Str::make_own(int length) {
    kc_char_t *newname=kc_strncpy(new kc_char_t[length+1],name,length);
    newname[length]=0;
    name=newname;
}
abstract_phylum impl_switchCaseList_SwitchCaseList::subphylum(int no) const
{
    switch(no){
	case 0: return switchCase_1;
	case 1: return switchCaseList_1;
    }
    return 0;
}
abstract_phylum impl_switchCase_SwitchDefault::subphylum(int no) const
{
    switch(no){
	case 0: return statement_1;
    }
    return 0;
}
abstract_phylum impl_switchCase_SwitchCase::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementReturn::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementSwitch::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return switchCaseList_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementForAll::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return type_2;
    }
    return 0;
}
abstract_phylum impl_statement_StatementForIdentColon::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_1;
	case 2: return statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementForTypeExpr::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return expression_1;
	case 3: return expression_2;
	case 4: return expression_3;
	case 5: return statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementForExpr::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
	case 2: return expression_3;
	case 3: return statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementDoWhile::subphylum(int no) const
{
    switch(no){
	case 0: return statement_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementWhile::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementIf::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return statement_1;
	case 2: return statement_2;
    }
    return 0;
}
abstract_phylum impl_statement_StatementExprSemicolon::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementBlock::subphylum(int no) const
{
    switch(no){
	case 0: return block_1;
    }
    return 0;
}
abstract_phylum impl_declaration_Declaration::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return varOrArrayList_1;
    }
    return 0;
}
abstract_phylum impl_declarationOrStatement_DeclOrStatemStatement::subphylum(int no) const
{
    switch(no){
	case 0: return statement_1;
	case 1: return declarationOrStatement_1;
    }
    return 0;
}
abstract_phylum impl_declarationOrStatement_DeclOrStatemDeclaration::subphylum(int no) const
{
    switch(no){
	case 0: return declaration_1;
	case 1: return declarationOrStatement_1;
    }
    return 0;
}
abstract_phylum impl_block_Block::subphylum(int no) const
{
    switch(no){
	case 0: return declarationOrStatement_1;
    }
    return 0;
}
abstract_phylum impl_identExprList_IdentExprList::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_1;
	case 2: return identExprList_1;
    }
    return 0;
}
abstract_phylum impl_guard_Guard::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_varOrArrayList_VarOrArrayList::subphylum(int no) const
{
    switch(no){
	case 0: return varOrArray_1;
	case 1: return varOrArrayList_1;
    }
    return 0;
}
abstract_phylum impl_variable_Variable::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return varOrArrayList_1;
	case 2: return variable_1;
    }
    return 0;
}
abstract_phylum impl_transition_Transition::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return fairness_1;
	case 2: return variable_1;
	case 3: return guard_1;
	case 4: return identExprList_1;
	case 5: return identExprList_2;
	case 6: return transition_1;
    }
    return 0;
}
abstract_phylum impl_marking_Marking::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_1;
	case 2: return marking_1;
    }
    return 0;
}
abstract_phylum impl_placeblock_PlaceBlock::subphylum(int no) const
{
    switch(no){
	case 0: return optSafe_1;
	case 1: return type_1;
	case 2: return placelist_1;
    }
    return 0;
}
abstract_phylum impl_placelist_PlaceList::subphylum(int no) const
{
    switch(no){
	case 0: return place_1;
	case 1: return placelist_1;
    }
    return 0;
}
abstract_phylum impl_place_Place::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_optSafe_Safe::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_placeblocklist_PlaceBlockList::subphylum(int no) const
{
    switch(no){
	case 0: return placeblock_1;
	case 1: return placeblocklist_1;
    }
    return 0;
}
abstract_phylum impl_expressionListColon_ExpressionListColon::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
	case 2: return expressionListColon_1;
    }
    return 0;
}
abstract_phylum impl_initializerList_ExprInBracesColon::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
	case 2: return expressionListColon_1;
    }
    return 0;
}
abstract_phylum impl_initializerList_ExprInBraces::subphylum(int no) const
{
    switch(no){
	case 0: return expressionlist_1;
    }
    return 0;
}
abstract_phylum impl_expressionlist_ExpressionList::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expressionlist_1;
    }
    return 0;
}
abstract_phylum impl_leftvalue_LeftValDot::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_leftvalue_LeftValBrackets::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_leftvalue_LeftValIdent::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprAll::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprOtherIf::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
	case 2: return expression_3;
    }
    return 0;
}
abstract_phylum impl_expression_ExprCommaSeparated::subphylum(int no) const
{
    switch(no){
	case 0: return expressionlist_1;
    }
    return 0;
}
abstract_phylum impl_expression_FunctionCall::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expressionlist_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprGreaterOrEqual::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ExprLessOrEqual::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ExprGreaterThan::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ExprLessThan::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ExprNotEqual::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ExprEquivalent::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ExprOr::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ExprAnd::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_NotExpr::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprNumber::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprModulo::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ExprDivision::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ExprMultiplication::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ExprSubtraction::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ExprAddition::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_NegativeExpr::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expression_PositiveExpr::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expression_ValDecrement::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
    }
    return 0;
}
abstract_phylum impl_expression_ValIncrement::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
    }
    return 0;
}
abstract_phylum impl_expression_DecrementVal::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
    }
    return 0;
}
abstract_phylum impl_expression_IncrementVal::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
    }
    return 0;
}
abstract_phylum impl_expression_AssignMod::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expression_AssignDivide::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expression_AssignTimes::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expression_AssignMinus::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expression_AssignPlus::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expression_AssignEqual::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprInitializerList::subphylum(int no) const
{
    switch(no){
	case 0: return initializerList_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprLeftvalue::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
    }
    return 0;
}
abstract_phylum impl_functionParameters_FunctionParameters::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return varOrArray_1;
    }
    return 0;
}
abstract_phylum impl_functionParametersList_FunctionParametersList::subphylum(int no) const
{
    switch(no){
	case 0: return functionParameters_1;
	case 1: return functionParametersList_1;
    }
    return 0;
}
abstract_phylum impl_arrayList_ArrayList::subphylum(int no) const
{
    switch(no){
	case 0: return arrayList_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_varOrArray_VarOrArray::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return arrayList_1;
    }
    return 0;
}
abstract_phylum impl_structType_StructType::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return arrayList_1;
    }
    return 0;
}
abstract_phylum impl_structTypeList_StructTypeList::subphylum(int no) const
{
    switch(no){
	case 0: return structTypeList_1;
	case 1: return structType_1;
    }
    return 0;
}
abstract_phylum impl_idents_Idents::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return optionalNumber_1;
    }
    return 0;
}
abstract_phylum impl_identList_IdentList::subphylum(int no) const
{
    switch(no){
	case 0: return identList_1;
	case 1: return idents_1;
    }
    return 0;
}
abstract_phylum impl_optionalNumber_OptNumber::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_type_TypeArray::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return integer_1;
    }
    return 0;
}
abstract_phylum impl_type_TypeMultiset::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
    }
    return 0;
}
abstract_phylum impl_type_TypeStruct::subphylum(int no) const
{
    switch(no){
	case 0: return structTypeList_1;
    }
    return 0;
}
abstract_phylum impl_type_TypeIntInterval::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_type_TypeIdent::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_type_TypeEnum::subphylum(int no) const
{
    switch(no){
	case 0: return identList_1;
    }
    return 0;
}
abstract_phylum impl_definitions_Function::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return arrayList_1;
	case 3: return functionParametersList_1;
	case 4: return block_1;
    }
    return 0;
}
abstract_phylum impl_definitions_Sort::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return arrayList_1;
    }
    return 0;
}
abstract_phylum impl_definitions_Constant::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return arrayList_1;
	case 3: return expression_1;
    }
    return 0;
}
abstract_phylum impl_definitionsList_DefinitionsList::subphylum(int no) const
{
    switch(no){
	case 0: return definitionsList_1;
	case 1: return definitions_1;
    }
    return 0;
}
abstract_phylum impl_net_Net::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return definitionsList_1;
	case 2: return placeblocklist_1;
	case 3: return marking_1;
	case 4: return transition_1;
    }
    return 0;
}
abstract_phylum impl_tAcceptingSet_AcceptingSet::subphylum(int no) const
{
    switch(no){
	case 0: return tAcceptingSet_1;
	case 1: return tAcceptingSet_2;
    }
    return 0;
}
abstract_phylum impl_tAcceptingSet_AcceptingState::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_tTransitionRules_TransitionRules::subphylum(int no) const
{
    switch(no){
	case 0: return tTransitionRules_1;
	case 1: return tTransitionRules_2;
    }
    return 0;
}
abstract_phylum impl_tTransitionRules_TransitionRule::subphylum(int no) const
{
    switch(no){
	case 0: return tFormula_1;
	case 1: return integer_1;
    }
    return 0;
}
abstract_phylum impl_tBuechiRules_BuechiRules::subphylum(int no) const
{
    switch(no){
	case 0: return tBuechiRules_1;
	case 1: return tBuechiRules_2;
    }
    return 0;
}
abstract_phylum impl_tBuechiRules_ExpandedBuechiRule::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
	case 1: return tFormula_1;
	case 2: return integer_2;
    }
    return 0;
}
abstract_phylum impl_tBuechiRules_BuechiRule::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
	case 1: return tTransitionRules_1;
    }
    return 0;
}
abstract_phylum impl_tBuechiAutomata_BuechiAutomaton::subphylum(int no) const
{
    switch(no){
	case 0: return tBuechiRules_1;
	case 1: return tAcceptingSet_1;
    }
    return 0;
}
abstract_phylum impl_tProduct_list::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tProduct_list_1;
    }
    return 0;
}
abstract_phylum impl_tTerm_ProductList::subphylum(int no) const
{
    switch(no){
	case 0: return tProduct_list_1;
    }
    return 0;
}
abstract_phylum impl_tTerm_Product::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
	case 1: return tTerm_1;
    }
    return 0;
}
abstract_phylum impl_tTerm_Difference::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tTerm_Sum::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tTerm_Number::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_tTerm_Node::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_Unfireable::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_Fireable::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_LessEqualAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_LessAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_GreaterEqualAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_GreaterAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_NotEqualsAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_EqualsAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tDisjunction_list::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tDisjunction_list_1;
    }
    return 0;
}
abstract_phylum impl_tConjunction_list::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tConjunction_list_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_DisjunctionList::subphylum(int no) const
{
    switch(no){
	case 0: return tDisjunction_list_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_ConjunctionList::subphylum(int no) const
{
    switch(no){
	case 0: return tConjunction_list_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_EX::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AX::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_EG::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AG::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_EF::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AF::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_ER::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AR::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_EU::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AU::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Release::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Until::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_NextState::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Eventually::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Always::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_ExPath::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AllPath::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Equivalence::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Implication::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_ExclusiveDisjunction::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Disjunction::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Conjunction::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Negation::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tAtomicProposition_1;
    }
    return 0;
}
abstract_phylum impl_tFormula_Compound::subphylum(int no) const
{
    switch(no){
	case 0: return tFormula_1;
	case 1: return tFormula_2;
    }
    return 0;
}
abstract_phylum impl_tFormula_ComputeBound::subphylum(int no) const
{
    switch(no){
	case 0: return tAtomicProposition_1;
    }
    return 0;
}
abstract_phylum impl_tFormula_StatePredicateFormula::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
void impl_switchCaseList_SwitchCaseList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = switchCase_1 = dynamic_cast<switchCase>(val);break;
	case 1: newval = switchCaseList_1 = dynamic_cast<switchCaseList>(val);break;
    }
    assertNonNull(newval);
}
void impl_switchCase_SwitchDefault::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = statement_1 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_switchCase_SwitchCase::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = statement_1 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementReturn::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementSwitch::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = switchCaseList_1 = dynamic_cast<switchCaseList>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementForAll::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = type_2 = dynamic_cast<type>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementForIdentColon::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 2: newval = statement_1 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementForTypeExpr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 3: newval = expression_2 = dynamic_cast<expression>(val);break;
	case 4: newval = expression_3 = dynamic_cast<expression>(val);break;
	case 5: newval = statement_1 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementForExpr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
	case 2: newval = expression_3 = dynamic_cast<expression>(val);break;
	case 3: newval = statement_1 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementDoWhile::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = statement_1 = dynamic_cast<statement>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementWhile::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = statement_1 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementIf::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = statement_1 = dynamic_cast<statement>(val);break;
	case 2: newval = statement_2 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementExprSemicolon::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementBlock::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = block_1 = dynamic_cast<block>(val);break;
    }
    assertNonNull(newval);
}
void impl_declaration_Declaration::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = varOrArrayList_1 = dynamic_cast<varOrArrayList>(val);break;
    }
    assertNonNull(newval);
}
void impl_declarationOrStatement_DeclOrStatemStatement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = statement_1 = dynamic_cast<statement>(val);break;
	case 1: newval = declarationOrStatement_1 = dynamic_cast<declarationOrStatement>(val);break;
    }
    assertNonNull(newval);
}
void impl_declarationOrStatement_DeclOrStatemDeclaration::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = declaration_1 = dynamic_cast<declaration>(val);break;
	case 1: newval = declarationOrStatement_1 = dynamic_cast<declarationOrStatement>(val);break;
    }
    assertNonNull(newval);
}
void impl_block_Block::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = declarationOrStatement_1 = dynamic_cast<declarationOrStatement>(val);break;
    }
    assertNonNull(newval);
}
void impl_identExprList_IdentExprList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 2: newval = identExprList_1 = dynamic_cast<identExprList>(val);break;
    }
    assertNonNull(newval);
}
void impl_guard_Guard::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_varOrArrayList_VarOrArrayList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = varOrArray_1 = dynamic_cast<varOrArray>(val);break;
	case 1: newval = varOrArrayList_1 = dynamic_cast<varOrArrayList>(val);break;
    }
    assertNonNull(newval);
}
void impl_variable_Variable::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = varOrArrayList_1 = dynamic_cast<varOrArrayList>(val);break;
	case 2: newval = variable_1 = dynamic_cast<variable>(val);break;
    }
    assertNonNull(newval);
}
void impl_transition_Transition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = fairness_1 = dynamic_cast<fairness>(val);break;
	case 2: newval = variable_1 = dynamic_cast<variable>(val);break;
	case 3: newval = guard_1 = dynamic_cast<guard>(val);break;
	case 4: newval = identExprList_1 = dynamic_cast<identExprList>(val);break;
	case 5: newval = identExprList_2 = dynamic_cast<identExprList>(val);break;
	case 6: newval = transition_1 = dynamic_cast<transition>(val);break;
    }
    assertNonNull(newval);
}
void impl_marking_Marking::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 2: newval = marking_1 = dynamic_cast<marking>(val);break;
    }
    assertNonNull(newval);
}
void impl_placeblock_PlaceBlock::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = optSafe_1 = dynamic_cast<optSafe>(val);break;
	case 1: newval = type_1 = dynamic_cast<type>(val);break;
	case 2: newval = placelist_1 = dynamic_cast<placelist>(val);break;
    }
    assertNonNull(newval);
}
void impl_placelist_PlaceList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = place_1 = dynamic_cast<place>(val);break;
	case 1: newval = placelist_1 = dynamic_cast<placelist>(val);break;
    }
    assertNonNull(newval);
}
void impl_place_Place::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_optSafe_Safe::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_placeblocklist_PlaceBlockList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = placeblock_1 = dynamic_cast<placeblock>(val);break;
	case 1: newval = placeblocklist_1 = dynamic_cast<placeblocklist>(val);break;
    }
    assertNonNull(newval);
}
void impl_expressionListColon_ExpressionListColon::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
	case 2: newval = expressionListColon_1 = dynamic_cast<expressionListColon>(val);break;
    }
    assertNonNull(newval);
}
void impl_initializerList_ExprInBracesColon::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
	case 2: newval = expressionListColon_1 = dynamic_cast<expressionListColon>(val);break;
    }
    assertNonNull(newval);
}
void impl_initializerList_ExprInBraces::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionlist_1 = dynamic_cast<expressionlist>(val);break;
    }
    assertNonNull(newval);
}
void impl_expressionlist_ExpressionList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expressionlist_1 = dynamic_cast<expressionlist>(val);break;
    }
    assertNonNull(newval);
}
void impl_leftvalue_LeftValDot::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_leftvalue_LeftValBrackets::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_leftvalue_LeftValIdent::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprAll::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprOtherIf::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
	case 2: newval = expression_3 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprCommaSeparated::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionlist_1 = dynamic_cast<expressionlist>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_FunctionCall::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expressionlist_1 = dynamic_cast<expressionlist>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprGreaterOrEqual::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprLessOrEqual::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprGreaterThan::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprLessThan::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprNotEqual::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprEquivalent::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprOr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprAnd::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_NotExpr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprNumber::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprModulo::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprDivision::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprMultiplication::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprSubtraction::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprAddition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_NegativeExpr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_PositiveExpr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ValDecrement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ValIncrement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_DecrementVal::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_IncrementVal::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_AssignMod::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_AssignDivide::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_AssignTimes::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_AssignMinus::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_AssignPlus::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_AssignEqual::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprInitializerList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = initializerList_1 = dynamic_cast<initializerList>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprLeftvalue::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
    }
    assertNonNull(newval);
}
void impl_functionParameters_FunctionParameters::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = varOrArray_1 = dynamic_cast<varOrArray>(val);break;
    }
    assertNonNull(newval);
}
void impl_functionParametersList_FunctionParametersList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = functionParameters_1 = dynamic_cast<functionParameters>(val);break;
	case 1: newval = functionParametersList_1 = dynamic_cast<functionParametersList>(val);break;
    }
    assertNonNull(newval);
}
void impl_arrayList_ArrayList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_varOrArray_VarOrArray::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
    }
    assertNonNull(newval);
}
void impl_structType_StructType::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
    }
    assertNonNull(newval);
}
void impl_structTypeList_StructTypeList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = structTypeList_1 = dynamic_cast<structTypeList>(val);break;
	case 1: newval = structType_1 = dynamic_cast<structType>(val);break;
    }
    assertNonNull(newval);
}
void impl_idents_Idents::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = optionalNumber_1 = dynamic_cast<optionalNumber>(val);break;
    }
    assertNonNull(newval);
}
void impl_identList_IdentList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = identList_1 = dynamic_cast<identList>(val);break;
	case 1: newval = idents_1 = dynamic_cast<idents>(val);break;
    }
    assertNonNull(newval);
}
void impl_optionalNumber_OptNumber::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_TypeArray::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_TypeMultiset::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_TypeStruct::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = structTypeList_1 = dynamic_cast<structTypeList>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_TypeIntInterval::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_TypeIdent::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_TypeEnum::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = identList_1 = dynamic_cast<identList>(val);break;
    }
    assertNonNull(newval);
}
void impl_definitions_Function::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
	case 3: newval = functionParametersList_1 = dynamic_cast<functionParametersList>(val);break;
	case 4: newval = block_1 = dynamic_cast<block>(val);break;
    }
    assertNonNull(newval);
}
void impl_definitions_Sort::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
    }
    assertNonNull(newval);
}
void impl_definitions_Constant::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
	case 3: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_definitionsList_DefinitionsList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = definitionsList_1 = dynamic_cast<definitionsList>(val);break;
	case 1: newval = definitions_1 = dynamic_cast<definitions>(val);break;
    }
    assertNonNull(newval);
}
void impl_net_Net::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = definitionsList_1 = dynamic_cast<definitionsList>(val);break;
	case 2: newval = placeblocklist_1 = dynamic_cast<placeblocklist>(val);break;
	case 3: newval = marking_1 = dynamic_cast<marking>(val);break;
	case 4: newval = transition_1 = dynamic_cast<transition>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAcceptingSet_AcceptingSet::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tAcceptingSet_1 = dynamic_cast<tAcceptingSet>(val);break;
	case 1: newval = tAcceptingSet_2 = dynamic_cast<tAcceptingSet>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAcceptingSet_AcceptingState::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTransitionRules_TransitionRules::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTransitionRules_1 = dynamic_cast<tTransitionRules>(val);break;
	case 1: newval = tTransitionRules_2 = dynamic_cast<tTransitionRules>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTransitionRules_TransitionRule::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tFormula_1 = dynamic_cast<tFormula>(val);break;
	case 1: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tBuechiRules_BuechiRules::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tBuechiRules_1 = dynamic_cast<tBuechiRules>(val);break;
	case 1: newval = tBuechiRules_2 = dynamic_cast<tBuechiRules>(val);break;
    }
    assertNonNull(newval);
}
void impl_tBuechiRules_ExpandedBuechiRule::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
	case 1: newval = tFormula_1 = dynamic_cast<tFormula>(val);break;
	case 2: newval = integer_2 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tBuechiRules_BuechiRule::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
	case 1: newval = tTransitionRules_1 = dynamic_cast<tTransitionRules>(val);break;
    }
    assertNonNull(newval);
}
void impl_tBuechiAutomata_BuechiAutomaton::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tBuechiRules_1 = dynamic_cast<tBuechiRules>(val);break;
	case 1: newval = tAcceptingSet_1 = dynamic_cast<tAcceptingSet>(val);break;
    }
    assertNonNull(newval);
}
void impl_tProduct_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tProduct_list_1 = dynamic_cast<tProduct_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_ProductList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tProduct_list_1 = dynamic_cast<tProduct_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_Product::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
	case 1: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_Difference::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_Sum::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_Number::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_Node::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_Unfireable::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_Fireable::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_LessEqualAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_LessAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_GreaterEqualAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_GreaterAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_NotEqualsAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_EqualsAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tDisjunction_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tDisjunction_list_1 = dynamic_cast<tDisjunction_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tConjunction_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tConjunction_list_1 = dynamic_cast<tConjunction_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_DisjunctionList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tDisjunction_list_1 = dynamic_cast<tDisjunction_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_ConjunctionList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tConjunction_list_1 = dynamic_cast<tConjunction_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_EX::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AX::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_EG::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AG::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_EF::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AF::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_ER::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AR::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_EU::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AU::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Release::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Until::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_NextState::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Eventually::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Always::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_ExPath::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AllPath::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Equivalence::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Implication::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_ExclusiveDisjunction::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Disjunction::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Conjunction::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Negation::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tAtomicProposition_1 = dynamic_cast<tAtomicProposition>(val);break;
    }
    assertNonNull(newval);
}
void impl_tFormula_Compound::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tFormula_1 = dynamic_cast<tFormula>(val);break;
	case 1: newval = tFormula_2 = dynamic_cast<tFormula>(val);break;
    }
    assertNonNull(newval);
}
void impl_tFormula_ComputeBound::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tAtomicProposition_1 = dynamic_cast<tAtomicProposition>(val);break;
    }
    assertNonNull(newval);
}
void impl_tFormula_StatePredicateFormula::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}

void
copy_attributes(enum_phyla copyPhy, c_abstract_phylum kc_p1, abstract_phylum kc_p2)
{
    switch(copyPhy) {
    case phylum_tFormula: {
	c_tFormula p1 = dynamic_cast<c_tFormula>(kc_p1);
	tFormula p2 = dynamic_cast<tFormula>(kc_p2);
	p2->type = p1->type;
	p2->formula = p1->formula;
	p2->ctl_formula = p1->ctl_formula;
	p2->ltl_tree = p1->ltl_tree;
	p2->cannotcompute = p1->cannotcompute;
	p2->task = p1->task;
	p2->containsDeadlock = p1->containsDeadlock;
	p2->length = p1->length;
	p2->number_of_or_dnf = p1->number_of_or_dnf;
	p2->number_of_or = p1->number_of_or;
	p2->number_of_and = p1->number_of_and;
	p2->only_fireable = p1->only_fireable;
	break;
    }
    case phylum_tStatePredicate: {
	c_tStatePredicate p1 = dynamic_cast<c_tStatePredicate>(kc_p1);
	tStatePredicate p2 = dynamic_cast<tStatePredicate>(kc_p2);
	p2->containsTemporal = p1->containsTemporal;
	p2->validCTLPathFormula = p1->validCTLPathFormula;
	p2->validCTLStateFormula = p1->validCTLStateFormula;
	p2->validLTLFormula = p1->validLTLFormula;
	p2->cannotcompute = p1->cannotcompute;
	p2->task = p1->task;
	p2->priority = p1->priority;
	p2->type = p1->type;
	p2->containsDeadlock = p1->containsDeadlock;
	p2->length = p1->length;
	p2->number_of_or_dnf = p1->number_of_or_dnf;
	p2->number_of_or = p1->number_of_or;
	p2->number_of_and = p1->number_of_and;
	p2->only_fireable = p1->only_fireable;
	break;
    }
    case phylum_tConjunction_list:
	dynamic_cast<tConjunction_list>(kc_p2)->containsDeadlock = dynamic_cast<c_tConjunction_list>(kc_p1)->containsDeadlock;
	break;
    case phylum_tDisjunction_list:
	dynamic_cast<tDisjunction_list>(kc_p2)->containsDeadlock = dynamic_cast<c_tDisjunction_list>(kc_p1)->containsDeadlock;
	break;
    case phylum_tAtomicProposition: {
	c_tAtomicProposition p1 = dynamic_cast<c_tAtomicProposition>(kc_p1);
	tAtomicProposition p2 = dynamic_cast<tAtomicProposition>(kc_p2);
	p2->only_fireable = p1->only_fireable;
	p2->containsDeadlock = p1->containsDeadlock;
	break;
    }
    case phylum_tBuechiAutomata:
	dynamic_cast<tBuechiAutomata>(kc_p2)->automata = dynamic_cast<c_tBuechiAutomata>(kc_p1)->automata;
	break;
    case phylum_type: {
	c_type p1 = dynamic_cast<c_type>(kc_p1);
	type p2 = dynamic_cast<type>(kc_p2);
	p2->is_finite = p1->is_finite;
	p2->is_scalar = p1->is_scalar;
	p2->size = p1->size;
	break;
    }
    case phylum_optionalNumber: {
	c_optionalNumber p1 = dynamic_cast<c_optionalNumber>(kc_p1);
	optionalNumber p2 = dynamic_cast<optionalNumber>(kc_p2);
	p2->value = p1->value;
	p2->set = p1->set;
	break;
    }
    case phylum_identList: {
	c_identList p1 = dynamic_cast<c_identList>(kc_p1);
	identList p2 = dynamic_cast<identList>(kc_p2);
	p2->maxvalue = p1->maxvalue;
	p2->nrvalues = p1->nrvalues;
	break;
    }
    case phylum_idents: {
	c_idents p1 = dynamic_cast<c_idents>(kc_p1);
	idents p2 = dynamic_cast<idents>(kc_p2);
	p2->value = p1->value;
	p2->set = p1->set;
	break;
    }
    case phylum_structTypeList: {
	c_structTypeList p1 = dynamic_cast<c_structTypeList>(kc_p1);
	structTypeList p2 = dynamic_cast<structTypeList>(kc_p2);
	p2->is_finite = p1->is_finite;
	p2->size = p1->size;
	p2->nrcomponents = p1->nrcomponents;
	break;
    }
    case phylum_structType: {
	c_structType p1 = dynamic_cast<c_structType>(kc_p1);
	structType p2 = dynamic_cast<structType>(kc_p2);
	p2->is_finite = p1->is_finite;
	p2->is_scalar = p1->is_scalar;
	p2->size = p1->size;
	break;
    }
    case phylum_varOrArray: {
	c_varOrArray p1 = dynamic_cast<c_varOrArray>(kc_p1);
	varOrArray p2 = dynamic_cast<varOrArray>(kc_p2);
	p2->inherited_type = p1->inherited_type;
	p2->type = p1->type;
	p2->nrdimensions = p1->nrdimensions;
	p2->nrelements = p1->nrelements;
	break;
    }
    case phylum_arrayList: {
	c_arrayList p1 = dynamic_cast<c_arrayList>(kc_p1);
	arrayList p2 = dynamic_cast<arrayList>(kc_p2);
	p2->inherited_type = p1->inherited_type;
	p2->nrdimensions = p1->nrdimensions;
	p2->nrelements = p1->nrelements;
	p2->type = p1->type;
	break;
    }
    case phylum_expression: {
	c_expression p1 = dynamic_cast<c_expression>(kc_p1);
	expression p2 = dynamic_cast<expression>(kc_p2);
	p2->check = p1->check;
	p2->is_constant = p1->is_constant;
	p2->value = p1->value;
	p2->is_scalar = p1->is_scalar;
	break;
    }
    case phylum_varOrArrayList: {
	c_varOrArrayList p1 = dynamic_cast<c_varOrArrayList>(kc_p1);
	varOrArrayList p2 = dynamic_cast<varOrArrayList>(kc_p2);
	p2->inherited_type = p1->inherited_type;
	p2->type = p1->type;
	break;
    }
    case one_before_first_phylum: // just to avoid a warning about missing case if empty
    default:
	break; // it's alright, no attributes to copy
    }
    enum_operators copyOp=kc_p1->prod_sel();
    for (int i=operator_info[copyOp].no_attrs-1; i>=0; --i)
	attributeOf(kc_p2, i)=attributeOf(const_cast<abstract_phylum>(kc_p1), i);
}

KC_PHYLUM_INFO phylum_info[] = {
    { "", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 }, /* dummy element */
    { "nocasestring", sel_NoCaseStr, sel_NoCaseStr, uniq },
    { "casestring", sel__Str, sel__Str, uniq },
    { "real", sel__Real, sel__Real, uniq },
    { "integer", sel__Int, sel__Int, uniq },
    { "voidptr", sel__VoidPtr, sel__VoidPtr, uniq },
    { "tFormula", sel_StatePredicateFormula, sel_Compound, kc_not_uniq },
    { "tStatePredicate", sel_AtomicProposition, sel_DisjunctionList, kc_not_uniq },
    { "tConjunction_list", sel_NiltConjunction_list, sel_ConstConjunction_list, kc_not_uniq },
    { "tDisjunction_list", sel_NiltDisjunction_list, sel_ConstDisjunction_list, kc_not_uniq },
    { "tAtomicProposition", sel_EqualsAtomicProposition, sel_Unfireable, kc_not_uniq },
    { "tTerm", sel_Node, sel_ProductList, kc_not_uniq },
    { "tProduct_list", sel_NiltProduct_list, sel_ConstProduct_list, kc_not_uniq },
    { "tBuechiAutomata", sel_BuechiAutomaton, sel_BuechiNull, kc_not_uniq },
    { "tBuechiRules", sel_EmptyBuechiRules, sel_BuechiRules, kc_not_uniq },
    { "tTransitionRules", sel_EmptyTransitionRules, sel_TransitionRules, kc_not_uniq },
    { "tAcceptingSet", sel_EmptyAcceptingSet, sel_AcceptingSet, kc_not_uniq },
    { "net", sel_Net, sel_Net, kc_not_uniq },
    { "definitionsList", sel_EmptyDefinitionsList, sel_DefinitionsList, kc_not_uniq },
    { "definitions", sel_Constant, sel_Function, kc_not_uniq },
    { "type", sel_TypeBool, sel_TypeBlack, kc_not_uniq },
    { "optionalNumber", sel_EmptyOptNumber, sel_OptNumber, kc_not_uniq },
    { "identList", sel_EmptyIdentList, sel_IdentList, kc_not_uniq },
    { "idents", sel_Idents, sel_Idents, kc_not_uniq },
    { "structTypeList", sel_EmptyStructTypeList, sel_StructTypeList, kc_not_uniq },
    { "structType", sel_StructType, sel_StructType, kc_not_uniq },
    { "varOrArray", sel_VarOrArray, sel_VarOrArray, kc_not_uniq },
    { "arrayList", sel_EmptyArrayList, sel_ArrayList, kc_not_uniq },
    { "functionParametersList", sel_EmptyFunctionParametersList, sel_FunctionParametersList, kc_not_uniq },
    { "functionParameters", sel_FunctionParameters, sel_FunctionParameters, kc_not_uniq },
    { "expression", sel_ExprLeftvalue, sel_ExprAll, kc_not_uniq },
    { "leftvalue", sel_LeftValIdent, sel_LeftValDot, kc_not_uniq },
    { "expressionlist", sel_EmptyExpressionList, sel_ExpressionList, kc_not_uniq },
    { "initializerList", sel_ExprInBraces, sel_ExprInBracesColon, kc_not_uniq },
    { "expressionListColon", sel_EmptyExpressionListColon, sel_ExpressionListColon, kc_not_uniq },
    { "placeblocklist", sel_EmptyPlaceBlockList, sel_PlaceBlockList, kc_not_uniq },
    { "optSafe", sel_EmptySafe, sel_Safe, kc_not_uniq },
    { "place", sel_Place, sel_Place, kc_not_uniq },
    { "placelist", sel_EmptyPlaceList, sel_PlaceList, kc_not_uniq },
    { "placeblock", sel_PlaceBlock, sel_PlaceBlock, kc_not_uniq },
    { "marking", sel_EmptyMarking, sel_Marking, kc_not_uniq },
    { "transition", sel_EmptyTransition, sel_Transition, kc_not_uniq },
    { "fairness", sel_EmptyFairness, sel_StrongFair, kc_not_uniq },
    { "variable", sel_EmptyVariable, sel_Variable, kc_not_uniq },
    { "varOrArrayList", sel_EmptyVarOrArrayList, sel_VarOrArrayList, kc_not_uniq },
    { "guard", sel_Guard, sel_Guard, kc_not_uniq },
    { "identExprList", sel_EmptyIdentExprList, sel_IdentExprList, kc_not_uniq },
    { "block", sel_Block, sel_Block, kc_not_uniq },
    { "declarationOrStatement", sel_EmptyDeclarationOrStatement, sel_DeclOrStatemStatement, kc_not_uniq },
    { "declaration", sel_Declaration, sel_Declaration, kc_not_uniq },
    { "statement", sel_StatementBlock, sel_StatementSkip, kc_not_uniq },
    { "switchCase", sel_SwitchCase, sel_SwitchDefault, kc_not_uniq },
    { "switchCaseList", sel_EmptySwitchCaseList, sel_SwitchCaseList, kc_not_uniq },
    { "", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 } /* last element */
};

static enum_phyla kc_subphyla_StatePredicateFormula[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_ComputeBound[] = { phylum_tAtomicProposition };
static enum_phyla kc_subphyla_Compound[] = { phylum_tFormula, phylum_tFormula };
static enum_phyla kc_subphyla_AtomicProposition[] = { phylum_tAtomicProposition };
static enum_phyla kc_subphyla_Negation[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_Conjunction[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_Disjunction[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_ExclusiveDisjunction[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_Implication[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_Equivalence[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_AllPath[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_ExPath[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_Always[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_Eventually[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_NextState[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_Until[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_Release[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_AU[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_EU[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_AR[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_ER[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_AF[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_EF[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_AG[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_EG[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_AX[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_EX[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_ConjunctionList[] = { phylum_tConjunction_list };
static enum_phyla kc_subphyla_DisjunctionList[] = { phylum_tDisjunction_list };
static enum_phyla kc_subphyla_ConstConjunction_list[] = { phylum_tStatePredicate, phylum_tConjunction_list };
static enum_phyla kc_subphyla_ConstDisjunction_list[] = { phylum_tStatePredicate, phylum_tDisjunction_list };
static enum_phyla kc_subphyla_EqualsAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_NotEqualsAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_GreaterAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_GreaterEqualAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_LessAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_LessEqualAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_Fireable[] = { phylum_integer };
static enum_phyla kc_subphyla_Unfireable[] = { phylum_integer };
static enum_phyla kc_subphyla_Node[] = { phylum_integer };
static enum_phyla kc_subphyla_Number[] = { phylum_integer };
static enum_phyla kc_subphyla_Sum[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_Difference[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_Product[] = { phylum_integer, phylum_tTerm };
static enum_phyla kc_subphyla_ProductList[] = { phylum_tProduct_list };
static enum_phyla kc_subphyla_ConstProduct_list[] = { phylum_tTerm, phylum_tProduct_list };
static enum_phyla kc_subphyla_BuechiAutomaton[] = { phylum_tBuechiRules, phylum_tAcceptingSet };
static enum_phyla kc_subphyla_BuechiRule[] = { phylum_integer, phylum_tTransitionRules };
static enum_phyla kc_subphyla_ExpandedBuechiRule[] = { phylum_integer, phylum_tFormula, phylum_integer };
static enum_phyla kc_subphyla_BuechiRules[] = { phylum_tBuechiRules, phylum_tBuechiRules };
static enum_phyla kc_subphyla_TransitionRule[] = { phylum_tFormula, phylum_integer };
static enum_phyla kc_subphyla_TransitionRules[] = { phylum_tTransitionRules, phylum_tTransitionRules };
static enum_phyla kc_subphyla_AcceptingState[] = { phylum_integer };
static enum_phyla kc_subphyla_AcceptingSet[] = { phylum_tAcceptingSet, phylum_tAcceptingSet };
static enum_phyla kc_subphyla_Net[] = { phylum_casestring, phylum_definitionsList, phylum_placeblocklist, phylum_marking, phylum_transition };
static enum_phyla kc_subphyla_DefinitionsList[] = { phylum_definitionsList, phylum_definitions };
static enum_phyla kc_subphyla_Constant[] = { phylum_type, phylum_casestring, phylum_arrayList, phylum_expression };
static enum_phyla kc_subphyla_Sort[] = { phylum_type, phylum_casestring, phylum_arrayList };
static enum_phyla kc_subphyla_Function[] = { phylum_type, phylum_casestring, phylum_arrayList, phylum_functionParametersList, phylum_block };
static enum_phyla kc_subphyla_TypeEnum[] = { phylum_identList };
static enum_phyla kc_subphyla_TypeIdent[] = { phylum_casestring };
static enum_phyla kc_subphyla_TypeIntInterval[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_TypeStruct[] = { phylum_structTypeList };
static enum_phyla kc_subphyla_TypeMultiset[] = { phylum_type };
static enum_phyla kc_subphyla_TypeArray[] = { phylum_type, phylum_integer };
static enum_phyla kc_subphyla_OptNumber[] = { phylum_integer };
static enum_phyla kc_subphyla_IdentList[] = { phylum_identList, phylum_idents };
static enum_phyla kc_subphyla_Idents[] = { phylum_casestring, phylum_optionalNumber };
static enum_phyla kc_subphyla_StructTypeList[] = { phylum_structTypeList, phylum_structType };
static enum_phyla kc_subphyla_StructType[] = { phylum_type, phylum_casestring, phylum_arrayList };
static enum_phyla kc_subphyla_VarOrArray[] = { phylum_casestring, phylum_arrayList };
static enum_phyla kc_subphyla_ArrayList[] = { phylum_arrayList, phylum_expression };
static enum_phyla kc_subphyla_FunctionParametersList[] = { phylum_functionParameters, phylum_functionParametersList };
static enum_phyla kc_subphyla_FunctionParameters[] = { phylum_type, phylum_varOrArray };
static enum_phyla kc_subphyla_ExprLeftvalue[] = { phylum_leftvalue };
static enum_phyla kc_subphyla_ExprInitializerList[] = { phylum_initializerList };
static enum_phyla kc_subphyla_AssignEqual[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_AssignPlus[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_AssignMinus[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_AssignTimes[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_AssignDivide[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_AssignMod[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_IncrementVal[] = { phylum_leftvalue };
static enum_phyla kc_subphyla_DecrementVal[] = { phylum_leftvalue };
static enum_phyla kc_subphyla_ValIncrement[] = { phylum_leftvalue };
static enum_phyla kc_subphyla_ValDecrement[] = { phylum_leftvalue };
static enum_phyla kc_subphyla_PositiveExpr[] = { phylum_expression };
static enum_phyla kc_subphyla_NegativeExpr[] = { phylum_expression };
static enum_phyla kc_subphyla_ExprAddition[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprSubtraction[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprMultiplication[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprDivision[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprModulo[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprNumber[] = { phylum_integer };
static enum_phyla kc_subphyla_NotExpr[] = { phylum_expression };
static enum_phyla kc_subphyla_ExprAnd[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprOr[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprEquivalent[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprNotEqual[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprLessThan[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprGreaterThan[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprLessOrEqual[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprGreaterOrEqual[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_FunctionCall[] = { phylum_casestring, phylum_expressionlist };
static enum_phyla kc_subphyla_ExprCommaSeparated[] = { phylum_expressionlist };
static enum_phyla kc_subphyla_ExprOtherIf[] = { phylum_expression, phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprAll[] = { phylum_type };
static enum_phyla kc_subphyla_LeftValIdent[] = { phylum_casestring };
static enum_phyla kc_subphyla_LeftValBrackets[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_LeftValDot[] = { phylum_leftvalue, phylum_casestring };
static enum_phyla kc_subphyla_ExpressionList[] = { phylum_expression, phylum_expressionlist };
static enum_phyla kc_subphyla_ExprInBraces[] = { phylum_expressionlist };
static enum_phyla kc_subphyla_ExprInBracesColon[] = { phylum_expression, phylum_expression, phylum_expressionListColon };
static enum_phyla kc_subphyla_ExpressionListColon[] = { phylum_expression, phylum_expression, phylum_expressionListColon };
static enum_phyla kc_subphyla_PlaceBlockList[] = { phylum_placeblock, phylum_placeblocklist };
static enum_phyla kc_subphyla_Safe[] = { phylum_integer };
static enum_phyla kc_subphyla_Place[] = { phylum_casestring };
static enum_phyla kc_subphyla_PlaceList[] = { phylum_place, phylum_placelist };
static enum_phyla kc_subphyla_PlaceBlock[] = { phylum_optSafe, phylum_type, phylum_placelist };
static enum_phyla kc_subphyla_Marking[] = { phylum_casestring, phylum_expression, phylum_marking };
static enum_phyla kc_subphyla_Transition[] = { phylum_casestring, phylum_fairness, phylum_variable, phylum_guard, phylum_identExprList, phylum_identExprList, phylum_transition };
static enum_phyla kc_subphyla_Variable[] = { phylum_type, phylum_varOrArrayList, phylum_variable };
static enum_phyla kc_subphyla_VarOrArrayList[] = { phylum_varOrArray, phylum_varOrArrayList };
static enum_phyla kc_subphyla_Guard[] = { phylum_expression };
static enum_phyla kc_subphyla_IdentExprList[] = { phylum_casestring, phylum_expression, phylum_identExprList };
static enum_phyla kc_subphyla_Block[] = { phylum_declarationOrStatement };
static enum_phyla kc_subphyla_DeclOrStatemDeclaration[] = { phylum_declaration, phylum_declarationOrStatement };
static enum_phyla kc_subphyla_DeclOrStatemStatement[] = { phylum_statement, phylum_declarationOrStatement };
static enum_phyla kc_subphyla_Declaration[] = { phylum_type, phylum_varOrArrayList };
static enum_phyla kc_subphyla_StatementBlock[] = { phylum_block };
static enum_phyla kc_subphyla_StatementExprSemicolon[] = { phylum_expression };
static enum_phyla kc_subphyla_StatementIf[] = { phylum_expression, phylum_statement, phylum_statement };
static enum_phyla kc_subphyla_StatementWhile[] = { phylum_expression, phylum_statement };
static enum_phyla kc_subphyla_StatementDoWhile[] = { phylum_statement, phylum_expression };
static enum_phyla kc_subphyla_StatementForExpr[] = { phylum_expression, phylum_expression, phylum_expression, phylum_statement };
static enum_phyla kc_subphyla_StatementForTypeExpr[] = { phylum_type, phylum_casestring, phylum_expression, phylum_expression, phylum_expression, phylum_statement };
static enum_phyla kc_subphyla_StatementForIdentColon[] = { phylum_casestring, phylum_expression, phylum_statement };
static enum_phyla kc_subphyla_StatementForAll[] = { phylum_type, phylum_casestring, phylum_type };
static enum_phyla kc_subphyla_StatementSwitch[] = { phylum_expression, phylum_switchCaseList };
static enum_phyla kc_subphyla_StatementReturn[] = { phylum_expression };
static enum_phyla kc_subphyla_SwitchCase[] = { phylum_expression, phylum_statement };
static enum_phyla kc_subphyla_SwitchDefault[] = { phylum_statement };
static enum_phyla kc_subphyla_SwitchCaseList[] = { phylum_switchCase, phylum_switchCaseList };


KC_OPERATOR_INFO operator_info[] = {
    { "", 0, 0, one_before_first_phylum, 0, 0, 0, 0 }, /* dummy element */
    { "NoCaseStr", 0, true, phylum_nocasestring, 0, 0, 0, sizeof(impl_nocasestring_NoCaseStr) },
    { "_Str", 0, true, phylum_casestring, 0, 0, 0, sizeof(impl_casestring__Str) },
    { "_Real", 0, true, phylum_real, 0, 0, 0, sizeof(impl_real__Real) },
    { "_Int", 0, true, phylum_integer, 0, 0, 0, sizeof(impl_integer__Int) },
    { "_VoidPtr", 0, true, phylum_voidptr, 0, 0, 0, sizeof(impl_voidptr__VoidPtr) },
    { "StatePredicateFormula", 1, false, phylum_tFormula, kc_subphyla_StatePredicateFormula, 0, 0, sizeof(impl_tFormula_StatePredicateFormula) },
    { "ComputeBound", 1, false, phylum_tFormula, kc_subphyla_ComputeBound, 0, 0, sizeof(impl_tFormula_ComputeBound) },
    { "Compound", 2, false, phylum_tFormula, kc_subphyla_Compound, 0, 0, sizeof(impl_tFormula_Compound) },
    { "AtomicProposition", 1, false, phylum_tStatePredicate, kc_subphyla_AtomicProposition, 0, 0, sizeof(impl_tStatePredicate_AtomicProposition) },
    { "Negation", 1, false, phylum_tStatePredicate, kc_subphyla_Negation, 0, 0, sizeof(impl_tStatePredicate_Negation) },
    { "Conjunction", 2, false, phylum_tStatePredicate, kc_subphyla_Conjunction, 0, 0, sizeof(impl_tStatePredicate_Conjunction) },
    { "Disjunction", 2, false, phylum_tStatePredicate, kc_subphyla_Disjunction, 0, 0, sizeof(impl_tStatePredicate_Disjunction) },
    { "ExclusiveDisjunction", 2, false, phylum_tStatePredicate, kc_subphyla_ExclusiveDisjunction, 0, 0, sizeof(impl_tStatePredicate_ExclusiveDisjunction) },
    { "Implication", 2, false, phylum_tStatePredicate, kc_subphyla_Implication, 0, 0, sizeof(impl_tStatePredicate_Implication) },
    { "Equivalence", 2, false, phylum_tStatePredicate, kc_subphyla_Equivalence, 0, 0, sizeof(impl_tStatePredicate_Equivalence) },
    { "AllPath", 1, false, phylum_tStatePredicate, kc_subphyla_AllPath, 0, 0, sizeof(impl_tStatePredicate_AllPath) },
    { "ExPath", 1, false, phylum_tStatePredicate, kc_subphyla_ExPath, 0, 0, sizeof(impl_tStatePredicate_ExPath) },
    { "Always", 1, false, phylum_tStatePredicate, kc_subphyla_Always, 0, 0, sizeof(impl_tStatePredicate_Always) },
    { "Eventually", 1, false, phylum_tStatePredicate, kc_subphyla_Eventually, 0, 0, sizeof(impl_tStatePredicate_Eventually) },
    { "NextState", 1, false, phylum_tStatePredicate, kc_subphyla_NextState, 0, 0, sizeof(impl_tStatePredicate_NextState) },
    { "Until", 2, false, phylum_tStatePredicate, kc_subphyla_Until, 0, 0, sizeof(impl_tStatePredicate_Until) },
    { "Release", 2, false, phylum_tStatePredicate, kc_subphyla_Release, 0, 0, sizeof(impl_tStatePredicate_Release) },
    { "AU", 2, false, phylum_tStatePredicate, kc_subphyla_AU, 0, 0, sizeof(impl_tStatePredicate_AU) },
    { "EU", 2, false, phylum_tStatePredicate, kc_subphyla_EU, 0, 0, sizeof(impl_tStatePredicate_EU) },
    { "AR", 2, false, phylum_tStatePredicate, kc_subphyla_AR, 0, 0, sizeof(impl_tStatePredicate_AR) },
    { "ER", 2, false, phylum_tStatePredicate, kc_subphyla_ER, 0, 0, sizeof(impl_tStatePredicate_ER) },
    { "AF", 1, false, phylum_tStatePredicate, kc_subphyla_AF, 0, 0, sizeof(impl_tStatePredicate_AF) },
    { "EF", 1, false, phylum_tStatePredicate, kc_subphyla_EF, 0, 0, sizeof(impl_tStatePredicate_EF) },
    { "AG", 1, false, phylum_tStatePredicate, kc_subphyla_AG, 0, 0, sizeof(impl_tStatePredicate_AG) },
    { "EG", 1, false, phylum_tStatePredicate, kc_subphyla_EG, 0, 0, sizeof(impl_tStatePredicate_EG) },
    { "AX", 1, false, phylum_tStatePredicate, kc_subphyla_AX, 0, 0, sizeof(impl_tStatePredicate_AX) },
    { "EX", 1, false, phylum_tStatePredicate, kc_subphyla_EX, 0, 0, sizeof(impl_tStatePredicate_EX) },
    { "ConjunctionList", 1, false, phylum_tStatePredicate, kc_subphyla_ConjunctionList, 0, 0, sizeof(impl_tStatePredicate_ConjunctionList) },
    { "DisjunctionList", 1, false, phylum_tStatePredicate, kc_subphyla_DisjunctionList, 0, 0, sizeof(impl_tStatePredicate_DisjunctionList) },
    { "NiltConjunction_list", 0, false, phylum_tConjunction_list, 0, 0, 0, sizeof(impl_tConjunction_list) },
    { "ConstConjunction_list", 2, false, phylum_tConjunction_list, kc_subphyla_ConstConjunction_list, 0, 0, sizeof(impl_tConjunction_list) },
    { "NiltDisjunction_list", 0, false, phylum_tDisjunction_list, 0, 0, 0, sizeof(impl_tDisjunction_list) },
    { "ConstDisjunction_list", 2, false, phylum_tDisjunction_list, kc_subphyla_ConstDisjunction_list, 0, 0, sizeof(impl_tDisjunction_list) },
    { "EqualsAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_EqualsAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_EqualsAtomicProposition) },
    { "NotEqualsAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_NotEqualsAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_NotEqualsAtomicProposition) },
    { "GreaterAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_GreaterAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_GreaterAtomicProposition) },
    { "GreaterEqualAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_GreaterEqualAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_GreaterEqualAtomicProposition) },
    { "LessAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_LessAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_LessAtomicProposition) },
    { "LessEqualAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_LessEqualAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_LessEqualAtomicProposition) },
    { "True", 0, false, phylum_tAtomicProposition, 0, 0, 0, sizeof(impl_tAtomicProposition_True) },
    { "False", 0, false, phylum_tAtomicProposition, 0, 0, 0, sizeof(impl_tAtomicProposition_False) },
    { "NoDeadlock", 0, false, phylum_tAtomicProposition, 0, 0, 0, sizeof(impl_tAtomicProposition_NoDeadlock) },
    { "Deadlock", 0, false, phylum_tAtomicProposition, 0, 0, 0, sizeof(impl_tAtomicProposition_Deadlock) },
    { "Initial", 0, false, phylum_tAtomicProposition, 0, 0, 0, sizeof(impl_tAtomicProposition_Initial) },
    { "Fireable", 1, false, phylum_tAtomicProposition, kc_subphyla_Fireable, 0, 0, sizeof(impl_tAtomicProposition_Fireable) },
    { "Unfireable", 1, false, phylum_tAtomicProposition, kc_subphyla_Unfireable, 0, 0, sizeof(impl_tAtomicProposition_Unfireable) },
    { "Node", 1, false, phylum_tTerm, kc_subphyla_Node, 0, 0, sizeof(impl_tTerm_Node) },
    { "Number", 1, false, phylum_tTerm, kc_subphyla_Number, 0, 0, sizeof(impl_tTerm_Number) },
    { "Sum", 2, false, phylum_tTerm, kc_subphyla_Sum, 0, 0, sizeof(impl_tTerm_Sum) },
    { "Difference", 2, false, phylum_tTerm, kc_subphyla_Difference, 0, 0, sizeof(impl_tTerm_Difference) },
    { "Product", 2, false, phylum_tTerm, kc_subphyla_Product, 0, 0, sizeof(impl_tTerm_Product) },
    { "ProductList", 1, false, phylum_tTerm, kc_subphyla_ProductList, 0, 0, sizeof(impl_tTerm_ProductList) },
    { "NiltProduct_list", 0, false, phylum_tProduct_list, 0, 0, 0, sizeof(impl_tProduct_list) },
    { "ConstProduct_list", 2, false, phylum_tProduct_list, kc_subphyla_ConstProduct_list, 0, 0, sizeof(impl_tProduct_list) },
    { "BuechiAutomaton", 2, false, phylum_tBuechiAutomata, kc_subphyla_BuechiAutomaton, 0, 0, sizeof(impl_tBuechiAutomata_BuechiAutomaton) },
    { "BuechiNull", 0, false, phylum_tBuechiAutomata, 0, 0, 0, sizeof(impl_tBuechiAutomata_BuechiNull) },
    { "EmptyBuechiRules", 0, false, phylum_tBuechiRules, 0, 0, 0, sizeof(impl_tBuechiRules_EmptyBuechiRules) },
    { "BuechiRule", 2, false, phylum_tBuechiRules, kc_subphyla_BuechiRule, 0, 0, sizeof(impl_tBuechiRules_BuechiRule) },
    { "ExpandedBuechiRule", 3, false, phylum_tBuechiRules, kc_subphyla_ExpandedBuechiRule, 0, 0, sizeof(impl_tBuechiRules_ExpandedBuechiRule) },
    { "BuechiRules", 2, false, phylum_tBuechiRules, kc_subphyla_BuechiRules, 0, 0, sizeof(impl_tBuechiRules_BuechiRules) },
    { "EmptyTransitionRules", 0, false, phylum_tTransitionRules, 0, 0, 0, sizeof(impl_tTransitionRules_EmptyTransitionRules) },
    { "TransitionRule", 2, false, phylum_tTransitionRules, kc_subphyla_TransitionRule, 0, 0, sizeof(impl_tTransitionRules_TransitionRule) },
    { "TransitionRules", 2, false, phylum_tTransitionRules, kc_subphyla_TransitionRules, 0, 0, sizeof(impl_tTransitionRules_TransitionRules) },
    { "EmptyAcceptingSet", 0, false, phylum_tAcceptingSet, 0, 0, 0, sizeof(impl_tAcceptingSet_EmptyAcceptingSet) },
    { "AcceptingState", 1, false, phylum_tAcceptingSet, kc_subphyla_AcceptingState, 0, 0, sizeof(impl_tAcceptingSet_AcceptingState) },
    { "AcceptingSet", 2, false, phylum_tAcceptingSet, kc_subphyla_AcceptingSet, 0, 0, sizeof(impl_tAcceptingSet_AcceptingSet) },
    { "Net", 5, false, phylum_net, kc_subphyla_Net, 0, 0, sizeof(impl_net_Net) },
    { "EmptyDefinitionsList", 0, false, phylum_definitionsList, 0, 0, 0, sizeof(impl_definitionsList_EmptyDefinitionsList) },
    { "DefinitionsList", 2, false, phylum_definitionsList, kc_subphyla_DefinitionsList, 0, 0, sizeof(impl_definitionsList_DefinitionsList) },
    { "Constant", 4, false, phylum_definitions, kc_subphyla_Constant, 0, 0, sizeof(impl_definitions_Constant) },
    { "Sort", 3, false, phylum_definitions, kc_subphyla_Sort, 0, 0, sizeof(impl_definitions_Sort) },
    { "Function", 5, false, phylum_definitions, kc_subphyla_Function, 0, 0, sizeof(impl_definitions_Function) },
    { "TypeBool", 0, false, phylum_type, 0, 0, 0, sizeof(impl_type_TypeBool) },
    { "TypeEnum", 1, false, phylum_type, kc_subphyla_TypeEnum, 0, 0, sizeof(impl_type_TypeEnum) },
    { "TypeIdent", 1, false, phylum_type, kc_subphyla_TypeIdent, 0, 0, sizeof(impl_type_TypeIdent) },
    { "TypeIntInterval", 2, false, phylum_type, kc_subphyla_TypeIntInterval, 0, 0, sizeof(impl_type_TypeIntInterval) },
    { "TypeStruct", 1, false, phylum_type, kc_subphyla_TypeStruct, 0, 0, sizeof(impl_type_TypeStruct) },
    { "TypeInt", 0, false, phylum_type, 0, 0, 0, sizeof(impl_type_TypeInt) },
    { "TypeMultiset", 1, false, phylum_type, kc_subphyla_TypeMultiset, 0, 0, sizeof(impl_type_TypeMultiset) },
    { "TypeArray", 2, false, phylum_type, kc_subphyla_TypeArray, 0, 0, sizeof(impl_type_TypeArray) },
    { "TypeBlack", 0, false, phylum_type, 0, 0, 0, sizeof(impl_type_TypeBlack) },
    { "EmptyOptNumber", 0, false, phylum_optionalNumber, 0, 0, 0, sizeof(impl_optionalNumber_EmptyOptNumber) },
    { "OptNumber", 1, false, phylum_optionalNumber, kc_subphyla_OptNumber, 0, 0, sizeof(impl_optionalNumber_OptNumber) },
    { "EmptyIdentList", 0, false, phylum_identList, 0, 0, 0, sizeof(impl_identList_EmptyIdentList) },
    { "IdentList", 2, false, phylum_identList, kc_subphyla_IdentList, 0, 0, sizeof(impl_identList_IdentList) },
    { "Idents", 2, false, phylum_idents, kc_subphyla_Idents, 0, 0, sizeof(impl_idents_Idents) },
    { "EmptyStructTypeList", 0, false, phylum_structTypeList, 0, 0, 0, sizeof(impl_structTypeList_EmptyStructTypeList) },
    { "StructTypeList", 2, false, phylum_structTypeList, kc_subphyla_StructTypeList, 0, 0, sizeof(impl_structTypeList_StructTypeList) },
    { "StructType", 3, false, phylum_structType, kc_subphyla_StructType, 0, 0, sizeof(impl_structType_StructType) },
    { "VarOrArray", 2, false, phylum_varOrArray, kc_subphyla_VarOrArray, 0, 0, sizeof(impl_varOrArray_VarOrArray) },
    { "EmptyArrayList", 0, false, phylum_arrayList, 0, 0, 0, sizeof(impl_arrayList_EmptyArrayList) },
    { "ArrayList", 2, false, phylum_arrayList, kc_subphyla_ArrayList, 0, 0, sizeof(impl_arrayList_ArrayList) },
    { "EmptyFunctionParametersList", 0, false, phylum_functionParametersList, 0, 0, 0, sizeof(impl_functionParametersList_EmptyFunctionParametersList) },
    { "FunctionParametersList", 2, false, phylum_functionParametersList, kc_subphyla_FunctionParametersList, 0, 0, sizeof(impl_functionParametersList_FunctionParametersList) },
    { "FunctionParameters", 2, false, phylum_functionParameters, kc_subphyla_FunctionParameters, 0, 0, sizeof(impl_functionParameters_FunctionParameters) },
    { "ExprLeftvalue", 1, false, phylum_expression, kc_subphyla_ExprLeftvalue, 0, 0, sizeof(impl_expression_ExprLeftvalue) },
    { "ExprInitializerList", 1, false, phylum_expression, kc_subphyla_ExprInitializerList, 0, 0, sizeof(impl_expression_ExprInitializerList) },
    { "AssignEqual", 2, false, phylum_expression, kc_subphyla_AssignEqual, 0, 0, sizeof(impl_expression_AssignEqual) },
    { "AssignPlus", 2, false, phylum_expression, kc_subphyla_AssignPlus, 0, 0, sizeof(impl_expression_AssignPlus) },
    { "AssignMinus", 2, false, phylum_expression, kc_subphyla_AssignMinus, 0, 0, sizeof(impl_expression_AssignMinus) },
    { "AssignTimes", 2, false, phylum_expression, kc_subphyla_AssignTimes, 0, 0, sizeof(impl_expression_AssignTimes) },
    { "AssignDivide", 2, false, phylum_expression, kc_subphyla_AssignDivide, 0, 0, sizeof(impl_expression_AssignDivide) },
    { "AssignMod", 2, false, phylum_expression, kc_subphyla_AssignMod, 0, 0, sizeof(impl_expression_AssignMod) },
    { "IncrementVal", 1, false, phylum_expression, kc_subphyla_IncrementVal, 0, 0, sizeof(impl_expression_IncrementVal) },
    { "DecrementVal", 1, false, phylum_expression, kc_subphyla_DecrementVal, 0, 0, sizeof(impl_expression_DecrementVal) },
    { "ValIncrement", 1, false, phylum_expression, kc_subphyla_ValIncrement, 0, 0, sizeof(impl_expression_ValIncrement) },
    { "ValDecrement", 1, false, phylum_expression, kc_subphyla_ValDecrement, 0, 0, sizeof(impl_expression_ValDecrement) },
    { "PositiveExpr", 1, false, phylum_expression, kc_subphyla_PositiveExpr, 0, 0, sizeof(impl_expression_PositiveExpr) },
    { "NegativeExpr", 1, false, phylum_expression, kc_subphyla_NegativeExpr, 0, 0, sizeof(impl_expression_NegativeExpr) },
    { "ExprAddition", 2, false, phylum_expression, kc_subphyla_ExprAddition, 0, 0, sizeof(impl_expression_ExprAddition) },
    { "ExprSubtraction", 2, false, phylum_expression, kc_subphyla_ExprSubtraction, 0, 0, sizeof(impl_expression_ExprSubtraction) },
    { "ExprMultiplication", 2, false, phylum_expression, kc_subphyla_ExprMultiplication, 0, 0, sizeof(impl_expression_ExprMultiplication) },
    { "ExprDivision", 2, false, phylum_expression, kc_subphyla_ExprDivision, 0, 0, sizeof(impl_expression_ExprDivision) },
    { "ExprModulo", 2, false, phylum_expression, kc_subphyla_ExprModulo, 0, 0, sizeof(impl_expression_ExprModulo) },
    { "ExprNumber", 1, false, phylum_expression, kc_subphyla_ExprNumber, 0, 0, sizeof(impl_expression_ExprNumber) },
    { "NotExpr", 1, false, phylum_expression, kc_subphyla_NotExpr, 0, 0, sizeof(impl_expression_NotExpr) },
    { "ExprAnd", 2, false, phylum_expression, kc_subphyla_ExprAnd, 0, 0, sizeof(impl_expression_ExprAnd) },
    { "ExprOr", 2, false, phylum_expression, kc_subphyla_ExprOr, 0, 0, sizeof(impl_expression_ExprOr) },
    { "ExprTrue", 0, false, phylum_expression, 0, 0, 0, sizeof(impl_expression_ExprTrue) },
    { "ExprFalse", 0, false, phylum_expression, 0, 0, 0, sizeof(impl_expression_ExprFalse) },
    { "ExprEquivalent", 2, false, phylum_expression, kc_subphyla_ExprEquivalent, 0, 0, sizeof(impl_expression_ExprEquivalent) },
    { "ExprNotEqual", 2, false, phylum_expression, kc_subphyla_ExprNotEqual, 0, 0, sizeof(impl_expression_ExprNotEqual) },
    { "ExprLessThan", 2, false, phylum_expression, kc_subphyla_ExprLessThan, 0, 0, sizeof(impl_expression_ExprLessThan) },
    { "ExprGreaterThan", 2, false, phylum_expression, kc_subphyla_ExprGreaterThan, 0, 0, sizeof(impl_expression_ExprGreaterThan) },
    { "ExprLessOrEqual", 2, false, phylum_expression, kc_subphyla_ExprLessOrEqual, 0, 0, sizeof(impl_expression_ExprLessOrEqual) },
    { "ExprGreaterOrEqual", 2, false, phylum_expression, kc_subphyla_ExprGreaterOrEqual, 0, 0, sizeof(impl_expression_ExprGreaterOrEqual) },
    { "FunctionCall", 2, false, phylum_expression, kc_subphyla_FunctionCall, 0, 0, sizeof(impl_expression_FunctionCall) },
    { "ExprCommaSeparated", 1, false, phylum_expression, kc_subphyla_ExprCommaSeparated, 0, 0, sizeof(impl_expression_ExprCommaSeparated) },
    { "ExprOtherIf", 3, false, phylum_expression, kc_subphyla_ExprOtherIf, 0, 0, sizeof(impl_expression_ExprOtherIf) },
    { "ExprAll", 1, false, phylum_expression, kc_subphyla_ExprAll, 0, 0, sizeof(impl_expression_ExprAll) },
    { "LeftValIdent", 1, false, phylum_leftvalue, kc_subphyla_LeftValIdent, 0, 0, sizeof(impl_leftvalue_LeftValIdent) },
    { "LeftValBrackets", 2, false, phylum_leftvalue, kc_subphyla_LeftValBrackets, 0, 0, sizeof(impl_leftvalue_LeftValBrackets) },
    { "LeftValDot", 2, false, phylum_leftvalue, kc_subphyla_LeftValDot, 0, 0, sizeof(impl_leftvalue_LeftValDot) },
    { "EmptyExpressionList", 0, false, phylum_expressionlist, 0, 0, 0, sizeof(impl_expressionlist_EmptyExpressionList) },
    { "ExpressionList", 2, false, phylum_expressionlist, kc_subphyla_ExpressionList, 0, 0, sizeof(impl_expressionlist_ExpressionList) },
    { "ExprInBraces", 1, false, phylum_initializerList, kc_subphyla_ExprInBraces, 0, 0, sizeof(impl_initializerList_ExprInBraces) },
    { "ExprInBracesColon", 3, false, phylum_initializerList, kc_subphyla_ExprInBracesColon, 0, 0, sizeof(impl_initializerList_ExprInBracesColon) },
    { "EmptyExpressionListColon", 0, false, phylum_expressionListColon, 0, 0, 0, sizeof(impl_expressionListColon_EmptyExpressionListColon) },
    { "ExpressionListColon", 3, false, phylum_expressionListColon, kc_subphyla_ExpressionListColon, 0, 0, sizeof(impl_expressionListColon_ExpressionListColon) },
    { "EmptyPlaceBlockList", 0, false, phylum_placeblocklist, 0, 0, 0, sizeof(impl_placeblocklist_EmptyPlaceBlockList) },
    { "PlaceBlockList", 2, false, phylum_placeblocklist, kc_subphyla_PlaceBlockList, 0, 0, sizeof(impl_placeblocklist_PlaceBlockList) },
    { "EmptySafe", 0, false, phylum_optSafe, 0, 0, 0, sizeof(impl_optSafe_EmptySafe) },
    { "Safe", 1, false, phylum_optSafe, kc_subphyla_Safe, 0, 0, sizeof(impl_optSafe_Safe) },
    { "Place", 1, false, phylum_place, kc_subphyla_Place, 0, 0, sizeof(impl_place_Place) },
    { "EmptyPlaceList", 0, false, phylum_placelist, 0, 0, 0, sizeof(impl_placelist_EmptyPlaceList) },
    { "PlaceList", 2, false, phylum_placelist, kc_subphyla_PlaceList, 0, 0, sizeof(impl_placelist_PlaceList) },
    { "PlaceBlock", 3, false, phylum_placeblock, kc_subphyla_PlaceBlock, 0, 0, sizeof(impl_placeblock_PlaceBlock) },
    { "EmptyMarking", 0, false, phylum_marking, 0, 0, 0, sizeof(impl_marking_EmptyMarking) },
    { "Marking", 3, false, phylum_marking, kc_subphyla_Marking, 0, 0, sizeof(impl_marking_Marking) },
    { "EmptyTransition", 0, false, phylum_transition, 0, 0, 0, sizeof(impl_transition_EmptyTransition) },
    { "Transition", 7, false, phylum_transition, kc_subphyla_Transition, 0, 0, sizeof(impl_transition_Transition) },
    { "EmptyFairness", 0, false, phylum_fairness, 0, 0, 0, sizeof(impl_fairness_EmptyFairness) },
    { "WeakFair", 0, false, phylum_fairness, 0, 0, 0, sizeof(impl_fairness_WeakFair) },
    { "StrongFair", 0, false, phylum_fairness, 0, 0, 0, sizeof(impl_fairness_StrongFair) },
    { "EmptyVariable", 0, false, phylum_variable, 0, 0, 0, sizeof(impl_variable_EmptyVariable) },
    { "Variable", 3, false, phylum_variable, kc_subphyla_Variable, 0, 0, sizeof(impl_variable_Variable) },
    { "EmptyVarOrArrayList", 0, false, phylum_varOrArrayList, 0, 0, 0, sizeof(impl_varOrArrayList_EmptyVarOrArrayList) },
    { "VarOrArrayList", 2, false, phylum_varOrArrayList, kc_subphyla_VarOrArrayList, 0, 0, sizeof(impl_varOrArrayList_VarOrArrayList) },
    { "Guard", 1, false, phylum_guard, kc_subphyla_Guard, 0, 0, sizeof(impl_guard_Guard) },
    { "EmptyIdentExprList", 0, false, phylum_identExprList, 0, 0, 0, sizeof(impl_identExprList_EmptyIdentExprList) },
    { "IdentExprList", 3, false, phylum_identExprList, kc_subphyla_IdentExprList, 0, 0, sizeof(impl_identExprList_IdentExprList) },
    { "Block", 1, false, phylum_block, kc_subphyla_Block, 0, 0, sizeof(impl_block_Block) },
    { "EmptyDeclarationOrStatement", 0, false, phylum_declarationOrStatement, 0, 0, 0, sizeof(impl_declarationOrStatement_EmptyDeclarationOrStatement) },
    { "DeclOrStatemDeclaration", 2, false, phylum_declarationOrStatement, kc_subphyla_DeclOrStatemDeclaration, 0, 0, sizeof(impl_declarationOrStatement_DeclOrStatemDeclaration) },
    { "DeclOrStatemStatement", 2, false, phylum_declarationOrStatement, kc_subphyla_DeclOrStatemStatement, 0, 0, sizeof(impl_declarationOrStatement_DeclOrStatemStatement) },
    { "Declaration", 2, false, phylum_declaration, kc_subphyla_Declaration, 0, 0, sizeof(impl_declaration_Declaration) },
    { "StatementBlock", 1, false, phylum_statement, kc_subphyla_StatementBlock, 0, 0, sizeof(impl_statement_StatementBlock) },
    { "StatementExprSemicolon", 1, false, phylum_statement, kc_subphyla_StatementExprSemicolon, 0, 0, sizeof(impl_statement_StatementExprSemicolon) },
    { "StatementIf", 3, false, phylum_statement, kc_subphyla_StatementIf, 0, 0, sizeof(impl_statement_StatementIf) },
    { "StatementWhile", 2, false, phylum_statement, kc_subphyla_StatementWhile, 0, 0, sizeof(impl_statement_StatementWhile) },
    { "StatementDoWhile", 2, false, phylum_statement, kc_subphyla_StatementDoWhile, 0, 0, sizeof(impl_statement_StatementDoWhile) },
    { "StatementForExpr", 4, false, phylum_statement, kc_subphyla_StatementForExpr, 0, 0, sizeof(impl_statement_StatementForExpr) },
    { "StatementForTypeExpr", 6, false, phylum_statement, kc_subphyla_StatementForTypeExpr, 0, 0, sizeof(impl_statement_StatementForTypeExpr) },
    { "StatementForIdentColon", 3, false, phylum_statement, kc_subphyla_StatementForIdentColon, 0, 0, sizeof(impl_statement_StatementForIdentColon) },
    { "StatementForAll", 3, false, phylum_statement, kc_subphyla_StatementForAll, 0, 0, sizeof(impl_statement_StatementForAll) },
    { "StatementSwitch", 2, false, phylum_statement, kc_subphyla_StatementSwitch, 0, 0, sizeof(impl_statement_StatementSwitch) },
    { "StatementBreak", 0, false, phylum_statement, 0, 0, 0, sizeof(impl_statement_StatementBreak) },
    { "StatementContinue", 0, false, phylum_statement, 0, 0, 0, sizeof(impl_statement_StatementContinue) },
    { "StatementReturn", 1, false, phylum_statement, kc_subphyla_StatementReturn, 0, 0, sizeof(impl_statement_StatementReturn) },
    { "StatementSkip", 0, false, phylum_statement, 0, 0, 0, sizeof(impl_statement_StatementSkip) },
    { "SwitchCase", 2, false, phylum_switchCase, kc_subphyla_SwitchCase, 0, 0, sizeof(impl_switchCase_SwitchCase) },
    { "SwitchDefault", 1, false, phylum_switchCase, kc_subphyla_SwitchDefault, 0, 0, sizeof(impl_switchCase_SwitchDefault) },
    { "EmptySwitchCaseList", 0, false, phylum_switchCaseList, 0, 0, 0, sizeof(impl_switchCaseList_EmptySwitchCaseList) },
    { "SwitchCaseList", 2, false, phylum_switchCaseList, kc_subphyla_SwitchCaseList, 0, 0, sizeof(impl_switchCaseList_SwitchCaseList) },
    { "", 0, 0, one_before_first_phylum, 0, 0, 0, 0 } /* last element */
};

static enum_phyla phylumstorageclass_uniq[] = { one_before_first_phylum, phylum_nocasestring, phylum_casestring, phylum_real, phylum_integer, phylum_voidptr, last_phylum };

KC_UNIQ_INFO kc_UniqInfo[] = {
    (KC_UNIQ_INFO)0,
    phylumstorageclass_uniq
};

} // namespace kc

namespace kc {

void
kc_no_default_in_with( const char *kc_func, int kc_line, const char *kc_file )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=A2CT(KC_NO_DEFAULT_IN_WITH);
    const _TCHAR* tkc_func=A2CT(kc_func);
    const _TCHAR* tkc_file=A2CT(kc_file);
    TRACE( format, tkc_func, tkc_file, kc_line );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, KC_NO_DEFAULT_IN_WITH, kc_func, kc_file, kc_line );
#ifndef KC_NODEFAULT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_returnless_function( const char *kc_func, int kc_line, const char *kc_file )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: function %s does not return a value, at %s:%d");
    const _TCHAR* tkc_func=A2CT(kc_func);
    const _TCHAR* tkc_file=A2CT(kc_file);
    TRACE( format, tkc_func, tkc_file, kc_line );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: function %s does not return a value, at %s:%d", kc_func, kc_file, kc_line );
#ifndef KC_NODEFAULT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionFailed(const char *kc_fn, int kc_l)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    TRACE( format, tkc_func, kc_l );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at %s:%d\n", kc_fn, kc_l );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionReasonFailed(const char *kc_fn, int kc_l, const char *kc_s)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at file %s:%d: %s\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s=A2CT(kc_s);
    TRACE( format, tkc_func, kc_l, tkc_s );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at file %s:%d: %s\n", kc_fn, kc_l, kc_s );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionNonNullFailed(const char *kc_fn, int kc_l, const char *kc_str)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d: pointer %s is NULL\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s=A2CT(kc_str);
    TRACE( format , tkc_func, kc_l, tkc_s);
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at %s:%d: pointer %s is NULL\n", kc_fn, kc_l, kc_str );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionOperatorInPhylumFailed(int kc_op, const char *kc_str1, const char *kc_str2, const char *kc_phy, const char *kc_fn, int kc_l)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s1=A2CT(kc_str1);
    const _TCHAR* tkc_s2=A2CT(kc_str2);
    const _TCHAR* tname=A2CT(kc_phy);
    if ((kc_op <= one_before_first_operator) || (kc_op >= last_operator)) {
	TRACE (format, tkc_func, kc_l, tname, tkc_s1, tkc_s2, kc_op );
    } else {
	format=_T("Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %s (%d) is a value of %s\n");
	const _TCHAR* tname2=A2CT(operator_info[kc_op].name);
	const _TCHAR* tname3=A2CT(phylum_info[operator_info[kc_op].phylum].name);
	TRACE(format,tkc_func, kc_l, tname, tkc_s1, tkc_s2, tname2, kc_op, tname3 );
    }
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    if ((kc_op <= one_before_first_operator) || (kc_op >= last_operator)) {
	fprintf( stderr, "Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\n",
	    kc_fn, kc_l, kc_phy, kc_str1, kc_str2, kc_op );
    } else {
	fprintf( stderr, "Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %s (%d) is a value of %s\n",
	    kc_fn, kc_l, kc_phy, kc_str1, kc_str2, operator_info[kc_op].name, kc_op, phylum_info[operator_info[kc_op].phylum].name );
    }
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line, const char *kc_file, enum_operators kc_oper )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: invalid operator code in %s%s at %s:%d: %s\n");
    const _TCHAR* tkc_func=A2CT(kc_func_prefix);
    const _TCHAR* tkc_file=A2CT(kc_file);
    const _TCHAR* ts1=A2CT(phylumname_or_error( kc_phy ));
    const _TCHAR* ts2=A2CT(kc_operatorname_or_error( kc_oper ));
    TRACE( format, tkc_func, ts1, tkc_file, kc_line, ts2);
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: invalid operator code in %s%s at %s:%d: %s\n", kc_func_prefix, phylumname_or_error( kc_phy ), kc_file, kc_line, kc_operatorname_or_error( kc_oper ));
#ifndef KC_INVALID_OPERATOR_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}
const enum_phyla impl_nocasestring::phylum_sel_ = phylum_nocasestring;
const enum_phyla impl_casestring::phylum_sel_ = phylum_casestring;
const enum_phyla impl_real::phylum_sel_ = phylum_real;
impl_real__Real::impl_real__Real(REAL _value)
    : value(_value) { }
const enum_phyla impl_integer::phylum_sel_ = phylum_integer;
impl_integer__Int::impl_integer__Int(INTEGER _value)
    : value(_value) { }
const enum_phyla impl_voidptr::phylum_sel_ = phylum_voidptr;
impl_voidptr__VoidPtr::impl_voidptr__VoidPtr(void* _pointer)
    : pointer(_pointer) { }
const enum_phyla impl_tFormula::phylum_sel_ = phylum_tFormula;
impl_tFormula_Compound::impl_tFormula_Compound(tFormula _tFormula_1, tFormula _tFormula_2)
    : tFormula_1(_tFormula_1), tFormula_2(_tFormula_2) { }
impl_tFormula_ComputeBound::impl_tFormula_ComputeBound(tAtomicProposition _tAtomicProposition_1)
    : tAtomicProposition_1(_tAtomicProposition_1) { }
impl_tFormula_StatePredicateFormula::impl_tFormula_StatePredicateFormula(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
const enum_phyla impl_tStatePredicate::phylum_sel_ = phylum_tStatePredicate;
impl_tStatePredicate_DisjunctionList::impl_tStatePredicate_DisjunctionList(tDisjunction_list _tDisjunction_list_1)
    : tDisjunction_list_1(_tDisjunction_list_1) { }
impl_tStatePredicate_ConjunctionList::impl_tStatePredicate_ConjunctionList(tConjunction_list _tConjunction_list_1)
    : tConjunction_list_1(_tConjunction_list_1) { }
impl_tStatePredicate_EX::impl_tStatePredicate_EX(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_AX::impl_tStatePredicate_AX(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_EG::impl_tStatePredicate_EG(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_AG::impl_tStatePredicate_AG(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_EF::impl_tStatePredicate_EF(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_AF::impl_tStatePredicate_AF(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_ER::impl_tStatePredicate_ER(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_AR::impl_tStatePredicate_AR(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_EU::impl_tStatePredicate_EU(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_AU::impl_tStatePredicate_AU(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Release::impl_tStatePredicate_Release(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Until::impl_tStatePredicate_Until(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_NextState::impl_tStatePredicate_NextState(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_Eventually::impl_tStatePredicate_Eventually(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_Always::impl_tStatePredicate_Always(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_ExPath::impl_tStatePredicate_ExPath(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_AllPath::impl_tStatePredicate_AllPath(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_Equivalence::impl_tStatePredicate_Equivalence(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Implication::impl_tStatePredicate_Implication(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_ExclusiveDisjunction::impl_tStatePredicate_ExclusiveDisjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Disjunction::impl_tStatePredicate_Disjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Conjunction::impl_tStatePredicate_Conjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Negation::impl_tStatePredicate_Negation(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_AtomicProposition::impl_tStatePredicate_AtomicProposition(tAtomicProposition _tAtomicProposition_1)
    : tAtomicProposition_1(_tAtomicProposition_1) { }
const enum_phyla impl_tConjunction_list::phylum_sel_ = phylum_tConjunction_list;
impl_tConjunction_list::impl_tConjunction_list(tStatePredicate p1 , tConjunction_list p2)
    : tStatePredicate_1(p1), tConjunction_list_1(p2) { }
const enum_phyla impl_tDisjunction_list::phylum_sel_ = phylum_tDisjunction_list;
impl_tDisjunction_list::impl_tDisjunction_list(tStatePredicate p1 , tDisjunction_list p2)
    : tStatePredicate_1(p1), tDisjunction_list_1(p2) { }
const enum_phyla impl_tAtomicProposition::phylum_sel_ = phylum_tAtomicProposition;
impl_tAtomicProposition_Unfireable::impl_tAtomicProposition_Unfireable(integer _integer_1)
    : integer_1(_integer_1) { }
impl_tAtomicProposition_Fireable::impl_tAtomicProposition_Fireable(integer _integer_1)
    : integer_1(_integer_1) { }
impl_tAtomicProposition_Initial::impl_tAtomicProposition_Initial()
    { }
impl_tAtomicProposition_Deadlock::impl_tAtomicProposition_Deadlock()
    { }
impl_tAtomicProposition_NoDeadlock::impl_tAtomicProposition_NoDeadlock()
    { }
impl_tAtomicProposition_False::impl_tAtomicProposition_False()
    { }
impl_tAtomicProposition_True::impl_tAtomicProposition_True()
    { }
impl_tAtomicProposition_LessEqualAtomicProposition::impl_tAtomicProposition_LessEqualAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tAtomicProposition_LessAtomicProposition::impl_tAtomicProposition_LessAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tAtomicProposition_GreaterEqualAtomicProposition::impl_tAtomicProposition_GreaterEqualAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tAtomicProposition_GreaterAtomicProposition::impl_tAtomicProposition_GreaterAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tAtomicProposition_NotEqualsAtomicProposition::impl_tAtomicProposition_NotEqualsAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tAtomicProposition_EqualsAtomicProposition::impl_tAtomicProposition_EqualsAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
const enum_phyla impl_tTerm::phylum_sel_ = phylum_tTerm;
impl_tTerm_ProductList::impl_tTerm_ProductList(tProduct_list _tProduct_list_1)
    : tProduct_list_1(_tProduct_list_1) { }
impl_tTerm_Product::impl_tTerm_Product(integer _integer_1, tTerm _tTerm_1)
    : integer_1(_integer_1), tTerm_1(_tTerm_1) { }
impl_tTerm_Difference::impl_tTerm_Difference(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tTerm_Sum::impl_tTerm_Sum(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tTerm_Number::impl_tTerm_Number(integer _integer_1)
    : integer_1(_integer_1) { }
impl_tTerm_Node::impl_tTerm_Node(integer _integer_1)
    : integer_1(_integer_1) { }
const enum_phyla impl_tProduct_list::phylum_sel_ = phylum_tProduct_list;
impl_tProduct_list::impl_tProduct_list(tTerm p1 , tProduct_list p2)
    : tTerm_1(p1), tProduct_list_1(p2) { }
const enum_phyla impl_tBuechiAutomata::phylum_sel_ = phylum_tBuechiAutomata;
impl_tBuechiAutomata_BuechiNull::impl_tBuechiAutomata_BuechiNull()
    { }
impl_tBuechiAutomata_BuechiAutomaton::impl_tBuechiAutomata_BuechiAutomaton(tBuechiRules _tBuechiRules_1, tAcceptingSet _tAcceptingSet_1)
    : tBuechiRules_1(_tBuechiRules_1), tAcceptingSet_1(_tAcceptingSet_1) { }
const enum_phyla impl_tBuechiRules::phylum_sel_ = phylum_tBuechiRules;
impl_tBuechiRules_BuechiRules::impl_tBuechiRules_BuechiRules(tBuechiRules _tBuechiRules_1, tBuechiRules _tBuechiRules_2)
    : tBuechiRules_1(_tBuechiRules_1), tBuechiRules_2(_tBuechiRules_2) { }
impl_tBuechiRules_ExpandedBuechiRule::impl_tBuechiRules_ExpandedBuechiRule(integer _integer_1, tFormula _tFormula_1, integer _integer_2)
    : integer_1(_integer_1), tFormula_1(_tFormula_1), integer_2(_integer_2) { }
impl_tBuechiRules_BuechiRule::impl_tBuechiRules_BuechiRule(integer _integer_1, tTransitionRules _tTransitionRules_1)
    : integer_1(_integer_1), tTransitionRules_1(_tTransitionRules_1) { }
impl_tBuechiRules_EmptyBuechiRules::impl_tBuechiRules_EmptyBuechiRules()
    { }
const enum_phyla impl_tTransitionRules::phylum_sel_ = phylum_tTransitionRules;
impl_tTransitionRules_TransitionRules::impl_tTransitionRules_TransitionRules(tTransitionRules _tTransitionRules_1, tTransitionRules _tTransitionRules_2)
    : tTransitionRules_1(_tTransitionRules_1), tTransitionRules_2(_tTransitionRules_2) { }
impl_tTransitionRules_TransitionRule::impl_tTransitionRules_TransitionRule(tFormula _tFormula_1, integer _integer_1)
    : tFormula_1(_tFormula_1), integer_1(_integer_1) { }
impl_tTransitionRules_EmptyTransitionRules::impl_tTransitionRules_EmptyTransitionRules()
    { }
const enum_phyla impl_tAcceptingSet::phylum_sel_ = phylum_tAcceptingSet;
impl_tAcceptingSet_AcceptingSet::impl_tAcceptingSet_AcceptingSet(tAcceptingSet _tAcceptingSet_1, tAcceptingSet _tAcceptingSet_2)
    : tAcceptingSet_1(_tAcceptingSet_1), tAcceptingSet_2(_tAcceptingSet_2) { }
impl_tAcceptingSet_AcceptingState::impl_tAcceptingSet_AcceptingState(integer _integer_1)
    : integer_1(_integer_1) { }
impl_tAcceptingSet_EmptyAcceptingSet::impl_tAcceptingSet_EmptyAcceptingSet()
    { }
const enum_phyla impl_net::phylum_sel_ = phylum_net;
impl_net_Net::impl_net_Net(casestring _casestring_1, definitionsList _definitionsList_1, placeblocklist _placeblocklist_1, marking _marking_1, transition _transition_1)
    : casestring_1(_casestring_1), definitionsList_1(_definitionsList_1), placeblocklist_1(_placeblocklist_1), marking_1(_marking_1), transition_1(_transition_1) { }
const enum_phyla impl_definitionsList::phylum_sel_ = phylum_definitionsList;
impl_definitionsList_DefinitionsList::impl_definitionsList_DefinitionsList(definitionsList _definitionsList_1, definitions _definitions_1)
    : definitionsList_1(_definitionsList_1), definitions_1(_definitions_1) { }
impl_definitionsList_EmptyDefinitionsList::impl_definitionsList_EmptyDefinitionsList()
    { }
const enum_phyla impl_definitions::phylum_sel_ = phylum_definitions;
impl_definitions_Function::impl_definitions_Function(type _type_1, casestring _casestring_1, arrayList _arrayList_1, functionParametersList _functionParametersList_1, block _block_1)
    : type_1(_type_1), casestring_1(_casestring_1), arrayList_1(_arrayList_1), functionParametersList_1(_functionParametersList_1), block_1(_block_1) { }
impl_definitions_Sort::impl_definitions_Sort(type _type_1, casestring _casestring_1, arrayList _arrayList_1)
    : type_1(_type_1), casestring_1(_casestring_1), arrayList_1(_arrayList_1) { }
impl_definitions_Constant::impl_definitions_Constant(type _type_1, casestring _casestring_1, arrayList _arrayList_1, expression _expression_1)
    : type_1(_type_1), casestring_1(_casestring_1), arrayList_1(_arrayList_1), expression_1(_expression_1) { }
const enum_phyla impl_type::phylum_sel_ = phylum_type;
impl_type_TypeBlack::impl_type_TypeBlack()
    { }
impl_type_TypeArray::impl_type_TypeArray(type _type_1, integer _integer_1)
    : type_1(_type_1), integer_1(_integer_1) { }
impl_type_TypeMultiset::impl_type_TypeMultiset(type _type_1)
    : type_1(_type_1) { }
impl_type_TypeInt::impl_type_TypeInt()
    { }
impl_type_TypeStruct::impl_type_TypeStruct(structTypeList _structTypeList_1)
    : structTypeList_1(_structTypeList_1) { }
impl_type_TypeIntInterval::impl_type_TypeIntInterval(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_type_TypeIdent::impl_type_TypeIdent(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
impl_type_TypeEnum::impl_type_TypeEnum(identList _identList_1)
    : identList_1(_identList_1) { }
impl_type_TypeBool::impl_type_TypeBool()
    { }
const enum_phyla impl_optionalNumber::phylum_sel_ = phylum_optionalNumber;
impl_optionalNumber_OptNumber::impl_optionalNumber_OptNumber(integer _integer_1)
    : integer_1(_integer_1) { }
impl_optionalNumber_EmptyOptNumber::impl_optionalNumber_EmptyOptNumber()
    { }
const enum_phyla impl_identList::phylum_sel_ = phylum_identList;
impl_identList_IdentList::impl_identList_IdentList(identList _identList_1, idents _idents_1)
    : identList_1(_identList_1), idents_1(_idents_1) { }
impl_identList_EmptyIdentList::impl_identList_EmptyIdentList()
    { }
const enum_phyla impl_idents::phylum_sel_ = phylum_idents;
impl_idents_Idents::impl_idents_Idents(casestring _casestring_1, optionalNumber _optionalNumber_1)
    : casestring_1(_casestring_1), optionalNumber_1(_optionalNumber_1) { }
const enum_phyla impl_structTypeList::phylum_sel_ = phylum_structTypeList;
impl_structTypeList_StructTypeList::impl_structTypeList_StructTypeList(structTypeList _structTypeList_1, structType _structType_1)
    : structTypeList_1(_structTypeList_1), structType_1(_structType_1) { }
impl_structTypeList_EmptyStructTypeList::impl_structTypeList_EmptyStructTypeList()
    { }
const enum_phyla impl_structType::phylum_sel_ = phylum_structType;
impl_structType_StructType::impl_structType_StructType(type _type_1, casestring _casestring_1, arrayList _arrayList_1)
    : type_1(_type_1), casestring_1(_casestring_1), arrayList_1(_arrayList_1) { }
const enum_phyla impl_varOrArray::phylum_sel_ = phylum_varOrArray;
impl_varOrArray_VarOrArray::impl_varOrArray_VarOrArray(casestring _casestring_1, arrayList _arrayList_1)
    : casestring_1(_casestring_1), arrayList_1(_arrayList_1) { }
const enum_phyla impl_arrayList::phylum_sel_ = phylum_arrayList;
impl_arrayList_ArrayList::impl_arrayList_ArrayList(arrayList _arrayList_1, expression _expression_1)
    : arrayList_1(_arrayList_1), expression_1(_expression_1) { }
impl_arrayList_EmptyArrayList::impl_arrayList_EmptyArrayList()
    { }
const enum_phyla impl_functionParametersList::phylum_sel_ = phylum_functionParametersList;
impl_functionParametersList_FunctionParametersList::impl_functionParametersList_FunctionParametersList(functionParameters _functionParameters_1, functionParametersList _functionParametersList_1)
    : functionParameters_1(_functionParameters_1), functionParametersList_1(_functionParametersList_1) { }
impl_functionParametersList_EmptyFunctionParametersList::impl_functionParametersList_EmptyFunctionParametersList()
    { }
const enum_phyla impl_functionParameters::phylum_sel_ = phylum_functionParameters;
impl_functionParameters_FunctionParameters::impl_functionParameters_FunctionParameters(type _type_1, varOrArray _varOrArray_1)
    : type_1(_type_1), varOrArray_1(_varOrArray_1) { }
const enum_phyla impl_expression::phylum_sel_ = phylum_expression;
impl_expression_ExprAll::impl_expression_ExprAll(type _type_1)
    : type_1(_type_1) { }
impl_expression_ExprOtherIf::impl_expression_ExprOtherIf(expression _expression_1, expression _expression_2, expression _expression_3)
    : expression_1(_expression_1), expression_2(_expression_2), expression_3(_expression_3) { }
impl_expression_ExprCommaSeparated::impl_expression_ExprCommaSeparated(expressionlist _expressionlist_1)
    : expressionlist_1(_expressionlist_1) { }
impl_expression_FunctionCall::impl_expression_FunctionCall(casestring _casestring_1, expressionlist _expressionlist_1)
    : casestring_1(_casestring_1), expressionlist_1(_expressionlist_1) { }
impl_expression_ExprGreaterOrEqual::impl_expression_ExprGreaterOrEqual(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ExprLessOrEqual::impl_expression_ExprLessOrEqual(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ExprGreaterThan::impl_expression_ExprGreaterThan(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ExprLessThan::impl_expression_ExprLessThan(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ExprNotEqual::impl_expression_ExprNotEqual(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ExprEquivalent::impl_expression_ExprEquivalent(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ExprFalse::impl_expression_ExprFalse()
    { }
impl_expression_ExprTrue::impl_expression_ExprTrue()
    { }
impl_expression_ExprOr::impl_expression_ExprOr(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ExprAnd::impl_expression_ExprAnd(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_NotExpr::impl_expression_NotExpr(expression _expression_1)
    : expression_1(_expression_1) { }
impl_expression_ExprNumber::impl_expression_ExprNumber(integer _integer_1)
    : integer_1(_integer_1) { }
impl_expression_ExprModulo::impl_expression_ExprModulo(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ExprDivision::impl_expression_ExprDivision(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ExprMultiplication::impl_expression_ExprMultiplication(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ExprSubtraction::impl_expression_ExprSubtraction(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ExprAddition::impl_expression_ExprAddition(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_NegativeExpr::impl_expression_NegativeExpr(expression _expression_1)
    : expression_1(_expression_1) { }
impl_expression_PositiveExpr::impl_expression_PositiveExpr(expression _expression_1)
    : expression_1(_expression_1) { }
impl_expression_ValDecrement::impl_expression_ValDecrement(leftvalue _leftvalue_1)
    : leftvalue_1(_leftvalue_1) { }
impl_expression_ValIncrement::impl_expression_ValIncrement(leftvalue _leftvalue_1)
    : leftvalue_1(_leftvalue_1) { }
impl_expression_DecrementVal::impl_expression_DecrementVal(leftvalue _leftvalue_1)
    : leftvalue_1(_leftvalue_1) { }
impl_expression_IncrementVal::impl_expression_IncrementVal(leftvalue _leftvalue_1)
    : leftvalue_1(_leftvalue_1) { }
impl_expression_AssignMod::impl_expression_AssignMod(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_expression_AssignDivide::impl_expression_AssignDivide(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_expression_AssignTimes::impl_expression_AssignTimes(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_expression_AssignMinus::impl_expression_AssignMinus(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_expression_AssignPlus::impl_expression_AssignPlus(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_expression_AssignEqual::impl_expression_AssignEqual(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_expression_ExprInitializerList::impl_expression_ExprInitializerList(initializerList _initializerList_1)
    : initializerList_1(_initializerList_1) { }
impl_expression_ExprLeftvalue::impl_expression_ExprLeftvalue(leftvalue _leftvalue_1)
    : leftvalue_1(_leftvalue_1) { }
const enum_phyla impl_leftvalue::phylum_sel_ = phylum_leftvalue;
impl_leftvalue_LeftValDot::impl_leftvalue_LeftValDot(leftvalue _leftvalue_1, casestring _casestring_1)
    : leftvalue_1(_leftvalue_1), casestring_1(_casestring_1) { }
impl_leftvalue_LeftValBrackets::impl_leftvalue_LeftValBrackets(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_leftvalue_LeftValIdent::impl_leftvalue_LeftValIdent(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
const enum_phyla impl_expressionlist::phylum_sel_ = phylum_expressionlist;
impl_expressionlist_ExpressionList::impl_expressionlist_ExpressionList(expression _expression_1, expressionlist _expressionlist_1)
    : expression_1(_expression_1), expressionlist_1(_expressionlist_1) { }
impl_expressionlist_EmptyExpressionList::impl_expressionlist_EmptyExpressionList()
    { }
const enum_phyla impl_initializerList::phylum_sel_ = phylum_initializerList;
impl_initializerList_ExprInBracesColon::impl_initializerList_ExprInBracesColon(expression _expression_1, expression _expression_2, expressionListColon _expressionListColon_1)
    : expression_1(_expression_1), expression_2(_expression_2), expressionListColon_1(_expressionListColon_1) { }
impl_initializerList_ExprInBraces::impl_initializerList_ExprInBraces(expressionlist _expressionlist_1)
    : expressionlist_1(_expressionlist_1) { }
const enum_phyla impl_expressionListColon::phylum_sel_ = phylum_expressionListColon;
impl_expressionListColon_ExpressionListColon::impl_expressionListColon_ExpressionListColon(expression _expression_1, expression _expression_2, expressionListColon _expressionListColon_1)
    : expression_1(_expression_1), expression_2(_expression_2), expressionListColon_1(_expressionListColon_1) { }
impl_expressionListColon_EmptyExpressionListColon::impl_expressionListColon_EmptyExpressionListColon()
    { }
const enum_phyla impl_placeblocklist::phylum_sel_ = phylum_placeblocklist;
impl_placeblocklist_PlaceBlockList::impl_placeblocklist_PlaceBlockList(placeblock _placeblock_1, placeblocklist _placeblocklist_1)
    : placeblock_1(_placeblock_1), placeblocklist_1(_placeblocklist_1) { }
impl_placeblocklist_EmptyPlaceBlockList::impl_placeblocklist_EmptyPlaceBlockList()
    { }
const enum_phyla impl_optSafe::phylum_sel_ = phylum_optSafe;
impl_optSafe_Safe::impl_optSafe_Safe(integer _integer_1)
    : integer_1(_integer_1) { }
impl_optSafe_EmptySafe::impl_optSafe_EmptySafe()
    { }
const enum_phyla impl_place::phylum_sel_ = phylum_place;
impl_place_Place::impl_place_Place(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
const enum_phyla impl_placelist::phylum_sel_ = phylum_placelist;
impl_placelist_PlaceList::impl_placelist_PlaceList(place _place_1, placelist _placelist_1)
    : place_1(_place_1), placelist_1(_placelist_1) { }
impl_placelist_EmptyPlaceList::impl_placelist_EmptyPlaceList()
    { }
const enum_phyla impl_placeblock::phylum_sel_ = phylum_placeblock;
impl_placeblock_PlaceBlock::impl_placeblock_PlaceBlock(optSafe _optSafe_1, type _type_1, placelist _placelist_1)
    : optSafe_1(_optSafe_1), type_1(_type_1), placelist_1(_placelist_1) { }
const enum_phyla impl_marking::phylum_sel_ = phylum_marking;
impl_marking_Marking::impl_marking_Marking(casestring _casestring_1, expression _expression_1, marking _marking_1)
    : casestring_1(_casestring_1), expression_1(_expression_1), marking_1(_marking_1) { }
impl_marking_EmptyMarking::impl_marking_EmptyMarking()
    { }
const enum_phyla impl_transition::phylum_sel_ = phylum_transition;
impl_transition_Transition::impl_transition_Transition(casestring _casestring_1, fairness _fairness_1, variable _variable_1, guard _guard_1, identExprList _identExprList_1, identExprList _identExprList_2, transition _transition_1)
    : casestring_1(_casestring_1), fairness_1(_fairness_1), variable_1(_variable_1), guard_1(_guard_1), identExprList_1(_identExprList_1), identExprList_2(_identExprList_2), transition_1(_transition_1) { }
impl_transition_EmptyTransition::impl_transition_EmptyTransition()
    { }
const enum_phyla impl_fairness::phylum_sel_ = phylum_fairness;
impl_fairness_StrongFair::impl_fairness_StrongFair()
    { }
impl_fairness_WeakFair::impl_fairness_WeakFair()
    { }
impl_fairness_EmptyFairness::impl_fairness_EmptyFairness()
    { }
const enum_phyla impl_variable::phylum_sel_ = phylum_variable;
impl_variable_Variable::impl_variable_Variable(type _type_1, varOrArrayList _varOrArrayList_1, variable _variable_1)
    : type_1(_type_1), varOrArrayList_1(_varOrArrayList_1), variable_1(_variable_1) { }
impl_variable_EmptyVariable::impl_variable_EmptyVariable()
    { }
const enum_phyla impl_varOrArrayList::phylum_sel_ = phylum_varOrArrayList;
impl_varOrArrayList_VarOrArrayList::impl_varOrArrayList_VarOrArrayList(varOrArray _varOrArray_1, varOrArrayList _varOrArrayList_1)
    : varOrArray_1(_varOrArray_1), varOrArrayList_1(_varOrArrayList_1) { }
impl_varOrArrayList_EmptyVarOrArrayList::impl_varOrArrayList_EmptyVarOrArrayList()
    { }
const enum_phyla impl_guard::phylum_sel_ = phylum_guard;
impl_guard_Guard::impl_guard_Guard(expression _expression_1)
    : expression_1(_expression_1) { }
const enum_phyla impl_identExprList::phylum_sel_ = phylum_identExprList;
impl_identExprList_IdentExprList::impl_identExprList_IdentExprList(casestring _casestring_1, expression _expression_1, identExprList _identExprList_1)
    : casestring_1(_casestring_1), expression_1(_expression_1), identExprList_1(_identExprList_1) { }
impl_identExprList_EmptyIdentExprList::impl_identExprList_EmptyIdentExprList()
    { }
const enum_phyla impl_block::phylum_sel_ = phylum_block;
impl_block_Block::impl_block_Block(declarationOrStatement _declarationOrStatement_1)
    : declarationOrStatement_1(_declarationOrStatement_1) { }
const enum_phyla impl_declarationOrStatement::phylum_sel_ = phylum_declarationOrStatement;
impl_declarationOrStatement_DeclOrStatemStatement::impl_declarationOrStatement_DeclOrStatemStatement(statement _statement_1, declarationOrStatement _declarationOrStatement_1)
    : statement_1(_statement_1), declarationOrStatement_1(_declarationOrStatement_1) { }
impl_declarationOrStatement_DeclOrStatemDeclaration::impl_declarationOrStatement_DeclOrStatemDeclaration(declaration _declaration_1, declarationOrStatement _declarationOrStatement_1)
    : declaration_1(_declaration_1), declarationOrStatement_1(_declarationOrStatement_1) { }
impl_declarationOrStatement_EmptyDeclarationOrStatement::impl_declarationOrStatement_EmptyDeclarationOrStatement()
    { }
const enum_phyla impl_declaration::phylum_sel_ = phylum_declaration;
impl_declaration_Declaration::impl_declaration_Declaration(type _type_1, varOrArrayList _varOrArrayList_1)
    : type_1(_type_1), varOrArrayList_1(_varOrArrayList_1) { }
const enum_phyla impl_statement::phylum_sel_ = phylum_statement;
impl_statement_StatementSkip::impl_statement_StatementSkip()
    { }
impl_statement_StatementReturn::impl_statement_StatementReturn(expression _expression_1)
    : expression_1(_expression_1) { }
impl_statement_StatementContinue::impl_statement_StatementContinue()
    { }
impl_statement_StatementBreak::impl_statement_StatementBreak()
    { }
impl_statement_StatementSwitch::impl_statement_StatementSwitch(expression _expression_1, switchCaseList _switchCaseList_1)
    : expression_1(_expression_1), switchCaseList_1(_switchCaseList_1) { }
impl_statement_StatementForAll::impl_statement_StatementForAll(type _type_1, casestring _casestring_1, type _type_2)
    : type_1(_type_1), casestring_1(_casestring_1), type_2(_type_2) { }
impl_statement_StatementForIdentColon::impl_statement_StatementForIdentColon(casestring _casestring_1, expression _expression_1, statement _statement_1)
    : casestring_1(_casestring_1), expression_1(_expression_1), statement_1(_statement_1) { }
impl_statement_StatementForTypeExpr::impl_statement_StatementForTypeExpr(type _type_1, casestring _casestring_1, expression _expression_1, expression _expression_2, expression _expression_3, statement _statement_1)
    : type_1(_type_1), casestring_1(_casestring_1), expression_1(_expression_1), expression_2(_expression_2), expression_3(_expression_3), statement_1(_statement_1) { }
impl_statement_StatementForExpr::impl_statement_StatementForExpr(expression _expression_1, expression _expression_2, expression _expression_3, statement _statement_1)
    : expression_1(_expression_1), expression_2(_expression_2), expression_3(_expression_3), statement_1(_statement_1) { }
impl_statement_StatementDoWhile::impl_statement_StatementDoWhile(statement _statement_1, expression _expression_1)
    : statement_1(_statement_1), expression_1(_expression_1) { }
impl_statement_StatementWhile::impl_statement_StatementWhile(expression _expression_1, statement _statement_1)
    : expression_1(_expression_1), statement_1(_statement_1) { }
impl_statement_StatementIf::impl_statement_StatementIf(expression _expression_1, statement _statement_1, statement _statement_2)
    : expression_1(_expression_1), statement_1(_statement_1), statement_2(_statement_2) { }
impl_statement_StatementExprSemicolon::impl_statement_StatementExprSemicolon(expression _expression_1)
    : expression_1(_expression_1) { }
impl_statement_StatementBlock::impl_statement_StatementBlock(block _block_1)
    : block_1(_block_1) { }
const enum_phyla impl_switchCase::phylum_sel_ = phylum_switchCase;
impl_switchCase_SwitchDefault::impl_switchCase_SwitchDefault(statement _statement_1)
    : statement_1(_statement_1) { }
impl_switchCase_SwitchCase::impl_switchCase_SwitchCase(expression _expression_1, statement _statement_1)
    : expression_1(_expression_1), statement_1(_statement_1) { }
const enum_phyla impl_switchCaseList::phylum_sel_ = phylum_switchCaseList;
impl_switchCaseList_SwitchCaseList::impl_switchCaseList_SwitchCaseList(switchCase _switchCase_1, switchCaseList _switchCaseList_1)
    : switchCase_1(_switchCase_1), switchCaseList_1(_switchCaseList_1) { }
impl_switchCaseList_EmptySwitchCaseList::impl_switchCaseList_EmptySwitchCaseList()
    { }

#ifdef KC_STATISTICS
KC_OPERATOR_STATISTICS operator_statistics[KC_NO_OF_OPERATORS];
static int kc_casestring_strlen =0;
static int kc_nocasestring_strlen =0;
#  define KC_COLLECT_STATS0(v) v
#else
#  define KC_COLLECT_STATS0(v)
#endif

#ifndef KC_CREATE_STATS
#  define KC_CREATE_STATS(oper) operator_statistics[oper].created++;
#endif
#ifndef KC_EXISTINGNOTFOUND_STATS
#  define KC_EXISTINGNOTFOUND_STATS(oper) operator_statistics[oper].existing_not_found++;
#endif

#ifndef KC_FREE_CALLED_STATS
#  define KC_FREE_CALLED_STATS(oper,rec) operator_statistics[oper].free_called[(rec?true:false)]++;
#endif

#ifndef KC_FREED_STATS
#  define KC_FREED_STATS(oper,rec) operator_statistics[oper].freed[(rec?true:false)]++;
#endif
static hashtable_struct_t kc_not_uniq_static_hashtable;
static hashtable_struct_t uniq_static_hashtable;

bool kc_storageclass_still_uniq[] = {
    true, true };

hashtable_t hashtables[] = {
    &kc_not_uniq_static_hashtable,
    &uniq_static_hashtable,
};

const char* kc_storageclassnames[] = { "kc_not_uniq", "uniq" };

namespace { // all local to k.cc

tFormula kc_initialize_tFormula(tFormula kc_x)
{
#line 49 "Frontend/Parser/formula_abstract.k"
    kc_x->type =  FORMULA_MODELCHECKING;
#line 50 "Frontend/Parser/formula_abstract.k"
    kc_x->formula =  NULL;
#line 51 "Frontend/Parser/formula_abstract.k"
    kc_x->ctl_formula =  NULL;
#line 52 "Frontend/Parser/formula_abstract.k"
    kc_x->ltl_tree =  NULL;
#line 53 "Frontend/Parser/formula_abstract.k"
    kc_x->cannotcompute =  false;
#line 55 "Frontend/Parser/formula_abstract.k"
    kc_x->task =  NULL;
#line 56 "Frontend/Parser/formula_abstract.k"
    kc_x->containsDeadlock =  0;
#line 58 "Frontend/Parser/formula_abstract.k"
    kc_x->length =  0;
#line 60 "Frontend/Parser/formula_abstract.k"
    kc_x->number_of_or_dnf =  0;
#line 62 "Frontend/Parser/formula_abstract.k"
    kc_x->number_of_or =  0;
#line 64 "Frontend/Parser/formula_abstract.k"
    kc_x->number_of_and =  0;
#line 66 "Frontend/Parser/formula_abstract.k"
    kc_x->only_fireable =  true;

#line  3916 "ast-system-k.cc"
    return kc_x;
}

tStatePredicate kc_initialize_tStatePredicate(tStatePredicate kc_x)
{
#line 99 "Frontend/Parser/formula_abstract.k"
    kc_x->containsTemporal =  false;
#line 101 "Frontend/Parser/formula_abstract.k"
    kc_x->validCTLPathFormula =  false;
#line 103 "Frontend/Parser/formula_abstract.k"
    kc_x->validCTLStateFormula =  false;
#line 105 "Frontend/Parser/formula_abstract.k"
    kc_x->validLTLFormula =  false;
#line 107 "Frontend/Parser/formula_abstract.k"
    kc_x->cannotcompute =  false;
#line 109 "Frontend/Parser/formula_abstract.k"
    kc_x->task =  NULL;
#line 110 "Frontend/Parser/formula_abstract.k"
    kc_x->priority =  0;
#line 111 "Frontend/Parser/formula_abstract.k"
    kc_x->type =  FORMULA_MODELCHECKING;
#line 112 "Frontend/Parser/formula_abstract.k"
    kc_x->containsDeadlock =  0;
#line 115 "Frontend/Parser/formula_abstract.k"
    kc_x->length =  0;
#line 117 "Frontend/Parser/formula_abstract.k"
    kc_x->number_of_or_dnf =  0;
#line 119 "Frontend/Parser/formula_abstract.k"
    kc_x->number_of_or =  0;
#line 121 "Frontend/Parser/formula_abstract.k"
    kc_x->number_of_and =  0;
#line 123 "Frontend/Parser/formula_abstract.k"
    kc_x->only_fireable =  true;

#line  3951 "ast-system-k.cc"
    return kc_x;
}

tConjunction_list kc_initialize_tConjunction_list(tConjunction_list kc_x)
{
#line 130 "Frontend/Parser/formula_abstract.k"
    kc_x->containsDeadlock =  0;

#line  3960 "ast-system-k.cc"
    return kc_x;
}

tDisjunction_list kc_initialize_tDisjunction_list(tDisjunction_list kc_x)
{
#line 137 "Frontend/Parser/formula_abstract.k"
    kc_x->containsDeadlock =  0;

#line  3969 "ast-system-k.cc"
    return kc_x;
}

tAtomicProposition kc_initialize_tAtomicProposition(tAtomicProposition kc_x)
{
#line 158 "Frontend/Parser/formula_abstract.k"
    kc_x->only_fireable =  true;
#line 159 "Frontend/Parser/formula_abstract.k"
    kc_x->containsDeadlock =  0;

#line  3980 "ast-system-k.cc"
    return kc_x;
}

type kc_initialize_type(type kc_x)
{
#line 235 "Frontend/Parser/formula_abstract.k"
    kc_x->is_finite =  false;
#line 236 "Frontend/Parser/formula_abstract.k"
    kc_x->is_scalar =  false;
#line 237 "Frontend/Parser/formula_abstract.k"
    kc_x->size =  0;

#line  3993 "ast-system-k.cc"
    return kc_x;
}

expression kc_initialize_expression(expression kc_x)
{
#line 355 "Frontend/Parser/formula_abstract.k"
    kc_x->check =  UNDEF;
#line 356 "Frontend/Parser/formula_abstract.k"
    kc_x->is_constant =  false;

#line  4004 "ast-system-k.cc"
    return kc_x;
}


} // namespace

enum_phyla
impl_abstract_phylum::phylum() const {
    return operator_info[prod_sel()].phylum;
}

const char*
impl_abstract_phylum::phylum_name() const {
    return phylum_info[phylum()].name;
}

const char*
impl_abstract_phylum::op_name() const {
    return operator_info[prod_sel()].name;
}

casestring
mkcasestring(const kc_char_t *kc_s, int length)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Str));

    casestring kc_x=new impl_casestring__Str(kc_s);
    if(length>=0) 
	kc_x->make_own(length);

    casestring unique_kc_x=hashtables[uniq]->ht_check_insert((casestring)kc_x);
    if(unique_kc_x!=kc_x) {
	if(length<0) 
	    kc_x->name=0;

	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Str));
	if(length<0) 
	    kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));

	kc_x->post_create();
    }
    return kc_x;
}

nocasestring
mknocasestring(const kc_char_t *kc_s, int length)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NoCaseStr));

    nocasestring kc_x=new impl_nocasestring_NoCaseStr(kc_s);
    if(length>=0)
	kc_x->make_own(length);
    nocasestring unique_kc_x=hashtables[uniq]->ht_check_insert((nocasestring)kc_x);
    if(unique_kc_x!=kc_x) {
	if(length<0)
	    kc_x->name=0;
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NoCaseStr));
	if(length<0)
	    kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));
	kc_x->post_create();
    }

    return kc_x;
}

integer
mkinteger(const INTEGER kc_i)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Int));

    integer kc_x =new impl_integer__Int(kc_i);
    integer unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Int));
	kc_x->post_create();
    }

    return kc_x;
}

real
mkreal(const REAL kc_r)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Real));

    real kc_x=new impl_real__Real(kc_r);
    real unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Real));
	kc_x->post_create();
    }

    return kc_x;
}

voidptr
mkvoidptr(void *kc_p)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__VoidPtr));
    voidptr kc_x=new impl_voidptr__VoidPtr(kc_p);
    voidptr unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__VoidPtr));
	kc_x->post_create();
    }
    return kc_x;
}

impl_tFormula_StatePredicateFormula*
StatePredicateFormula(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tFormula kc_x = new impl_tFormula_StatePredicateFormula(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatePredicateFormula));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatePredicateFormula));
    kc_x->post_create();
    kc_x = kc_initialize_tFormula(kc_x);
    return static_cast<impl_tFormula_StatePredicateFormula*>(kc_x);
}

impl_tFormula_ComputeBound*
ComputeBound(tAtomicProposition _tAtomicProposition_1) {
    assertPhylum(_tAtomicProposition_1, phylum_tAtomicProposition);
    tFormula kc_x = new impl_tFormula_ComputeBound(_tAtomicProposition_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ComputeBound));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ComputeBound));
    kc_x->post_create();
    kc_x = kc_initialize_tFormula(kc_x);
    return static_cast<impl_tFormula_ComputeBound*>(kc_x);
}

impl_tFormula_Compound*
Compound(tFormula _tFormula_1, tFormula _tFormula_2) {
    assertPhylum(_tFormula_1, phylum_tFormula);
    assertPhylum(_tFormula_2, phylum_tFormula);
    tFormula kc_x = new impl_tFormula_Compound(_tFormula_1, _tFormula_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Compound));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Compound));
    kc_x->post_create();
    kc_x = kc_initialize_tFormula(kc_x);
    return static_cast<impl_tFormula_Compound*>(kc_x);
}

impl_tStatePredicate_AtomicProposition*
AtomicProposition(tAtomicProposition _tAtomicProposition_1) {
    assertPhylum(_tAtomicProposition_1, phylum_tAtomicProposition);
    tStatePredicate kc_x = new impl_tStatePredicate_AtomicProposition(_tAtomicProposition_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AtomicProposition));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AtomicProposition*>(kc_x);
}

impl_tStatePredicate_Negation*
Negation(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Negation(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Negation));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Negation));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Negation*>(kc_x);
}

impl_tStatePredicate_Conjunction*
Conjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Conjunction(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Conjunction));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Conjunction));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Conjunction*>(kc_x);
}

impl_tStatePredicate_Disjunction*
Disjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Disjunction(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Disjunction));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Disjunction));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Disjunction*>(kc_x);
}

impl_tStatePredicate_ExclusiveDisjunction*
ExclusiveDisjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_ExclusiveDisjunction(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExclusiveDisjunction));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExclusiveDisjunction));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_ExclusiveDisjunction*>(kc_x);
}

impl_tStatePredicate_Implication*
Implication(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Implication(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Implication));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Implication));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Implication*>(kc_x);
}

impl_tStatePredicate_Equivalence*
Equivalence(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Equivalence(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Equivalence));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Equivalence));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Equivalence*>(kc_x);
}

impl_tStatePredicate_AllPath*
AllPath(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AllPath(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AllPath));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AllPath));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AllPath*>(kc_x);
}

impl_tStatePredicate_ExPath*
ExPath(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_ExPath(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExPath));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExPath));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_ExPath*>(kc_x);
}

impl_tStatePredicate_Always*
Always(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Always(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Always));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Always));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Always*>(kc_x);
}

impl_tStatePredicate_Eventually*
Eventually(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Eventually(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Eventually));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Eventually));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Eventually*>(kc_x);
}

impl_tStatePredicate_NextState*
NextState(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_NextState(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NextState));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NextState));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_NextState*>(kc_x);
}

impl_tStatePredicate_Until*
Until(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Until(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Until));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Until));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Until*>(kc_x);
}

impl_tStatePredicate_Release*
Release(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Release(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Release));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Release));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Release*>(kc_x);
}

impl_tStatePredicate_AU*
AU(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AU(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AU));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AU));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AU*>(kc_x);
}

impl_tStatePredicate_EU*
EU(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_EU(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EU));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EU));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_EU*>(kc_x);
}

impl_tStatePredicate_AR*
AR(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AR(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AR));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AR));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AR*>(kc_x);
}

impl_tStatePredicate_ER*
ER(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_ER(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ER));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ER));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_ER*>(kc_x);
}

impl_tStatePredicate_AF*
AF(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AF(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AF));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AF));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AF*>(kc_x);
}

impl_tStatePredicate_EF*
EF(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_EF(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EF));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EF));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_EF*>(kc_x);
}

impl_tStatePredicate_AG*
AG(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AG(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AG));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AG));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AG*>(kc_x);
}

impl_tStatePredicate_EG*
EG(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_EG(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EG));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EG));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_EG*>(kc_x);
}

impl_tStatePredicate_AX*
AX(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AX(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AX));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AX));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AX*>(kc_x);
}

impl_tStatePredicate_EX*
EX(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_EX(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EX));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EX));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_EX*>(kc_x);
}

impl_tStatePredicate_ConjunctionList*
ConjunctionList(tConjunction_list _tConjunction_list_1) {
    assertPhylum(_tConjunction_list_1, phylum_tConjunction_list);
    tStatePredicate kc_x = new impl_tStatePredicate_ConjunctionList(_tConjunction_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ConjunctionList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ConjunctionList));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_ConjunctionList*>(kc_x);
}

impl_tStatePredicate_DisjunctionList*
DisjunctionList(tDisjunction_list _tDisjunction_list_1) {
    assertPhylum(_tDisjunction_list_1, phylum_tDisjunction_list);
    tStatePredicate kc_x = new impl_tStatePredicate_DisjunctionList(_tDisjunction_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DisjunctionList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DisjunctionList));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_DisjunctionList*>(kc_x);
}

impl_tConjunction_list*
NiltConjunction_list() {
    tConjunction_list kc_x = new impl_tConjunction_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NiltConjunction_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NiltConjunction_list));
    kc_x->post_create();
    kc_x = kc_initialize_tConjunction_list(kc_x);
    return static_cast<impl_tConjunction_list*>(kc_x);
}

impl_tConjunction_list*
ConstConjunction_list(tStatePredicate _tStatePredicate_1, tConjunction_list _tConjunction_list_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tConjunction_list_1, phylum_tConjunction_list);
    tConjunction_list kc_x = new impl_tConjunction_list(_tStatePredicate_1, _tConjunction_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ConstConjunction_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ConstConjunction_list));
    kc_x->post_create();
    kc_x = kc_initialize_tConjunction_list(kc_x);
    return static_cast<impl_tConjunction_list*>(kc_x);
}

impl_tDisjunction_list*
NiltDisjunction_list() {
    tDisjunction_list kc_x = new impl_tDisjunction_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NiltDisjunction_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NiltDisjunction_list));
    kc_x->post_create();
    kc_x = kc_initialize_tDisjunction_list(kc_x);
    return static_cast<impl_tDisjunction_list*>(kc_x);
}

impl_tDisjunction_list*
ConstDisjunction_list(tStatePredicate _tStatePredicate_1, tDisjunction_list _tDisjunction_list_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tDisjunction_list_1, phylum_tDisjunction_list);
    tDisjunction_list kc_x = new impl_tDisjunction_list(_tStatePredicate_1, _tDisjunction_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ConstDisjunction_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ConstDisjunction_list));
    kc_x->post_create();
    kc_x = kc_initialize_tDisjunction_list(kc_x);
    return static_cast<impl_tDisjunction_list*>(kc_x);
}

impl_tAtomicProposition_EqualsAtomicProposition*
EqualsAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_EqualsAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EqualsAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EqualsAtomicProposition));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_EqualsAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_NotEqualsAtomicProposition*
NotEqualsAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_NotEqualsAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NotEqualsAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NotEqualsAtomicProposition));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_NotEqualsAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_GreaterAtomicProposition*
GreaterAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_GreaterAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_GreaterAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_GreaterAtomicProposition));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_GreaterAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_GreaterEqualAtomicProposition*
GreaterEqualAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_GreaterEqualAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_GreaterEqualAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_GreaterEqualAtomicProposition));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_GreaterEqualAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_LessAtomicProposition*
LessAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_LessAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_LessAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_LessAtomicProposition));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_LessAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_LessEqualAtomicProposition*
LessEqualAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_LessEqualAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_LessEqualAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_LessEqualAtomicProposition));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_LessEqualAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_True*
True() {
    tAtomicProposition kc_x = new impl_tAtomicProposition_True();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_True));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_True));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_True*>(kc_x);
}

impl_tAtomicProposition_False*
False() {
    tAtomicProposition kc_x = new impl_tAtomicProposition_False();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_False));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_False));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_False*>(kc_x);
}

impl_tAtomicProposition_NoDeadlock*
NoDeadlock() {
    tAtomicProposition kc_x = new impl_tAtomicProposition_NoDeadlock();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NoDeadlock));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NoDeadlock));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_NoDeadlock*>(kc_x);
}

impl_tAtomicProposition_Deadlock*
Deadlock() {
    tAtomicProposition kc_x = new impl_tAtomicProposition_Deadlock();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Deadlock));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Deadlock));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_Deadlock*>(kc_x);
}

impl_tAtomicProposition_Initial*
Initial() {
    tAtomicProposition kc_x = new impl_tAtomicProposition_Initial();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Initial));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Initial));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_Initial*>(kc_x);
}

impl_tAtomicProposition_Fireable*
Fireable(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    tAtomicProposition kc_x = new impl_tAtomicProposition_Fireable(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Fireable));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Fireable));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_Fireable*>(kc_x);
}

impl_tAtomicProposition_Unfireable*
Unfireable(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    tAtomicProposition kc_x = new impl_tAtomicProposition_Unfireable(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Unfireable));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Unfireable));
    kc_x->post_create();
    kc_x = kc_initialize_tAtomicProposition(kc_x);
    return static_cast<impl_tAtomicProposition_Unfireable*>(kc_x);
}

impl_tTerm_Node*
Node(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    tTerm kc_x = new impl_tTerm_Node(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Node));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Node));
    kc_x->post_create();
    return static_cast<impl_tTerm_Node*>(kc_x);
}

impl_tTerm_Number*
Number(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    tTerm kc_x = new impl_tTerm_Number(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Number));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Number));
    kc_x->post_create();
    return static_cast<impl_tTerm_Number*>(kc_x);
}

impl_tTerm_Sum*
Sum(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tTerm kc_x = new impl_tTerm_Sum(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Sum));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Sum));
    kc_x->post_create();
    return static_cast<impl_tTerm_Sum*>(kc_x);
}

impl_tTerm_Difference*
Difference(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tTerm kc_x = new impl_tTerm_Difference(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Difference));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Difference));
    kc_x->post_create();
    return static_cast<impl_tTerm_Difference*>(kc_x);
}

impl_tTerm_Product*
Product(integer _integer_1, tTerm _tTerm_1) {
    assertPhylum(_integer_1, phylum_integer);
    assertPhylum(_tTerm_1, phylum_tTerm);
    tTerm kc_x = new impl_tTerm_Product(_integer_1, _tTerm_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Product));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Product));
    kc_x->post_create();
    return static_cast<impl_tTerm_Product*>(kc_x);
}

impl_tTerm_ProductList*
ProductList(tProduct_list _tProduct_list_1) {
    assertPhylum(_tProduct_list_1, phylum_tProduct_list);
    tTerm kc_x = new impl_tTerm_ProductList(_tProduct_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ProductList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ProductList));
    kc_x->post_create();
    return static_cast<impl_tTerm_ProductList*>(kc_x);
}

impl_tProduct_list*
NiltProduct_list() {
    tProduct_list kc_x = new impl_tProduct_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NiltProduct_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NiltProduct_list));
    kc_x->post_create();
    return static_cast<impl_tProduct_list*>(kc_x);
}

impl_tProduct_list*
ConstProduct_list(tTerm _tTerm_1, tProduct_list _tProduct_list_1) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tProduct_list_1, phylum_tProduct_list);
    tProduct_list kc_x = new impl_tProduct_list(_tTerm_1, _tProduct_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ConstProduct_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ConstProduct_list));
    kc_x->post_create();
    return static_cast<impl_tProduct_list*>(kc_x);
}

impl_tBuechiAutomata_BuechiAutomaton*
BuechiAutomaton(tBuechiRules _tBuechiRules_1, tAcceptingSet _tAcceptingSet_1) {
    assertPhylum(_tBuechiRules_1, phylum_tBuechiRules);
    assertPhylum(_tAcceptingSet_1, phylum_tAcceptingSet);
    tBuechiAutomata kc_x = new impl_tBuechiAutomata_BuechiAutomaton(_tBuechiRules_1, _tAcceptingSet_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_BuechiAutomaton));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_BuechiAutomaton));
    kc_x->post_create();
    return static_cast<impl_tBuechiAutomata_BuechiAutomaton*>(kc_x);
}

impl_tBuechiAutomata_BuechiNull*
BuechiNull() {
    tBuechiAutomata kc_x = new impl_tBuechiAutomata_BuechiNull();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_BuechiNull));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_BuechiNull));
    kc_x->post_create();
    return static_cast<impl_tBuechiAutomata_BuechiNull*>(kc_x);
}

impl_tBuechiRules_EmptyBuechiRules*
EmptyBuechiRules() {
    tBuechiRules kc_x = new impl_tBuechiRules_EmptyBuechiRules();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyBuechiRules));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyBuechiRules));
    kc_x->post_create();
    return static_cast<impl_tBuechiRules_EmptyBuechiRules*>(kc_x);
}

impl_tBuechiRules_BuechiRule*
BuechiRule(integer _integer_1, tTransitionRules _tTransitionRules_1) {
    assertPhylum(_integer_1, phylum_integer);
    assertPhylum(_tTransitionRules_1, phylum_tTransitionRules);
    tBuechiRules kc_x = new impl_tBuechiRules_BuechiRule(_integer_1, _tTransitionRules_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_BuechiRule));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_BuechiRule));
    kc_x->post_create();
    return static_cast<impl_tBuechiRules_BuechiRule*>(kc_x);
}

impl_tBuechiRules_ExpandedBuechiRule*
ExpandedBuechiRule(integer _integer_1, tFormula _tFormula_1, integer _integer_2) {
    assertPhylum(_integer_1, phylum_integer);
    assertPhylum(_tFormula_1, phylum_tFormula);
    assertPhylum(_integer_2, phylum_integer);
    tBuechiRules kc_x = new impl_tBuechiRules_ExpandedBuechiRule(_integer_1, _tFormula_1, _integer_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExpandedBuechiRule));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExpandedBuechiRule));
    kc_x->post_create();
    return static_cast<impl_tBuechiRules_ExpandedBuechiRule*>(kc_x);
}

impl_tBuechiRules_BuechiRules*
BuechiRules(tBuechiRules _tBuechiRules_1, tBuechiRules _tBuechiRules_2) {
    assertPhylum(_tBuechiRules_1, phylum_tBuechiRules);
    assertPhylum(_tBuechiRules_2, phylum_tBuechiRules);
    tBuechiRules kc_x = new impl_tBuechiRules_BuechiRules(_tBuechiRules_1, _tBuechiRules_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_BuechiRules));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_BuechiRules));
    kc_x->post_create();
    return static_cast<impl_tBuechiRules_BuechiRules*>(kc_x);
}

impl_tTransitionRules_EmptyTransitionRules*
EmptyTransitionRules() {
    tTransitionRules kc_x = new impl_tTransitionRules_EmptyTransitionRules();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyTransitionRules));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyTransitionRules));
    kc_x->post_create();
    return static_cast<impl_tTransitionRules_EmptyTransitionRules*>(kc_x);
}

impl_tTransitionRules_TransitionRule*
TransitionRule(tFormula _tFormula_1, integer _integer_1) {
    assertPhylum(_tFormula_1, phylum_tFormula);
    assertPhylum(_integer_1, phylum_integer);
    tTransitionRules kc_x = new impl_tTransitionRules_TransitionRule(_tFormula_1, _integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TransitionRule));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TransitionRule));
    kc_x->post_create();
    return static_cast<impl_tTransitionRules_TransitionRule*>(kc_x);
}

impl_tTransitionRules_TransitionRules*
TransitionRules(tTransitionRules _tTransitionRules_1, tTransitionRules _tTransitionRules_2) {
    assertPhylum(_tTransitionRules_1, phylum_tTransitionRules);
    assertPhylum(_tTransitionRules_2, phylum_tTransitionRules);
    tTransitionRules kc_x = new impl_tTransitionRules_TransitionRules(_tTransitionRules_1, _tTransitionRules_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TransitionRules));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TransitionRules));
    kc_x->post_create();
    return static_cast<impl_tTransitionRules_TransitionRules*>(kc_x);
}

impl_tAcceptingSet_EmptyAcceptingSet*
EmptyAcceptingSet() {
    tAcceptingSet kc_x = new impl_tAcceptingSet_EmptyAcceptingSet();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyAcceptingSet));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyAcceptingSet));
    kc_x->post_create();
    return static_cast<impl_tAcceptingSet_EmptyAcceptingSet*>(kc_x);
}

impl_tAcceptingSet_AcceptingState*
AcceptingState(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    tAcceptingSet kc_x = new impl_tAcceptingSet_AcceptingState(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AcceptingState));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AcceptingState));
    kc_x->post_create();
    return static_cast<impl_tAcceptingSet_AcceptingState*>(kc_x);
}

impl_tAcceptingSet_AcceptingSet*
AcceptingSet(tAcceptingSet _tAcceptingSet_1, tAcceptingSet _tAcceptingSet_2) {
    assertPhylum(_tAcceptingSet_1, phylum_tAcceptingSet);
    assertPhylum(_tAcceptingSet_2, phylum_tAcceptingSet);
    tAcceptingSet kc_x = new impl_tAcceptingSet_AcceptingSet(_tAcceptingSet_1, _tAcceptingSet_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AcceptingSet));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AcceptingSet));
    kc_x->post_create();
    return static_cast<impl_tAcceptingSet_AcceptingSet*>(kc_x);
}

impl_net_Net*
Net(casestring _casestring_1, definitionsList _definitionsList_1, placeblocklist _placeblocklist_1, marking _marking_1, transition _transition_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_definitionsList_1, phylum_definitionsList);
    assertPhylum(_placeblocklist_1, phylum_placeblocklist);
    assertPhylum(_marking_1, phylum_marking);
    assertPhylum(_transition_1, phylum_transition);
    net kc_x = new impl_net_Net(_casestring_1, _definitionsList_1, _placeblocklist_1, _marking_1, _transition_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Net));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Net));
    kc_x->post_create();
    return static_cast<impl_net_Net*>(kc_x);
}

impl_definitionsList_EmptyDefinitionsList*
EmptyDefinitionsList() {
    definitionsList kc_x = new impl_definitionsList_EmptyDefinitionsList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyDefinitionsList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyDefinitionsList));
    kc_x->post_create();
    return static_cast<impl_definitionsList_EmptyDefinitionsList*>(kc_x);
}

impl_definitionsList_DefinitionsList*
DefinitionsList(definitionsList _definitionsList_1, definitions _definitions_1) {
    assertPhylum(_definitionsList_1, phylum_definitionsList);
    assertPhylum(_definitions_1, phylum_definitions);
    definitionsList kc_x = new impl_definitionsList_DefinitionsList(_definitionsList_1, _definitions_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DefinitionsList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DefinitionsList));
    kc_x->post_create();
    return static_cast<impl_definitionsList_DefinitionsList*>(kc_x);
}

impl_definitions_Constant*
Constant(type _type_1, casestring _casestring_1, arrayList _arrayList_1, expression _expression_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_arrayList_1, phylum_arrayList);
    assertPhylum(_expression_1, phylum_expression);
    definitions kc_x = new impl_definitions_Constant(_type_1, _casestring_1, _arrayList_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Constant));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Constant));
    kc_x->post_create();
    return static_cast<impl_definitions_Constant*>(kc_x);
}

impl_definitions_Sort*
Sort(type _type_1, casestring _casestring_1, arrayList _arrayList_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_arrayList_1, phylum_arrayList);
    definitions kc_x = new impl_definitions_Sort(_type_1, _casestring_1, _arrayList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Sort));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Sort));
    kc_x->post_create();
    return static_cast<impl_definitions_Sort*>(kc_x);
}

impl_definitions_Function*
Function(type _type_1, casestring _casestring_1, arrayList _arrayList_1, functionParametersList _functionParametersList_1, block _block_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_arrayList_1, phylum_arrayList);
    assertPhylum(_functionParametersList_1, phylum_functionParametersList);
    assertPhylum(_block_1, phylum_block);
    definitions kc_x = new impl_definitions_Function(_type_1, _casestring_1, _arrayList_1, _functionParametersList_1, _block_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Function));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Function));
    kc_x->post_create();
    return static_cast<impl_definitions_Function*>(kc_x);
}

impl_type_TypeBool*
TypeBool() {
    type kc_x = new impl_type_TypeBool();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeBool));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeBool));
    kc_x->post_create();
    kc_x = kc_initialize_type(kc_x);
    return static_cast<impl_type_TypeBool*>(kc_x);
}

impl_type_TypeEnum*
TypeEnum(identList _identList_1) {
    assertPhylum(_identList_1, phylum_identList);
    type kc_x = new impl_type_TypeEnum(_identList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeEnum));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeEnum));
    kc_x->post_create();
    kc_x = kc_initialize_type(kc_x);
    return static_cast<impl_type_TypeEnum*>(kc_x);
}

impl_type_TypeIdent*
TypeIdent(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    type kc_x = new impl_type_TypeIdent(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeIdent));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeIdent));
    kc_x->post_create();
    kc_x = kc_initialize_type(kc_x);
    return static_cast<impl_type_TypeIdent*>(kc_x);
}

impl_type_TypeIntInterval*
TypeIntInterval(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    type kc_x = new impl_type_TypeIntInterval(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeIntInterval));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeIntInterval));
    kc_x->post_create();
    kc_x = kc_initialize_type(kc_x);
    return static_cast<impl_type_TypeIntInterval*>(kc_x);
}

impl_type_TypeStruct*
TypeStruct(structTypeList _structTypeList_1) {
    assertPhylum(_structTypeList_1, phylum_structTypeList);
    type kc_x = new impl_type_TypeStruct(_structTypeList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeStruct));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeStruct));
    kc_x->post_create();
    kc_x = kc_initialize_type(kc_x);
    return static_cast<impl_type_TypeStruct*>(kc_x);
}

impl_type_TypeInt*
TypeInt() {
    type kc_x = new impl_type_TypeInt();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeInt));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeInt));
    kc_x->post_create();
    kc_x = kc_initialize_type(kc_x);
    return static_cast<impl_type_TypeInt*>(kc_x);
}

impl_type_TypeMultiset*
TypeMultiset(type _type_1) {
    assertPhylum(_type_1, phylum_type);
    type kc_x = new impl_type_TypeMultiset(_type_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeMultiset));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeMultiset));
    kc_x->post_create();
    kc_x = kc_initialize_type(kc_x);
    return static_cast<impl_type_TypeMultiset*>(kc_x);
}

impl_type_TypeArray*
TypeArray(type _type_1, integer _integer_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_integer_1, phylum_integer);
    type kc_x = new impl_type_TypeArray(_type_1, _integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeArray));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeArray));
    kc_x->post_create();
    kc_x = kc_initialize_type(kc_x);
    return static_cast<impl_type_TypeArray*>(kc_x);
}

impl_type_TypeBlack*
TypeBlack() {
    type kc_x = new impl_type_TypeBlack();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeBlack));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeBlack));
    kc_x->post_create();
    kc_x = kc_initialize_type(kc_x);
    return static_cast<impl_type_TypeBlack*>(kc_x);
}

impl_optionalNumber_EmptyOptNumber*
EmptyOptNumber() {
    optionalNumber kc_x = new impl_optionalNumber_EmptyOptNumber();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyOptNumber));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyOptNumber));
    kc_x->post_create();
    return static_cast<impl_optionalNumber_EmptyOptNumber*>(kc_x);
}

impl_optionalNumber_OptNumber*
OptNumber(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    optionalNumber kc_x = new impl_optionalNumber_OptNumber(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_OptNumber));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_OptNumber));
    kc_x->post_create();
    return static_cast<impl_optionalNumber_OptNumber*>(kc_x);
}

impl_identList_EmptyIdentList*
EmptyIdentList() {
    identList kc_x = new impl_identList_EmptyIdentList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyIdentList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyIdentList));
    kc_x->post_create();
    return static_cast<impl_identList_EmptyIdentList*>(kc_x);
}

impl_identList_IdentList*
IdentList(identList _identList_1, idents _idents_1) {
    assertPhylum(_identList_1, phylum_identList);
    assertPhylum(_idents_1, phylum_idents);
    identList kc_x = new impl_identList_IdentList(_identList_1, _idents_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_IdentList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_IdentList));
    kc_x->post_create();
    return static_cast<impl_identList_IdentList*>(kc_x);
}

impl_idents_Idents*
Idents(casestring _casestring_1, optionalNumber _optionalNumber_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_optionalNumber_1, phylum_optionalNumber);
    idents kc_x = new impl_idents_Idents(_casestring_1, _optionalNumber_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Idents));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Idents));
    kc_x->post_create();
    return static_cast<impl_idents_Idents*>(kc_x);
}

impl_structTypeList_EmptyStructTypeList*
EmptyStructTypeList() {
    structTypeList kc_x = new impl_structTypeList_EmptyStructTypeList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyStructTypeList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyStructTypeList));
    kc_x->post_create();
    return static_cast<impl_structTypeList_EmptyStructTypeList*>(kc_x);
}

impl_structTypeList_StructTypeList*
StructTypeList(structTypeList _structTypeList_1, structType _structType_1) {
    assertPhylum(_structTypeList_1, phylum_structTypeList);
    assertPhylum(_structType_1, phylum_structType);
    structTypeList kc_x = new impl_structTypeList_StructTypeList(_structTypeList_1, _structType_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StructTypeList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StructTypeList));
    kc_x->post_create();
    return static_cast<impl_structTypeList_StructTypeList*>(kc_x);
}

impl_structType_StructType*
StructType(type _type_1, casestring _casestring_1, arrayList _arrayList_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_arrayList_1, phylum_arrayList);
    structType kc_x = new impl_structType_StructType(_type_1, _casestring_1, _arrayList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StructType));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StructType));
    kc_x->post_create();
    return static_cast<impl_structType_StructType*>(kc_x);
}

impl_varOrArray_VarOrArray*
VarOrArray(casestring _casestring_1, arrayList _arrayList_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_arrayList_1, phylum_arrayList);
    varOrArray kc_x = new impl_varOrArray_VarOrArray(_casestring_1, _arrayList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_VarOrArray));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_VarOrArray));
    kc_x->post_create();
    return static_cast<impl_varOrArray_VarOrArray*>(kc_x);
}

impl_arrayList_EmptyArrayList*
EmptyArrayList() {
    arrayList kc_x = new impl_arrayList_EmptyArrayList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyArrayList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyArrayList));
    kc_x->post_create();
    return static_cast<impl_arrayList_EmptyArrayList*>(kc_x);
}

impl_arrayList_ArrayList*
ArrayList(arrayList _arrayList_1, expression _expression_1) {
    assertPhylum(_arrayList_1, phylum_arrayList);
    assertPhylum(_expression_1, phylum_expression);
    arrayList kc_x = new impl_arrayList_ArrayList(_arrayList_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ArrayList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ArrayList));
    kc_x->post_create();
    return static_cast<impl_arrayList_ArrayList*>(kc_x);
}

impl_functionParametersList_EmptyFunctionParametersList*
EmptyFunctionParametersList() {
    functionParametersList kc_x = new impl_functionParametersList_EmptyFunctionParametersList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyFunctionParametersList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyFunctionParametersList));
    kc_x->post_create();
    return static_cast<impl_functionParametersList_EmptyFunctionParametersList*>(kc_x);
}

impl_functionParametersList_FunctionParametersList*
FunctionParametersList(functionParameters _functionParameters_1, functionParametersList _functionParametersList_1) {
    assertPhylum(_functionParameters_1, phylum_functionParameters);
    assertPhylum(_functionParametersList_1, phylum_functionParametersList);
    functionParametersList kc_x = new impl_functionParametersList_FunctionParametersList(_functionParameters_1, _functionParametersList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_FunctionParametersList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_FunctionParametersList));
    kc_x->post_create();
    return static_cast<impl_functionParametersList_FunctionParametersList*>(kc_x);
}

impl_functionParameters_FunctionParameters*
FunctionParameters(type _type_1, varOrArray _varOrArray_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_varOrArray_1, phylum_varOrArray);
    functionParameters kc_x = new impl_functionParameters_FunctionParameters(_type_1, _varOrArray_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_FunctionParameters));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_FunctionParameters));
    kc_x->post_create();
    return static_cast<impl_functionParameters_FunctionParameters*>(kc_x);
}

impl_expression_ExprLeftvalue*
ExprLeftvalue(leftvalue _leftvalue_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    expression kc_x = new impl_expression_ExprLeftvalue(_leftvalue_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprLeftvalue));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprLeftvalue));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprLeftvalue*>(kc_x);
}

impl_expression_ExprInitializerList*
ExprInitializerList(initializerList _initializerList_1) {
    assertPhylum(_initializerList_1, phylum_initializerList);
    expression kc_x = new impl_expression_ExprInitializerList(_initializerList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprInitializerList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprInitializerList));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprInitializerList*>(kc_x);
}

impl_expression_AssignEqual*
AssignEqual(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    expression kc_x = new impl_expression_AssignEqual(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignEqual));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignEqual));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_AssignEqual*>(kc_x);
}

impl_expression_AssignPlus*
AssignPlus(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    expression kc_x = new impl_expression_AssignPlus(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignPlus));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignPlus));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_AssignPlus*>(kc_x);
}

impl_expression_AssignMinus*
AssignMinus(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    expression kc_x = new impl_expression_AssignMinus(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignMinus));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignMinus));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_AssignMinus*>(kc_x);
}

impl_expression_AssignTimes*
AssignTimes(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    expression kc_x = new impl_expression_AssignTimes(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignTimes));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignTimes));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_AssignTimes*>(kc_x);
}

impl_expression_AssignDivide*
AssignDivide(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    expression kc_x = new impl_expression_AssignDivide(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignDivide));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignDivide));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_AssignDivide*>(kc_x);
}

impl_expression_AssignMod*
AssignMod(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    expression kc_x = new impl_expression_AssignMod(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignMod));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignMod));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_AssignMod*>(kc_x);
}

impl_expression_IncrementVal*
IncrementVal(leftvalue _leftvalue_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    expression kc_x = new impl_expression_IncrementVal(_leftvalue_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_IncrementVal));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_IncrementVal));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_IncrementVal*>(kc_x);
}

impl_expression_DecrementVal*
DecrementVal(leftvalue _leftvalue_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    expression kc_x = new impl_expression_DecrementVal(_leftvalue_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DecrementVal));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DecrementVal));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_DecrementVal*>(kc_x);
}

impl_expression_ValIncrement*
ValIncrement(leftvalue _leftvalue_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    expression kc_x = new impl_expression_ValIncrement(_leftvalue_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ValIncrement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ValIncrement));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ValIncrement*>(kc_x);
}

impl_expression_ValDecrement*
ValDecrement(leftvalue _leftvalue_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    expression kc_x = new impl_expression_ValDecrement(_leftvalue_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ValDecrement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ValDecrement));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ValDecrement*>(kc_x);
}

impl_expression_PositiveExpr*
PositiveExpr(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    expression kc_x = new impl_expression_PositiveExpr(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PositiveExpr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PositiveExpr));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_PositiveExpr*>(kc_x);
}

impl_expression_NegativeExpr*
NegativeExpr(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    expression kc_x = new impl_expression_NegativeExpr(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NegativeExpr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NegativeExpr));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_NegativeExpr*>(kc_x);
}

impl_expression_ExprAddition*
ExprAddition(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprAddition(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprAddition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprAddition));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprAddition*>(kc_x);
}

impl_expression_ExprSubtraction*
ExprSubtraction(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprSubtraction(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprSubtraction));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprSubtraction));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprSubtraction*>(kc_x);
}

impl_expression_ExprMultiplication*
ExprMultiplication(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprMultiplication(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprMultiplication));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprMultiplication));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprMultiplication*>(kc_x);
}

impl_expression_ExprDivision*
ExprDivision(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprDivision(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprDivision));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprDivision));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprDivision*>(kc_x);
}

impl_expression_ExprModulo*
ExprModulo(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprModulo(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprModulo));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprModulo));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprModulo*>(kc_x);
}

impl_expression_ExprNumber*
ExprNumber(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    expression kc_x = new impl_expression_ExprNumber(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprNumber));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprNumber));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprNumber*>(kc_x);
}

impl_expression_NotExpr*
NotExpr(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    expression kc_x = new impl_expression_NotExpr(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NotExpr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NotExpr));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_NotExpr*>(kc_x);
}

impl_expression_ExprAnd*
ExprAnd(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprAnd(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprAnd));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprAnd));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprAnd*>(kc_x);
}

impl_expression_ExprOr*
ExprOr(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprOr(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprOr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprOr));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprOr*>(kc_x);
}

impl_expression_ExprTrue*
ExprTrue() {
    expression kc_x = new impl_expression_ExprTrue();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprTrue));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprTrue));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprTrue*>(kc_x);
}

impl_expression_ExprFalse*
ExprFalse() {
    expression kc_x = new impl_expression_ExprFalse();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprFalse));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprFalse));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprFalse*>(kc_x);
}

impl_expression_ExprEquivalent*
ExprEquivalent(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprEquivalent(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprEquivalent));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprEquivalent));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprEquivalent*>(kc_x);
}

impl_expression_ExprNotEqual*
ExprNotEqual(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprNotEqual(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprNotEqual));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprNotEqual));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprNotEqual*>(kc_x);
}

impl_expression_ExprLessThan*
ExprLessThan(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprLessThan(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprLessThan));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprLessThan));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprLessThan*>(kc_x);
}

impl_expression_ExprGreaterThan*
ExprGreaterThan(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprGreaterThan(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprGreaterThan));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprGreaterThan));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprGreaterThan*>(kc_x);
}

impl_expression_ExprLessOrEqual*
ExprLessOrEqual(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprLessOrEqual(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprLessOrEqual));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprLessOrEqual));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprLessOrEqual*>(kc_x);
}

impl_expression_ExprGreaterOrEqual*
ExprGreaterOrEqual(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_ExprGreaterOrEqual(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprGreaterOrEqual));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprGreaterOrEqual));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprGreaterOrEqual*>(kc_x);
}

impl_expression_FunctionCall*
FunctionCall(casestring _casestring_1, expressionlist _expressionlist_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expressionlist_1, phylum_expressionlist);
    expression kc_x = new impl_expression_FunctionCall(_casestring_1, _expressionlist_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_FunctionCall));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_FunctionCall));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_FunctionCall*>(kc_x);
}

impl_expression_ExprCommaSeparated*
ExprCommaSeparated(expressionlist _expressionlist_1) {
    assertPhylum(_expressionlist_1, phylum_expressionlist);
    expression kc_x = new impl_expression_ExprCommaSeparated(_expressionlist_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprCommaSeparated));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprCommaSeparated));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprCommaSeparated*>(kc_x);
}

impl_expression_ExprOtherIf*
ExprOtherIf(expression _expression_1, expression _expression_2, expression _expression_3) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    assertPhylum(_expression_3, phylum_expression);
    expression kc_x = new impl_expression_ExprOtherIf(_expression_1, _expression_2, _expression_3);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprOtherIf));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprOtherIf));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprOtherIf*>(kc_x);
}

impl_expression_ExprAll*
ExprAll(type _type_1) {
    assertPhylum(_type_1, phylum_type);
    expression kc_x = new impl_expression_ExprAll(_type_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprAll));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprAll));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprAll*>(kc_x);
}

impl_leftvalue_LeftValIdent*
LeftValIdent(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    leftvalue kc_x = new impl_leftvalue_LeftValIdent(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_LeftValIdent));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_LeftValIdent));
    kc_x->post_create();
    return static_cast<impl_leftvalue_LeftValIdent*>(kc_x);
}

impl_leftvalue_LeftValBrackets*
LeftValBrackets(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    leftvalue kc_x = new impl_leftvalue_LeftValBrackets(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_LeftValBrackets));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_LeftValBrackets));
    kc_x->post_create();
    return static_cast<impl_leftvalue_LeftValBrackets*>(kc_x);
}

impl_leftvalue_LeftValDot*
LeftValDot(leftvalue _leftvalue_1, casestring _casestring_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_casestring_1, phylum_casestring);
    leftvalue kc_x = new impl_leftvalue_LeftValDot(_leftvalue_1, _casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_LeftValDot));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_LeftValDot));
    kc_x->post_create();
    return static_cast<impl_leftvalue_LeftValDot*>(kc_x);
}

impl_expressionlist_EmptyExpressionList*
EmptyExpressionList() {
    expressionlist kc_x = new impl_expressionlist_EmptyExpressionList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyExpressionList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyExpressionList));
    kc_x->post_create();
    return static_cast<impl_expressionlist_EmptyExpressionList*>(kc_x);
}

impl_expressionlist_ExpressionList*
ExpressionList(expression _expression_1, expressionlist _expressionlist_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expressionlist_1, phylum_expressionlist);
    expressionlist kc_x = new impl_expressionlist_ExpressionList(_expression_1, _expressionlist_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExpressionList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExpressionList));
    kc_x->post_create();
    return static_cast<impl_expressionlist_ExpressionList*>(kc_x);
}

impl_initializerList_ExprInBraces*
ExprInBraces(expressionlist _expressionlist_1) {
    assertPhylum(_expressionlist_1, phylum_expressionlist);
    initializerList kc_x = new impl_initializerList_ExprInBraces(_expressionlist_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprInBraces));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprInBraces));
    kc_x->post_create();
    return static_cast<impl_initializerList_ExprInBraces*>(kc_x);
}

impl_initializerList_ExprInBracesColon*
ExprInBracesColon(expression _expression_1, expression _expression_2, expressionListColon _expressionListColon_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    assertPhylum(_expressionListColon_1, phylum_expressionListColon);
    initializerList kc_x = new impl_initializerList_ExprInBracesColon(_expression_1, _expression_2, _expressionListColon_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprInBracesColon));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprInBracesColon));
    kc_x->post_create();
    return static_cast<impl_initializerList_ExprInBracesColon*>(kc_x);
}

impl_expressionListColon_EmptyExpressionListColon*
EmptyExpressionListColon() {
    expressionListColon kc_x = new impl_expressionListColon_EmptyExpressionListColon();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyExpressionListColon));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyExpressionListColon));
    kc_x->post_create();
    return static_cast<impl_expressionListColon_EmptyExpressionListColon*>(kc_x);
}

impl_expressionListColon_ExpressionListColon*
ExpressionListColon(expression _expression_1, expression _expression_2, expressionListColon _expressionListColon_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    assertPhylum(_expressionListColon_1, phylum_expressionListColon);
    expressionListColon kc_x = new impl_expressionListColon_ExpressionListColon(_expression_1, _expression_2, _expressionListColon_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExpressionListColon));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExpressionListColon));
    kc_x->post_create();
    return static_cast<impl_expressionListColon_ExpressionListColon*>(kc_x);
}

impl_placeblocklist_EmptyPlaceBlockList*
EmptyPlaceBlockList() {
    placeblocklist kc_x = new impl_placeblocklist_EmptyPlaceBlockList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyPlaceBlockList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyPlaceBlockList));
    kc_x->post_create();
    return static_cast<impl_placeblocklist_EmptyPlaceBlockList*>(kc_x);
}

impl_placeblocklist_PlaceBlockList*
PlaceBlockList(placeblock _placeblock_1, placeblocklist _placeblocklist_1) {
    assertPhylum(_placeblock_1, phylum_placeblock);
    assertPhylum(_placeblocklist_1, phylum_placeblocklist);
    placeblocklist kc_x = new impl_placeblocklist_PlaceBlockList(_placeblock_1, _placeblocklist_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PlaceBlockList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PlaceBlockList));
    kc_x->post_create();
    return static_cast<impl_placeblocklist_PlaceBlockList*>(kc_x);
}

impl_optSafe_EmptySafe*
EmptySafe() {
    optSafe kc_x = new impl_optSafe_EmptySafe();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptySafe));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptySafe));
    kc_x->post_create();
    return static_cast<impl_optSafe_EmptySafe*>(kc_x);
}

impl_optSafe_Safe*
Safe(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    optSafe kc_x = new impl_optSafe_Safe(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Safe));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Safe));
    kc_x->post_create();
    return static_cast<impl_optSafe_Safe*>(kc_x);
}

impl_place_Place*
Place(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    place kc_x = new impl_place_Place(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Place));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Place));
    kc_x->post_create();
    return static_cast<impl_place_Place*>(kc_x);
}

impl_placelist_EmptyPlaceList*
EmptyPlaceList() {
    placelist kc_x = new impl_placelist_EmptyPlaceList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyPlaceList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyPlaceList));
    kc_x->post_create();
    return static_cast<impl_placelist_EmptyPlaceList*>(kc_x);
}

impl_placelist_PlaceList*
PlaceList(place _place_1, placelist _placelist_1) {
    assertPhylum(_place_1, phylum_place);
    assertPhylum(_placelist_1, phylum_placelist);
    placelist kc_x = new impl_placelist_PlaceList(_place_1, _placelist_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PlaceList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PlaceList));
    kc_x->post_create();
    return static_cast<impl_placelist_PlaceList*>(kc_x);
}

impl_placeblock_PlaceBlock*
PlaceBlock(optSafe _optSafe_1, type _type_1, placelist _placelist_1) {
    assertPhylum(_optSafe_1, phylum_optSafe);
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_placelist_1, phylum_placelist);
    placeblock kc_x = new impl_placeblock_PlaceBlock(_optSafe_1, _type_1, _placelist_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PlaceBlock));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PlaceBlock));
    kc_x->post_create();
    return static_cast<impl_placeblock_PlaceBlock*>(kc_x);
}

impl_marking_EmptyMarking*
EmptyMarking() {
    marking kc_x = new impl_marking_EmptyMarking();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyMarking));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyMarking));
    kc_x->post_create();
    return static_cast<impl_marking_EmptyMarking*>(kc_x);
}

impl_marking_Marking*
Marking(casestring _casestring_1, expression _expression_1, marking _marking_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_marking_1, phylum_marking);
    marking kc_x = new impl_marking_Marking(_casestring_1, _expression_1, _marking_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Marking));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Marking));
    kc_x->post_create();
    return static_cast<impl_marking_Marking*>(kc_x);
}

impl_transition_EmptyTransition*
EmptyTransition() {
    transition kc_x = new impl_transition_EmptyTransition();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyTransition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyTransition));
    kc_x->post_create();
    return static_cast<impl_transition_EmptyTransition*>(kc_x);
}

impl_transition_Transition*
Transition(casestring _casestring_1, fairness _fairness_1, variable _variable_1, guard _guard_1, identExprList _identExprList_1, identExprList _identExprList_2, transition _transition_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_fairness_1, phylum_fairness);
    assertPhylum(_variable_1, phylum_variable);
    assertPhylum(_guard_1, phylum_guard);
    assertPhylum(_identExprList_1, phylum_identExprList);
    assertPhylum(_identExprList_2, phylum_identExprList);
    assertPhylum(_transition_1, phylum_transition);
    transition kc_x = new impl_transition_Transition(_casestring_1, _fairness_1, _variable_1, _guard_1, _identExprList_1, _identExprList_2, _transition_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Transition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Transition));
    kc_x->post_create();
    return static_cast<impl_transition_Transition*>(kc_x);
}

impl_fairness_EmptyFairness*
EmptyFairness() {
    fairness kc_x = new impl_fairness_EmptyFairness();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyFairness));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyFairness));
    kc_x->post_create();
    return static_cast<impl_fairness_EmptyFairness*>(kc_x);
}

impl_fairness_WeakFair*
WeakFair() {
    fairness kc_x = new impl_fairness_WeakFair();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_WeakFair));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_WeakFair));
    kc_x->post_create();
    return static_cast<impl_fairness_WeakFair*>(kc_x);
}

impl_fairness_StrongFair*
StrongFair() {
    fairness kc_x = new impl_fairness_StrongFair();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StrongFair));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StrongFair));
    kc_x->post_create();
    return static_cast<impl_fairness_StrongFair*>(kc_x);
}

impl_variable_EmptyVariable*
EmptyVariable() {
    variable kc_x = new impl_variable_EmptyVariable();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyVariable));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyVariable));
    kc_x->post_create();
    return static_cast<impl_variable_EmptyVariable*>(kc_x);
}

impl_variable_Variable*
Variable(type _type_1, varOrArrayList _varOrArrayList_1, variable _variable_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_varOrArrayList_1, phylum_varOrArrayList);
    assertPhylum(_variable_1, phylum_variable);
    variable kc_x = new impl_variable_Variable(_type_1, _varOrArrayList_1, _variable_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Variable));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Variable));
    kc_x->post_create();
    return static_cast<impl_variable_Variable*>(kc_x);
}

impl_varOrArrayList_EmptyVarOrArrayList*
EmptyVarOrArrayList() {
    varOrArrayList kc_x = new impl_varOrArrayList_EmptyVarOrArrayList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyVarOrArrayList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyVarOrArrayList));
    kc_x->post_create();
    return static_cast<impl_varOrArrayList_EmptyVarOrArrayList*>(kc_x);
}

impl_varOrArrayList_VarOrArrayList*
VarOrArrayList(varOrArray _varOrArray_1, varOrArrayList _varOrArrayList_1) {
    assertPhylum(_varOrArray_1, phylum_varOrArray);
    assertPhylum(_varOrArrayList_1, phylum_varOrArrayList);
    varOrArrayList kc_x = new impl_varOrArrayList_VarOrArrayList(_varOrArray_1, _varOrArrayList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_VarOrArrayList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_VarOrArrayList));
    kc_x->post_create();
    return static_cast<impl_varOrArrayList_VarOrArrayList*>(kc_x);
}

impl_guard_Guard*
Guard(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    guard kc_x = new impl_guard_Guard(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Guard));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Guard));
    kc_x->post_create();
    return static_cast<impl_guard_Guard*>(kc_x);
}

impl_identExprList_EmptyIdentExprList*
EmptyIdentExprList() {
    identExprList kc_x = new impl_identExprList_EmptyIdentExprList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyIdentExprList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyIdentExprList));
    kc_x->post_create();
    return static_cast<impl_identExprList_EmptyIdentExprList*>(kc_x);
}

impl_identExprList_IdentExprList*
IdentExprList(casestring _casestring_1, expression _expression_1, identExprList _identExprList_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_identExprList_1, phylum_identExprList);
    identExprList kc_x = new impl_identExprList_IdentExprList(_casestring_1, _expression_1, _identExprList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_IdentExprList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_IdentExprList));
    kc_x->post_create();
    return static_cast<impl_identExprList_IdentExprList*>(kc_x);
}

impl_block_Block*
Block(declarationOrStatement _declarationOrStatement_1) {
    assertPhylum(_declarationOrStatement_1, phylum_declarationOrStatement);
    block kc_x = new impl_block_Block(_declarationOrStatement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Block));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Block));
    kc_x->post_create();
    return static_cast<impl_block_Block*>(kc_x);
}

impl_declarationOrStatement_EmptyDeclarationOrStatement*
EmptyDeclarationOrStatement() {
    declarationOrStatement kc_x = new impl_declarationOrStatement_EmptyDeclarationOrStatement();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyDeclarationOrStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyDeclarationOrStatement));
    kc_x->post_create();
    return static_cast<impl_declarationOrStatement_EmptyDeclarationOrStatement*>(kc_x);
}

impl_declarationOrStatement_DeclOrStatemDeclaration*
DeclOrStatemDeclaration(declaration _declaration_1, declarationOrStatement _declarationOrStatement_1) {
    assertPhylum(_declaration_1, phylum_declaration);
    assertPhylum(_declarationOrStatement_1, phylum_declarationOrStatement);
    declarationOrStatement kc_x = new impl_declarationOrStatement_DeclOrStatemDeclaration(_declaration_1, _declarationOrStatement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DeclOrStatemDeclaration));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DeclOrStatemDeclaration));
    kc_x->post_create();
    return static_cast<impl_declarationOrStatement_DeclOrStatemDeclaration*>(kc_x);
}

impl_declarationOrStatement_DeclOrStatemStatement*
DeclOrStatemStatement(statement _statement_1, declarationOrStatement _declarationOrStatement_1) {
    assertPhylum(_statement_1, phylum_statement);
    assertPhylum(_declarationOrStatement_1, phylum_declarationOrStatement);
    declarationOrStatement kc_x = new impl_declarationOrStatement_DeclOrStatemStatement(_statement_1, _declarationOrStatement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DeclOrStatemStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DeclOrStatemStatement));
    kc_x->post_create();
    return static_cast<impl_declarationOrStatement_DeclOrStatemStatement*>(kc_x);
}

impl_declaration_Declaration*
Declaration(type _type_1, varOrArrayList _varOrArrayList_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_varOrArrayList_1, phylum_varOrArrayList);
    declaration kc_x = new impl_declaration_Declaration(_type_1, _varOrArrayList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Declaration));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Declaration));
    kc_x->post_create();
    return static_cast<impl_declaration_Declaration*>(kc_x);
}

impl_statement_StatementBlock*
StatementBlock(block _block_1) {
    assertPhylum(_block_1, phylum_block);
    statement kc_x = new impl_statement_StatementBlock(_block_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementBlock));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementBlock));
    kc_x->post_create();
    return static_cast<impl_statement_StatementBlock*>(kc_x);
}

impl_statement_StatementExprSemicolon*
StatementExprSemicolon(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    statement kc_x = new impl_statement_StatementExprSemicolon(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementExprSemicolon));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementExprSemicolon));
    kc_x->post_create();
    return static_cast<impl_statement_StatementExprSemicolon*>(kc_x);
}

impl_statement_StatementIf*
StatementIf(expression _expression_1, statement _statement_1, statement _statement_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    assertPhylum(_statement_2, phylum_statement);
    statement kc_x = new impl_statement_StatementIf(_expression_1, _statement_1, _statement_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementIf));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementIf));
    kc_x->post_create();
    return static_cast<impl_statement_StatementIf*>(kc_x);
}

impl_statement_StatementWhile*
StatementWhile(expression _expression_1, statement _statement_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    statement kc_x = new impl_statement_StatementWhile(_expression_1, _statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementWhile));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementWhile));
    kc_x->post_create();
    return static_cast<impl_statement_StatementWhile*>(kc_x);
}

impl_statement_StatementDoWhile*
StatementDoWhile(statement _statement_1, expression _expression_1) {
    assertPhylum(_statement_1, phylum_statement);
    assertPhylum(_expression_1, phylum_expression);
    statement kc_x = new impl_statement_StatementDoWhile(_statement_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementDoWhile));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementDoWhile));
    kc_x->post_create();
    return static_cast<impl_statement_StatementDoWhile*>(kc_x);
}

impl_statement_StatementForExpr*
StatementForExpr(expression _expression_1, expression _expression_2, expression _expression_3, statement _statement_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    assertPhylum(_expression_3, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    statement kc_x = new impl_statement_StatementForExpr(_expression_1, _expression_2, _expression_3, _statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementForExpr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementForExpr));
    kc_x->post_create();
    return static_cast<impl_statement_StatementForExpr*>(kc_x);
}

impl_statement_StatementForTypeExpr*
StatementForTypeExpr(type _type_1, casestring _casestring_1, expression _expression_1, expression _expression_2, expression _expression_3, statement _statement_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    assertPhylum(_expression_3, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    statement kc_x = new impl_statement_StatementForTypeExpr(_type_1, _casestring_1, _expression_1, _expression_2, _expression_3, _statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementForTypeExpr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementForTypeExpr));
    kc_x->post_create();
    return static_cast<impl_statement_StatementForTypeExpr*>(kc_x);
}

impl_statement_StatementForIdentColon*
StatementForIdentColon(casestring _casestring_1, expression _expression_1, statement _statement_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    statement kc_x = new impl_statement_StatementForIdentColon(_casestring_1, _expression_1, _statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementForIdentColon));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementForIdentColon));
    kc_x->post_create();
    return static_cast<impl_statement_StatementForIdentColon*>(kc_x);
}

impl_statement_StatementForAll*
StatementForAll(type _type_1, casestring _casestring_1, type _type_2) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_type_2, phylum_type);
    statement kc_x = new impl_statement_StatementForAll(_type_1, _casestring_1, _type_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementForAll));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementForAll));
    kc_x->post_create();
    return static_cast<impl_statement_StatementForAll*>(kc_x);
}

impl_statement_StatementSwitch*
StatementSwitch(expression _expression_1, switchCaseList _switchCaseList_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_switchCaseList_1, phylum_switchCaseList);
    statement kc_x = new impl_statement_StatementSwitch(_expression_1, _switchCaseList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementSwitch));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementSwitch));
    kc_x->post_create();
    return static_cast<impl_statement_StatementSwitch*>(kc_x);
}

impl_statement_StatementBreak*
StatementBreak() {
    statement kc_x = new impl_statement_StatementBreak();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementBreak));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementBreak));
    kc_x->post_create();
    return static_cast<impl_statement_StatementBreak*>(kc_x);
}

impl_statement_StatementContinue*
StatementContinue() {
    statement kc_x = new impl_statement_StatementContinue();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementContinue));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementContinue));
    kc_x->post_create();
    return static_cast<impl_statement_StatementContinue*>(kc_x);
}

impl_statement_StatementReturn*
StatementReturn(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    statement kc_x = new impl_statement_StatementReturn(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementReturn));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementReturn));
    kc_x->post_create();
    return static_cast<impl_statement_StatementReturn*>(kc_x);
}

impl_statement_StatementSkip*
StatementSkip() {
    statement kc_x = new impl_statement_StatementSkip();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementSkip));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementSkip));
    kc_x->post_create();
    return static_cast<impl_statement_StatementSkip*>(kc_x);
}

impl_switchCase_SwitchCase*
SwitchCase(expression _expression_1, statement _statement_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    switchCase kc_x = new impl_switchCase_SwitchCase(_expression_1, _statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_SwitchCase));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_SwitchCase));
    kc_x->post_create();
    return static_cast<impl_switchCase_SwitchCase*>(kc_x);
}

impl_switchCase_SwitchDefault*
SwitchDefault(statement _statement_1) {
    assertPhylum(_statement_1, phylum_statement);
    switchCase kc_x = new impl_switchCase_SwitchDefault(_statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_SwitchDefault));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_SwitchDefault));
    kc_x->post_create();
    return static_cast<impl_switchCase_SwitchDefault*>(kc_x);
}

impl_switchCaseList_EmptySwitchCaseList*
EmptySwitchCaseList() {
    switchCaseList kc_x = new impl_switchCaseList_EmptySwitchCaseList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptySwitchCaseList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptySwitchCaseList));
    kc_x->post_create();
    return static_cast<impl_switchCaseList_EmptySwitchCaseList*>(kc_x);
}

impl_switchCaseList_SwitchCaseList*
SwitchCaseList(switchCase _switchCase_1, switchCaseList _switchCaseList_1) {
    assertPhylum(_switchCase_1, phylum_switchCase);
    assertPhylum(_switchCaseList_1, phylum_switchCaseList);
    switchCaseList kc_x = new impl_switchCaseList_SwitchCaseList(_switchCase_1, _switchCaseList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_SwitchCaseList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_SwitchCaseList));
    kc_x->post_create();
    return static_cast<impl_switchCaseList_SwitchCaseList*>(kc_x);
}


abstract_phylum
kc_create(enum_operators createOp, abstract_phylum kc_p1, abstract_phylum kc_p2, abstract_phylum kc_p3, abstract_phylum kc_p4, abstract_phylum kc_p5, abstract_phylum kc_p6, abstract_phylum kc_p7)
{
    switch(createOp) {
    case sel__VoidPtr:
    case sel__Int:
    case sel__Real:
    case sel__Str:
    case sel_NoCaseStr:
	assertionFailed("Cannot create this kind of phylum - predefined phyla must be handled seperately");break;
    case sel_SwitchCaseList:
	return SwitchCaseList(phylum_cast<switchCase>(kc_p1), phylum_cast<switchCaseList>(kc_p2));
    case sel_EmptySwitchCaseList:
	return EmptySwitchCaseList();
    case sel_SwitchDefault:
	return SwitchDefault(phylum_cast<statement>(kc_p1));
    case sel_SwitchCase:
	return SwitchCase(phylum_cast<expression>(kc_p1), phylum_cast<statement>(kc_p2));
    case sel_StatementSkip:
	return StatementSkip();
    case sel_StatementReturn:
	return StatementReturn(phylum_cast<expression>(kc_p1));
    case sel_StatementContinue:
	return StatementContinue();
    case sel_StatementBreak:
	return StatementBreak();
    case sel_StatementSwitch:
	return StatementSwitch(phylum_cast<expression>(kc_p1), phylum_cast<switchCaseList>(kc_p2));
    case sel_StatementForAll:
	return StatementForAll(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<type>(kc_p3));
    case sel_StatementForIdentColon:
	return StatementForIdentColon(phylum_cast<casestring>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<statement>(kc_p3));
    case sel_StatementForTypeExpr:
	return StatementForTypeExpr(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<expression>(kc_p3), phylum_cast<expression>(kc_p4), phylum_cast<expression>(kc_p5), phylum_cast<statement>(kc_p6));
    case sel_StatementForExpr:
	return StatementForExpr(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<expression>(kc_p3), phylum_cast<statement>(kc_p4));
    case sel_StatementDoWhile:
	return StatementDoWhile(phylum_cast<statement>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_StatementWhile:
	return StatementWhile(phylum_cast<expression>(kc_p1), phylum_cast<statement>(kc_p2));
    case sel_StatementIf:
	return StatementIf(phylum_cast<expression>(kc_p1), phylum_cast<statement>(kc_p2), phylum_cast<statement>(kc_p3));
    case sel_StatementExprSemicolon:
	return StatementExprSemicolon(phylum_cast<expression>(kc_p1));
    case sel_StatementBlock:
	return StatementBlock(phylum_cast<block>(kc_p1));
    case sel_Declaration:
	return Declaration(phylum_cast<type>(kc_p1), phylum_cast<varOrArrayList>(kc_p2));
    case sel_DeclOrStatemStatement:
	return DeclOrStatemStatement(phylum_cast<statement>(kc_p1), phylum_cast<declarationOrStatement>(kc_p2));
    case sel_DeclOrStatemDeclaration:
	return DeclOrStatemDeclaration(phylum_cast<declaration>(kc_p1), phylum_cast<declarationOrStatement>(kc_p2));
    case sel_EmptyDeclarationOrStatement:
	return EmptyDeclarationOrStatement();
    case sel_Block:
	return Block(phylum_cast<declarationOrStatement>(kc_p1));
    case sel_IdentExprList:
	return IdentExprList(phylum_cast<casestring>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<identExprList>(kc_p3));
    case sel_EmptyIdentExprList:
	return EmptyIdentExprList();
    case sel_Guard:
	return Guard(phylum_cast<expression>(kc_p1));
    case sel_VarOrArrayList:
	return VarOrArrayList(phylum_cast<varOrArray>(kc_p1), phylum_cast<varOrArrayList>(kc_p2));
    case sel_EmptyVarOrArrayList:
	return EmptyVarOrArrayList();
    case sel_Variable:
	return Variable(phylum_cast<type>(kc_p1), phylum_cast<varOrArrayList>(kc_p2), phylum_cast<variable>(kc_p3));
    case sel_EmptyVariable:
	return EmptyVariable();
    case sel_StrongFair:
	return StrongFair();
    case sel_WeakFair:
	return WeakFair();
    case sel_EmptyFairness:
	return EmptyFairness();
    case sel_Transition:
	return Transition(phylum_cast<casestring>(kc_p1), phylum_cast<fairness>(kc_p2), phylum_cast<variable>(kc_p3), phylum_cast<guard>(kc_p4), phylum_cast<identExprList>(kc_p5), phylum_cast<identExprList>(kc_p6), phylum_cast<transition>(kc_p7));
    case sel_EmptyTransition:
	return EmptyTransition();
    case sel_Marking:
	return Marking(phylum_cast<casestring>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<marking>(kc_p3));
    case sel_EmptyMarking:
	return EmptyMarking();
    case sel_PlaceBlock:
	return PlaceBlock(phylum_cast<optSafe>(kc_p1), phylum_cast<type>(kc_p2), phylum_cast<placelist>(kc_p3));
    case sel_PlaceList:
	return PlaceList(phylum_cast<place>(kc_p1), phylum_cast<placelist>(kc_p2));
    case sel_EmptyPlaceList:
	return EmptyPlaceList();
    case sel_Place:
	return Place(phylum_cast<casestring>(kc_p1));
    case sel_Safe:
	return Safe(phylum_cast<integer>(kc_p1));
    case sel_EmptySafe:
	return EmptySafe();
    case sel_PlaceBlockList:
	return PlaceBlockList(phylum_cast<placeblock>(kc_p1), phylum_cast<placeblocklist>(kc_p2));
    case sel_EmptyPlaceBlockList:
	return EmptyPlaceBlockList();
    case sel_ExpressionListColon:
	return ExpressionListColon(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<expressionListColon>(kc_p3));
    case sel_EmptyExpressionListColon:
	return EmptyExpressionListColon();
    case sel_ExprInBracesColon:
	return ExprInBracesColon(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<expressionListColon>(kc_p3));
    case sel_ExprInBraces:
	return ExprInBraces(phylum_cast<expressionlist>(kc_p1));
    case sel_ExpressionList:
	return ExpressionList(phylum_cast<expression>(kc_p1), phylum_cast<expressionlist>(kc_p2));
    case sel_EmptyExpressionList:
	return EmptyExpressionList();
    case sel_LeftValDot:
	return LeftValDot(phylum_cast<leftvalue>(kc_p1), phylum_cast<casestring>(kc_p2));
    case sel_LeftValBrackets:
	return LeftValBrackets(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_LeftValIdent:
	return LeftValIdent(phylum_cast<casestring>(kc_p1));
    case sel_ExprAll:
	return ExprAll(phylum_cast<type>(kc_p1));
    case sel_ExprOtherIf:
	return ExprOtherIf(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<expression>(kc_p3));
    case sel_ExprCommaSeparated:
	return ExprCommaSeparated(phylum_cast<expressionlist>(kc_p1));
    case sel_FunctionCall:
	return FunctionCall(phylum_cast<casestring>(kc_p1), phylum_cast<expressionlist>(kc_p2));
    case sel_ExprGreaterOrEqual:
	return ExprGreaterOrEqual(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprLessOrEqual:
	return ExprLessOrEqual(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprGreaterThan:
	return ExprGreaterThan(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprLessThan:
	return ExprLessThan(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprNotEqual:
	return ExprNotEqual(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprEquivalent:
	return ExprEquivalent(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprFalse:
	return ExprFalse();
    case sel_ExprTrue:
	return ExprTrue();
    case sel_ExprOr:
	return ExprOr(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprAnd:
	return ExprAnd(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_NotExpr:
	return NotExpr(phylum_cast<expression>(kc_p1));
    case sel_ExprNumber:
	return ExprNumber(phylum_cast<integer>(kc_p1));
    case sel_ExprModulo:
	return ExprModulo(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprDivision:
	return ExprDivision(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprMultiplication:
	return ExprMultiplication(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprSubtraction:
	return ExprSubtraction(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprAddition:
	return ExprAddition(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_NegativeExpr:
	return NegativeExpr(phylum_cast<expression>(kc_p1));
    case sel_PositiveExpr:
	return PositiveExpr(phylum_cast<expression>(kc_p1));
    case sel_ValDecrement:
	return ValDecrement(phylum_cast<leftvalue>(kc_p1));
    case sel_ValIncrement:
	return ValIncrement(phylum_cast<leftvalue>(kc_p1));
    case sel_DecrementVal:
	return DecrementVal(phylum_cast<leftvalue>(kc_p1));
    case sel_IncrementVal:
	return IncrementVal(phylum_cast<leftvalue>(kc_p1));
    case sel_AssignMod:
	return AssignMod(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_AssignDivide:
	return AssignDivide(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_AssignTimes:
	return AssignTimes(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_AssignMinus:
	return AssignMinus(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_AssignPlus:
	return AssignPlus(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_AssignEqual:
	return AssignEqual(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprInitializerList:
	return ExprInitializerList(phylum_cast<initializerList>(kc_p1));
    case sel_ExprLeftvalue:
	return ExprLeftvalue(phylum_cast<leftvalue>(kc_p1));
    case sel_FunctionParameters:
	return FunctionParameters(phylum_cast<type>(kc_p1), phylum_cast<varOrArray>(kc_p2));
    case sel_FunctionParametersList:
	return FunctionParametersList(phylum_cast<functionParameters>(kc_p1), phylum_cast<functionParametersList>(kc_p2));
    case sel_EmptyFunctionParametersList:
	return EmptyFunctionParametersList();
    case sel_ArrayList:
	return ArrayList(phylum_cast<arrayList>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_EmptyArrayList:
	return EmptyArrayList();
    case sel_VarOrArray:
	return VarOrArray(phylum_cast<casestring>(kc_p1), phylum_cast<arrayList>(kc_p2));
    case sel_StructType:
	return StructType(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<arrayList>(kc_p3));
    case sel_StructTypeList:
	return StructTypeList(phylum_cast<structTypeList>(kc_p1), phylum_cast<structType>(kc_p2));
    case sel_EmptyStructTypeList:
	return EmptyStructTypeList();
    case sel_Idents:
	return Idents(phylum_cast<casestring>(kc_p1), phylum_cast<optionalNumber>(kc_p2));
    case sel_IdentList:
	return IdentList(phylum_cast<identList>(kc_p1), phylum_cast<idents>(kc_p2));
    case sel_EmptyIdentList:
	return EmptyIdentList();
    case sel_OptNumber:
	return OptNumber(phylum_cast<integer>(kc_p1));
    case sel_EmptyOptNumber:
	return EmptyOptNumber();
    case sel_TypeBlack:
	return TypeBlack();
    case sel_TypeArray:
	return TypeArray(phylum_cast<type>(kc_p1), phylum_cast<integer>(kc_p2));
    case sel_TypeMultiset:
	return TypeMultiset(phylum_cast<type>(kc_p1));
    case sel_TypeInt:
	return TypeInt();
    case sel_TypeStruct:
	return TypeStruct(phylum_cast<structTypeList>(kc_p1));
    case sel_TypeIntInterval:
	return TypeIntInterval(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_TypeIdent:
	return TypeIdent(phylum_cast<casestring>(kc_p1));
    case sel_TypeEnum:
	return TypeEnum(phylum_cast<identList>(kc_p1));
    case sel_TypeBool:
	return TypeBool();
    case sel_Function:
	return Function(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<arrayList>(kc_p3), phylum_cast<functionParametersList>(kc_p4), phylum_cast<block>(kc_p5));
    case sel_Sort:
	return Sort(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<arrayList>(kc_p3));
    case sel_Constant:
	return Constant(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<arrayList>(kc_p3), phylum_cast<expression>(kc_p4));
    case sel_DefinitionsList:
	return DefinitionsList(phylum_cast<definitionsList>(kc_p1), phylum_cast<definitions>(kc_p2));
    case sel_EmptyDefinitionsList:
	return EmptyDefinitionsList();
    case sel_Net:
	return Net(phylum_cast<casestring>(kc_p1), phylum_cast<definitionsList>(kc_p2), phylum_cast<placeblocklist>(kc_p3), phylum_cast<marking>(kc_p4), phylum_cast<transition>(kc_p5));
    case sel_AcceptingSet:
	return AcceptingSet(phylum_cast<tAcceptingSet>(kc_p1), phylum_cast<tAcceptingSet>(kc_p2));
    case sel_AcceptingState:
	return AcceptingState(phylum_cast<integer>(kc_p1));
    case sel_EmptyAcceptingSet:
	return EmptyAcceptingSet();
    case sel_TransitionRules:
	return TransitionRules(phylum_cast<tTransitionRules>(kc_p1), phylum_cast<tTransitionRules>(kc_p2));
    case sel_TransitionRule:
	return TransitionRule(phylum_cast<tFormula>(kc_p1), phylum_cast<integer>(kc_p2));
    case sel_EmptyTransitionRules:
	return EmptyTransitionRules();
    case sel_BuechiRules:
	return BuechiRules(phylum_cast<tBuechiRules>(kc_p1), phylum_cast<tBuechiRules>(kc_p2));
    case sel_ExpandedBuechiRule:
	return ExpandedBuechiRule(phylum_cast<integer>(kc_p1), phylum_cast<tFormula>(kc_p2), phylum_cast<integer>(kc_p3));
    case sel_BuechiRule:
	return BuechiRule(phylum_cast<integer>(kc_p1), phylum_cast<tTransitionRules>(kc_p2));
    case sel_EmptyBuechiRules:
	return EmptyBuechiRules();
    case sel_BuechiNull:
	return BuechiNull();
    case sel_BuechiAutomaton:
	return BuechiAutomaton(phylum_cast<tBuechiRules>(kc_p1), phylum_cast<tAcceptingSet>(kc_p2));
    case sel_ConstProduct_list:
	return ConstProduct_list(phylum_cast<tTerm>(kc_p1), phylum_cast<tProduct_list>(kc_p2));
    case sel_NiltProduct_list:
	return NiltProduct_list();
    case sel_ProductList:
	return ProductList(phylum_cast<tProduct_list>(kc_p1));
    case sel_Product:
	return Product(phylum_cast<integer>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_Difference:
	return Difference(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_Sum:
	return Sum(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_Number:
	return Number(phylum_cast<integer>(kc_p1));
    case sel_Node:
	return Node(phylum_cast<integer>(kc_p1));
    case sel_Unfireable:
	return Unfireable(phylum_cast<integer>(kc_p1));
    case sel_Fireable:
	return Fireable(phylum_cast<integer>(kc_p1));
    case sel_Initial:
	return Initial();
    case sel_Deadlock:
	return Deadlock();
    case sel_NoDeadlock:
	return NoDeadlock();
    case sel_False:
	return False();
    case sel_True:
	return True();
    case sel_LessEqualAtomicProposition:
	return LessEqualAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_LessAtomicProposition:
	return LessAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_GreaterEqualAtomicProposition:
	return GreaterEqualAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_GreaterAtomicProposition:
	return GreaterAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_NotEqualsAtomicProposition:
	return NotEqualsAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_EqualsAtomicProposition:
	return EqualsAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_ConstDisjunction_list:
	return ConstDisjunction_list(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tDisjunction_list>(kc_p2));
    case sel_NiltDisjunction_list:
	return NiltDisjunction_list();
    case sel_ConstConjunction_list:
	return ConstConjunction_list(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tConjunction_list>(kc_p2));
    case sel_NiltConjunction_list:
	return NiltConjunction_list();
    case sel_DisjunctionList:
	return DisjunctionList(phylum_cast<tDisjunction_list>(kc_p1));
    case sel_ConjunctionList:
	return ConjunctionList(phylum_cast<tConjunction_list>(kc_p1));
    case sel_EX:
	return EX(phylum_cast<tStatePredicate>(kc_p1));
    case sel_AX:
	return AX(phylum_cast<tStatePredicate>(kc_p1));
    case sel_EG:
	return EG(phylum_cast<tStatePredicate>(kc_p1));
    case sel_AG:
	return AG(phylum_cast<tStatePredicate>(kc_p1));
    case sel_EF:
	return EF(phylum_cast<tStatePredicate>(kc_p1));
    case sel_AF:
	return AF(phylum_cast<tStatePredicate>(kc_p1));
    case sel_ER:
	return ER(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_AR:
	return AR(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_EU:
	return EU(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_AU:
	return AU(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Release:
	return Release(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Until:
	return Until(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_NextState:
	return NextState(phylum_cast<tStatePredicate>(kc_p1));
    case sel_Eventually:
	return Eventually(phylum_cast<tStatePredicate>(kc_p1));
    case sel_Always:
	return Always(phylum_cast<tStatePredicate>(kc_p1));
    case sel_ExPath:
	return ExPath(phylum_cast<tStatePredicate>(kc_p1));
    case sel_AllPath:
	return AllPath(phylum_cast<tStatePredicate>(kc_p1));
    case sel_Equivalence:
	return Equivalence(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Implication:
	return Implication(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_ExclusiveDisjunction:
	return ExclusiveDisjunction(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Disjunction:
	return Disjunction(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Conjunction:
	return Conjunction(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Negation:
	return Negation(phylum_cast<tStatePredicate>(kc_p1));
    case sel_AtomicProposition:
	return AtomicProposition(phylum_cast<tAtomicProposition>(kc_p1));
    case sel_Compound:
	return Compound(phylum_cast<tFormula>(kc_p1), phylum_cast<tFormula>(kc_p2));
    case sel_ComputeBound:
	return ComputeBound(phylum_cast<tAtomicProposition>(kc_p1));
    case sel_StatePredicateFormula:
	return StatePredicateFormula(phylum_cast<tStatePredicate>(kc_p1));
    default:
	assertionFailed("Cannot create this kind of phylum - unkown operator id");
    }
    NORETURN
}

abstract_phylum
kc_create(enum_operators createOp, const std::vector<abstract_phylum>& kc_ps)
{
    if (kc_ps.size() < 7) {
	assertionFailed("Need vector of size of maximum subphylum count (which is 7)!");
    }
    return kc_create(createOp, kc_ps[0], kc_ps[1], kc_ps[2], kc_ps[3], kc_ps[4], kc_ps[5], kc_ps[6]);
}

abstract_phylum&
attributeOf(abstract_phylum kc_p, int no)
{
    assertionFailed("Cannot select attribute for this kind of phylum - has no attributes");
    NORETURN
}

abstract_phylum
impl_abstract_phylum::subphylum(int) const
{
    return 0;
}

void
impl_abstract_phylum::set_subphylum(int,abstract_phylum)
{
}

void
impl_abstract_phylum::free(bool kc_rec)
{
    KC_COLLECT_STATS0(KC_FREE_CALLED_STATS(prod_sel(), kc_rec));
    if (!phylum_info[phylum()].uniq_stored) {
	if (kc_rec) {
	    abstract_phylum son;
	    for (int kc_i=0; (son = subphylum(kc_i)); kc_i++)
	    {
		if (son!=0) son->free(kc_rec);
		son=0;
	    }
	}
	KC_COLLECT_STATS0(KC_FREED_STATS(prod_sel(), kc_rec));
	delete this;
    }
}

bool
impl_abstract_phylum::eq(c_abstract_phylum kc_p2) const
{
    if (this == kc_p2)
	return true;
    if (prod_sel() != kc_p2->prod_sel())
	return false;

    int kc_st = phylum_info[phylum()].uniq_stored;
    if (kc_st && kc_storageclass_still_uniq[kc_st])
	return false;

    c_abstract_phylum son1;
    for (int kc_i=0; (son1 = subphylum(kc_i)); kc_i++) {
	if (!son1->eq(kc_p2->subphylum(kc_i)))
	    return false;
    }

    return true;
}

static string kc_indentation = "";
static const char *kc_printformat_not_nullary_open = "%s%s(\n";
static const char *kc_printformat_list_open = "%s%s\n";

static const char *kc_printformat_not_nullary_close = "%s)\n";
static const char *kc_printformat_nullary = "%s%s()\n";

void
impl_abstract_phylum::fprint(FILE*kc_f)
{
    int kc_i;

    if (!kc_f) kc_f = stdout;
    abstract_list al = dynamic_cast<abstract_list>(this);
    if (al != 0 && !al->is_nil()) {
	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());
	kc_indentation+="| ";
	subphylum(0)->fprint(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
    } else // not list
	switch(phylum()) {
	case phylum_voidptr:
	    fprintf(kc_f, "%s%p\n", kc_indentation.c_str(), static_cast<voidptr>(this)->pointer);
	    break;
	case phylum_casestring:
	case phylum_nocasestring:
	    fprintf(kc_f, "%s%s\n", kc_indentation.c_str(), static_cast<casestring>(this)->name);
	    break;
	case phylum_integer:
	    fprintf(kc_f, "%s%i\n", kc_indentation.c_str(), static_cast<integer>(this)->value);
	    break;
	case phylum_real:
	    fprintf(kc_f, "%s%f\n", kc_indentation.c_str(), static_cast<real>(this)->value);
	    break;
	default:
	    if (!subphylum(0)) {
		fprintf(kc_f, kc_printformat_nullary, kc_indentation.c_str(), op_name());
	    } else {
		fprintf(kc_f, kc_printformat_not_nullary_open, kc_indentation.c_str(), op_name());
		kc_indentation+="  ";
		abstract_phylum son;
		for (kc_i=0; (son = subphylum(kc_i)); kc_i++) {
		    son->fprint(kc_f);
		}
		kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
		fprintf(kc_f, kc_printformat_not_nullary_close, kc_indentation.c_str());
	    }
    }
}

void 
impl_abstract_phylum::print()
{
    fprint(stdout);
}

void 
impl_abstract_list::fprint_list(FILE*kc_f)
{
    if (!kc_f)
	kc_f = stdout;
    if (this->is_nil()) {
	kc_indentation+="`-";
	fprintf(kc_f, kc_printformat_nullary, kc_indentation.c_str(), op_name());
    } else {
	kc_indentation+="|-";
	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	kc_indentation+="| ";
	subphylum(0)->fprint(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);
    }
}

int
impl_abstract_list::length() const
{
    int kc_length = 0;
    c_abstract_phylum kc_p = this;
    while((kc_p = kc_p->subphylum(1)))
	kc_length++;
    return kc_length;
}
void impl_abstract_list::freelist()
{
    abstract_phylum kc_p = this, kc_tmp_p;
    do {
	kc_tmp_p=kc_p->subphylum(1);
	kc_p->free(false);
	kc_p=kc_tmp_p;
    } while(kc_p);
}
abstract_phylum
impl_abstract_list::do_concat(c_abstract_phylum kc_p2, enum_operators mk) const
{
    abstract_phylum next = subphylum(1);
    if(!next)
	return const_cast<abstract_phylum>(kc_p2);
    return kc_create(mk, subphylum(0), static_cast<abstract_list>(next)->do_concat(kc_p2, mk));
}

abstract_phylum
impl_abstract_list::do_reverse(c_abstract_phylum tail, enum_operators mk) const
{
    for (impl_abstract_list const* iterator_ = this; iterator_->subphylum(1) != 0;
	iterator_ = static_cast<impl_abstract_list const*>(iterator_->subphylum(1)) )
    tail = kc_create(mk, iterator_->subphylum(0), const_cast<abstract_phylum>(tail));
    return const_cast<abstract_phylum>(tail);
}

abstract_phylum
impl_abstract_list::last() const
{
    c_abstract_phylum kc_p = this, next = subphylum(1), nextnext;
#ifdef _AFX
    ASSERT(next);
    if(!next)
	return NULL;
#else
    if(!next){
	fflush(stdout);
	fprintf(stderr, "Internal Error: list::last was called with argument Nil%s\n", phylum_name());
	exit(1);
    }
#endif
    while ((nextnext = next->subphylum(1))) {
	kc_p = next;
	next = nextnext;
    }
    return const_cast<abstract_phylum>(kc_p->subphylum(0));/* XXX remove cast */
}

abstract_phylum
impl_abstract_list::do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    return kc_create(mk, kc_fp(el), next->do_map(kc_fp, mk));
}

abstract_phylum
impl_abstract_list::do_filter(bool (*kc_fp)(abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    if ((*kc_fp)(el)) {
	return kc_create(mk, el, next->do_filter(kc_fp, mk));
    } else {
	return next->do_filter(kc_fp, mk);
    }
}

abstract_list
impl_abstract_list::do_append(abstract_phylum new_last, abstract_list eol)
{
    abstract_list next = this;
    while (!next->is_nil())
	next = phylum_cast<abstract_list>(next->subphylum(1));
    next->set_subphylum(0, new_last);
    next->set_subphylum(1, eol);
    return next;
}

abstract_phylum
impl_abstract_list::do_merge(abstract_list second,abstract_phylum(*kc_fp)(abstract_phylum,abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_phylum el2 = second->subphylum(0);
    if (!el2)
	return el2;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    abstract_list next2 = static_cast<abstract_list>(second->subphylum(1));
    return kc_create(mk, kc_fp(el,el2), next->do_merge(next2, kc_fp, mk));
}

abstract_phylum
impl_abstract_list::do_reduce(abstract_phylum neutral, abstract_phylum(*kc_fp)(abstract_phylum,abstract_phylum)) {
    abstract_phylum el = subphylum(0);
    if (!el)
	return neutral;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    return kc_fp(el,next->do_reduce(neutral,kc_fp));
}


extern const char* kc_storageclassnames[];

#ifdef KC_STATISTICS
void do_print_operator_statistics(FILE * kc_f)
{
    unsigned int kc_i;
    assertNonNull( kc_f );
    fprintf(kc_f, "%-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s\n", 38 , "Operator", 3, "Sz", 8, "#oper", 8, "#new", 8, "#exist", 8, "#frnrec", 8, "#frrec", 8, "#freed", 8, "#rem", 9, "total (bytes)");
    fprintf(kc_f, "%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, "case sensitive strings", 3, "-", 8, operator_statistics[sel__Str].created, 8, operator_statistics[sel__Str].existing_not_found, 8, operator_statistics[sel__Str].created-operator_statistics[sel__Str].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_casestring_strlen);
    fprintf(kc_f, "%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, "case insensitive strings", 3, "-", 8, operator_statistics[sel_NoCaseStr].created, 8, operator_statistics[sel_NoCaseStr].existing_not_found, 8, operator_statistics[sel_NoCaseStr].created-operator_statistics[sel_NoCaseStr].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_nocasestring_strlen);
    for (kc_i = one_before_first_operator+1; kc_i < last_operator; kc_i++) {
	fprintf(kc_f, "%-*s|%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, operator_info[kc_i].name, 3, operator_info[kc_i].size, 8, operator_statistics[kc_i].created, 8, operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].created-operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].free_called[false], 8, operator_statistics[kc_i].free_called[true], 8, operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true], 8, operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true]), 9, operator_info[kc_i].size*(operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true])));
    }
}
#endif // KC_STATISTICS


void
ht_static(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_static();
}

void
ht_dynamic(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_dynamic();
}

void
ht_inc_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_inc_level();
}

void
ht_dec_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_dec_level();
}

void
ht_free_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_free_level();
}

hashtable_t
ht_create_simple()
{
    hashtable_t kc_ht=new hashtable_struct_t;
    kc_ht->set_to_be_freed();
    return kc_ht;
}

hashtable_t
ht_assign(hashtable_t kc_a_hashtable_t, kc_storageclass_t kc_a_storageclass_t, bool still_unique)
{
    hashtable_t kc_tmp = hashtables[kc_a_storageclass_t];
    hashtables[kc_a_storageclass_t] = kc_a_hashtable_t;
    kc_storageclass_still_uniq[kc_a_storageclass_t] = still_unique;
    return kc_tmp;
}

hashtable_t
ht_assigned(kc_storageclass_t kc_a_storageclass_t)
{
    return hashtables[kc_a_storageclass_t];
}

void
ht_clear(hashtable_t kc_a_hashtable_t)
{
    kc_a_hashtable_t->ht_clear();
}

void
ht_delete(hashtable_t kc_a_hashtable_t)
{
    if(kc_a_hashtable_t->to_be_freed())
	delete kc_a_hashtable_t;
}
const char*
phylumname_or_error(enum_phyla kc_phy)
{
    if ((kc_phy <= one_before_first_phylum) || (kc_phy >= last_phylum)) {
	char *kc_strof_error;
	sprintf((kc_strof_error=new char[69]), "Internal Error: unknown phylum number: %d", kc_phy);
	return kc_strof_error;
    } else {
	return phylum_info[kc_phy].name;
    }   }


const char*
kc_operatorname_or_error(enum_operators kc_operator)
{
    if ((kc_operator <= one_before_first_operator) || (kc_operator >= last_operator)) {
	char *kc_strof_error;
	sprintf((kc_strof_error=new char[71]), "Internal Error: unknown operator number: %d", kc_operator);
	return kc_strof_error;
    } else {
	return operator_info[kc_operator].name;
    }   }


#ifndef KC_PRINTDOT_LABELSIZE
# define KC_PRINTDOT_LABELSIZE 1023
#endif

class impl_kc_dotedgenode_t
{
    public:
    impl_kc_dotedgenode_t(c_abstract_phylum from,c_abstract_phylum to, int _son_nr):
    ptr_from(from), ptr_to(to), son_nr(_son_nr), label(0), lsize(0), next(0) { }
    c_abstract_phylum ptr_from;
    c_abstract_phylum ptr_to;
    int son_nr;
    char *label;
    int lsize;
    kc_dotedgenode_t next;
};

static kc_dotedgenode_t
kc_mkdotedgenode(struct kc_dotedge_ht*, c_abstract_phylum, c_abstract_phylum, int);
static void kc_do_printdot_do_add_edge (c_abstract_phylum, c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*);
static void kc_do_printdot_subgraph_prologue (FILE*, c_abstract_phylum, const char*, const char*, bool, bool);
static void kc_do_printdot_subgraph_epilogue (FILE*);
static void kc_do_printdot_genfields (FILE*, int, bool);
static void kc_do_printdot_edges (FILE*, kc_dotedgenode_t, const char*, bool);

static bool
kc_dotedge_less(kc_dotedgenode_t p1, kc_dotedgenode_t p2)
{
    if(p2==0)
	return false;
    if(p1==0)
	return true;
    if(p1->ptr_from<p2->ptr_from)
	return true;
    if(p1->ptr_from>p2->ptr_from)
	return false;
    if(p1->ptr_to<p2->ptr_to)
	return true;
    if(p1->ptr_to>p2->ptr_to)
	return false;
    if(p1->son_nr<p2->son_nr)
	return true;
    // OPERATORHASH((unsigned) kc_phy_from);
    // OPERATORHASH((unsigned) kc_phy_to);
    return false;
}

template<typename T>
struct dotedge_less : std::binary_function<T, T, bool> {
    bool operator()(const T& X, const T& Y) const { return kc_dotedge_less(X,Y); }
};

struct kc_dotedge_ht: public std::set<kc_dotedgenode_t, dotedge_less<kc_dotedgenode_t> > {
    ~kc_dotedge_ht() {
	for(iterator i=begin();i!=end();++i)
	delete const_cast<kc_dotedgenode_t>(*i);
	clear();
    }
    kc_dotedgenode_t check_insert(kc_dotedgenode_t t) {
	std::pair<iterator,bool> res=insert(t);
	return *res.first;
    }
};

static kc_dotedge_ht* fprintdot_hashtable;
void impl_nocasestring::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_casestring::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_real::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_integer::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_voidptr::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tFormula::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tStatePredicate::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tConjunction_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tDisjunction_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tAtomicProposition::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tTerm::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tProduct_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tBuechiAutomata::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tBuechiRules::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tTransitionRules::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tAcceptingSet::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_net::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_definitionsList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_definitions::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_type::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_optionalNumber::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_identList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_idents::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_structTypeList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_structType::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_varOrArray::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_arrayList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_functionParametersList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_functionParameters::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_expression::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_leftvalue::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_expressionlist::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_initializerList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_expressionListColon::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_placeblocklist::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_optSafe::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_place::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_placelist::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_placeblock::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_marking::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_transition::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_fairness::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_variable::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_varOrArrayList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_guard::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_identExprList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_block::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_declarationOrStatement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_declaration::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_statement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_switchCase::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_switchCaseList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}


kc_dotedgenode_t
kc_mkdotedgenode(kc_dotedge_ht* kc_a_ht, c_abstract_phylum kc_s_from, c_abstract_phylum kc_s_to, int kc_son_nr)
{
    kc_dotedgenode_t kc_x = new impl_kc_dotedgenode_t(kc_s_from,kc_s_to,kc_son_nr);
    kc_dotedgenode_t unique_kc_x=kc_a_ht->check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    }
    return kc_x;
}

void kc_do_printdot_subgraph_prologue(FILE *kc_f, c_abstract_phylum kc_p, const char *root_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "/*subgraph*/ {\n");
    if (root_label_prefix) {
	fprintf(kc_f, "\"%s\" [shape=ellipse", root_label_prefix);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, ", %s", edge_attributes);
	}
	if (print_node_labels) {
	    fprintf(kc_f, ", label=\"%s\\n%s\"", root_label_prefix, phylum_info[kc_p->phylum()].name);
	}
	fprintf(kc_f, "];\n");
	fprintf(kc_f, "\"%s\" ->", root_label_prefix);
	kc_p->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, "[%s]", edge_attributes);
	}
	fprintf(kc_f, ";\n");
    }
}

void kc_do_printdot_subgraph_epilogue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "}\n");
}

void fprintdotprologue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "digraph kc_output{\n");
    fprintf(kc_f, "node [shape=record, height=.1, fontname=Helvetica];\n");
}

void fprintdotepilogue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "}\n");
}

void kc_do_printdot_genfields(FILE *kc_f, int kc_prodsel, bool print_node_labels)
{
    int kc_i = 1;
    KC_OPERATOR_INFO *kc_op_info = &operator_info[kc_prodsel];
    if (kc_op_info->no_sons <= 0) return;
    if (!kc_f) kc_f = stdout;
    while(kc_i < kc_op_info->no_sons) {
	fprintf(kc_f, "<f%d>", kc_i);
	if (print_node_labels) {
	    fprintf(kc_f, "%s", phylum_info[kc_op_info->subphylum[kc_i-1]].name);
	}
	fprintf(kc_f, "|");
	kc_i++;
    }
    fprintf(kc_f, "<f%d>", kc_i);
    if (print_node_labels) {
	fprintf(kc_f, "%s", phylum_info[kc_op_info->subphylum[kc_i-1]].name);
    }
}

void impl_abstract_phylum::do_printdot_id(FILE *kc_f, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_son_nr) const
{
    // The casts only make unique ids, so reinterpret_cast is alright
    if (!kc_f) kc_f = stdout;
    enum_phyla kc_phy = phylum();
    if (kc_phy == phylum_voidptr) {
	fprintf(kc_f, "kcidp%lx", reinterpret_cast<unsigned long int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%lx_%d", reinterpret_cast<unsigned long int>(kc_ctxt), kc_son_nr);
	}
    } else if ((kc_phy == phylum_casestring) || (kc_phy == phylum_nocasestring)) {
	fprintf(kc_f, "kcids%lx", reinterpret_cast<unsigned long int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%lx_%d", reinterpret_cast<unsigned long int>(kc_ctxt), kc_son_nr);
	}
    } else if (kc_phy == phylum_integer) {
	fprintf(kc_f, "kcidi%lx", reinterpret_cast<unsigned long int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%lx_%d", reinterpret_cast<unsigned long int>(kc_ctxt), kc_son_nr);
	}
    } else if (kc_phy == phylum_real) {
	fprintf(kc_f, "kcidf%lx", reinterpret_cast<unsigned long int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%lx_%d", reinterpret_cast<unsigned long int>(kc_ctxt), kc_son_nr);
	}
    } else {
	fprintf(kc_f, "kcidx%lx", reinterpret_cast<unsigned long int>(this));
    }   }

void kc_do_printdot_do_add_edge(c_abstract_phylum kc_p, c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix)
{
    kc_dotedgenode_t kc_hn;
    char kc_buf[30];
    kc_hn = kc_mkdotedgenode(fprintdot_hashtable, kc_p, kc_sub_p, kc_son_nr);
    if (! kc_hn->label) {
	kc_hn->label = new char[(size_t)(KC_PRINTDOT_LABELSIZE+1)];
	kc_hn->lsize = KC_PRINTDOT_LABELSIZE;
	strcpy(kc_hn->label, "");
	kc_hn->next = *kc_edges;
	*kc_edges = kc_hn;
    } else {
	char kc_buf2[30];
	sprintf(kc_buf2, ", ");
	strncat(kc_hn->label, kc_buf2, kc_hn->lsize - strlen(kc_hn->label));
    }
    if (edge_label_prefix) {
	strncat(kc_hn->label, edge_label_prefix, kc_hn->lsize - strlen(kc_hn->label));
    }
    sprintf(kc_buf, "%d", *kc_edge_nr);
    strncat(kc_hn->label, kc_buf, kc_hn->lsize - strlen(kc_hn->label));
    (*kc_edge_nr)++;
}

void impl_abstract_phylum::printdot_add_edge(c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix) const
{
    kc_do_printdot_do_add_edge(this, kc_sub_p, kc_son_nr, kc_edge_nr, kc_edges, edge_label_prefix);
}

void kc_do_printdot_edges(FILE *kc_f, kc_dotedgenode_t kc_edges, const char *edge_attributes, bool use_context_when_sharing_leaves)
{
    kc_dotedgenode_t kc_p = kc_edges;
    if (!kc_f) kc_f = stdout;
    while(kc_p) {
	kc_p->ptr_from->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);
	fprintf(kc_f, ":f%d -> ", kc_p->son_nr);
	kc_p->ptr_to->do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_p->ptr_from, kc_p->son_nr);
	fprintf(kc_f, " [label=\"%s\"", kc_p->label);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, ", %s", edge_attributes);
	}
	fprintf(kc_f, "];\n");
	kc_p = kc_p->next;
    }   }

void impl_abstract_phylum::do_printdot(FILE *kc_f, bool kc_outmost, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix, bool print_node_labels, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_son_nr) const
{
    int kc_i;

    if (!kc_f) kc_f = stdout;
    switch(phylum()) {
	case phylum_voidptr:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%p\", shape=ellipse];\n", dynamic_cast<c_voidptr>(this)->pointer);
	break;
	case phylum_casestring:
	case phylum_nocasestring:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
#ifdef KC_UNICODE
	fprintf(kc_f, " [label=\"%s\", shape=ellipse];\n", kc_to_cstring(static_cast<c_casestring>(this)->name).c_str());
#else
	fprintf(kc_f, " [label=\"%s\", shape=ellipse];\n", static_cast<c_casestring>(this)->name);
#endif
	break;
	case phylum_integer:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%i\", shape=ellipse];\n", ((integer)this)->value);
	break;
	case phylum_real:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%f\", shape=ellipse];\n", ((real)this)->value);
	break;
	default:
	if (!subphylum(0)) {
	    do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	    fprintf(kc_f, " [label=\"<f0>%s\"];\n", op_name());
	} else {
	    do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	    fprintf(kc_f, " [label=\"{<f0>%s|{", op_name());
	    kc_do_printdot_genfields(kc_f, prod_sel(), print_node_labels);
	    fprintf(kc_f, "}}\"];\n");
	    abstract_phylum child;
	    for (kc_i=0; (child = subphylum(kc_i)); kc_i++) {
		printdot_add_edge(child, kc_i+1, kc_edge_nr, kc_edges, edge_label_prefix );
		child->do_printdot( kc_f, false, kc_edge_nr, kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, this, kc_i+1 );
	    }
	}
    }
}
tConjunction_list
concat(c_tConjunction_list kc_p1, c_tConjunction_list kc_p2)
{ return dynamic_cast<tConjunction_list>(kc_p1->do_concat(kc_p2, sel_ConstConjunction_list)); }

tConjunction_list
impl_tConjunction_list::reverse() const
{ return dynamic_cast<tConjunction_list>(do_reverse(NiltConjunction_list(), sel_ConstConjunction_list)); }

tStatePredicate
impl_tConjunction_list::last() const
{ return dynamic_cast<tStatePredicate>(impl_abstract_list::last()); }

bool
impl_tConjunction_list::is_nil() const
{
    return tStatePredicate_1==0 && tConjunction_list_1==0;
}

tConjunction_list
impl_tConjunction_list::map(tStatePredicate (*kc_fp)(tStatePredicate))
{ return dynamic_cast<tConjunction_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_ConstConjunction_list)); }
tConjunction_list
impl_tConjunction_list::filter(bool (*kc_fp)(tStatePredicate))
{ return dynamic_cast<tConjunction_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_ConstConjunction_list)); }

tConjunction_list
impl_tConjunction_list::append(tStatePredicate new_last)
{
    return dynamic_cast<tConjunction_list>(do_append(new_last, NiltConjunction_list()));
}
tConjunction_list
impl_tConjunction_list::merge( tConjunction_list second, tStatePredicate (*kc_fp)(tStatePredicate, tStatePredicate))
{
    return dynamic_cast<tConjunction_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_ConstConjunction_list));
}
tStatePredicate
impl_tConjunction_list::reduce( tStatePredicate neutral, tStatePredicate (*kc_fp)(tStatePredicate, tStatePredicate))
{
    return dynamic_cast<tStatePredicate>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

tDisjunction_list
concat(c_tDisjunction_list kc_p1, c_tDisjunction_list kc_p2)
{ return dynamic_cast<tDisjunction_list>(kc_p1->do_concat(kc_p2, sel_ConstDisjunction_list)); }

tDisjunction_list
impl_tDisjunction_list::reverse() const
{ return dynamic_cast<tDisjunction_list>(do_reverse(NiltDisjunction_list(), sel_ConstDisjunction_list)); }

tStatePredicate
impl_tDisjunction_list::last() const
{ return dynamic_cast<tStatePredicate>(impl_abstract_list::last()); }

bool
impl_tDisjunction_list::is_nil() const
{
    return tStatePredicate_1==0 && tDisjunction_list_1==0;
}

tDisjunction_list
impl_tDisjunction_list::map(tStatePredicate (*kc_fp)(tStatePredicate))
{ return dynamic_cast<tDisjunction_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_ConstDisjunction_list)); }
tDisjunction_list
impl_tDisjunction_list::filter(bool (*kc_fp)(tStatePredicate))
{ return dynamic_cast<tDisjunction_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_ConstDisjunction_list)); }

tDisjunction_list
impl_tDisjunction_list::append(tStatePredicate new_last)
{
    return dynamic_cast<tDisjunction_list>(do_append(new_last, NiltDisjunction_list()));
}
tDisjunction_list
impl_tDisjunction_list::merge( tDisjunction_list second, tStatePredicate (*kc_fp)(tStatePredicate, tStatePredicate))
{
    return dynamic_cast<tDisjunction_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_ConstDisjunction_list));
}
tStatePredicate
impl_tDisjunction_list::reduce( tStatePredicate neutral, tStatePredicate (*kc_fp)(tStatePredicate, tStatePredicate))
{
    return dynamic_cast<tStatePredicate>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

tProduct_list
concat(c_tProduct_list kc_p1, c_tProduct_list kc_p2)
{ return dynamic_cast<tProduct_list>(kc_p1->do_concat(kc_p2, sel_ConstProduct_list)); }

tProduct_list
impl_tProduct_list::reverse() const
{ return dynamic_cast<tProduct_list>(do_reverse(NiltProduct_list(), sel_ConstProduct_list)); }

tTerm
impl_tProduct_list::last() const
{ return dynamic_cast<tTerm>(impl_abstract_list::last()); }

bool
impl_tProduct_list::is_nil() const
{
    return tTerm_1==0 && tProduct_list_1==0;
}

tProduct_list
impl_tProduct_list::map(tTerm (*kc_fp)(tTerm))
{ return dynamic_cast<tProduct_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_ConstProduct_list)); }
tProduct_list
impl_tProduct_list::filter(bool (*kc_fp)(tTerm))
{ return dynamic_cast<tProduct_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_ConstProduct_list)); }

tProduct_list
impl_tProduct_list::append(tTerm new_last)
{
    return dynamic_cast<tProduct_list>(do_append(new_last, NiltProduct_list()));
}
tProduct_list
impl_tProduct_list::merge( tProduct_list second, tTerm (*kc_fp)(tTerm, tTerm))
{
    return dynamic_cast<tProduct_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_ConstProduct_list));
}
tTerm
impl_tProduct_list::reduce( tTerm neutral, tTerm (*kc_fp)(tTerm, tTerm))
{
    return dynamic_cast<tTerm>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

abstract_phylum
impl_abstract_phylum::copy(bool kc_copy_attributes) const
{
    enum_phyla kc_phy = phylum(); // XXX - implement special cases in subclasses - MvL
    KC_OPERATOR_INFO *kc_op_info = &operator_info[prod_sel()];
    kc_storageclass_t kc_st = phylum_info[kc_op_info->phylum].uniq_stored;
    if (kc_st && kc_storageclass_still_uniq[kc_st])
	return const_cast<abstract_phylum>(this);
    abstract_phylum kc_answer=0;
    if (kc_phy == phylum_casestring) {
	kc_answer=mkcasestring((dynamic_cast<c_casestring>(this))->name);
    } else if (kc_phy == phylum_nocasestring) {
	kc_answer=mknocasestring((dynamic_cast<c_nocasestring>(this))->name);
    } else if (kc_phy == phylum_voidptr) {
	kc_answer=mkvoidptr((dynamic_cast<c_voidptr>(this))->pointer);
    } else if (kc_phy == phylum_integer) {
	kc_answer=mkinteger((dynamic_cast<c_integer>(this))->value);
    } else if (kc_phy == phylum_real) {
	kc_answer=mkreal((dynamic_cast<c_real>(this))->value);
    } else {
	abstract_phylum kc_subtmp[7], child;
	for (int kc_i = 0; (child = subphylum(kc_i)); kc_i++) {
	    kc_subtmp[kc_i] = child->copy(kc_copy_attributes);
	}
	switch(kc_op_info->no_sons) {
	    case 0: kc_answer = kc_create(prod_sel()); break;
	    case 1: kc_answer = kc_create(prod_sel(), kc_subtmp[0]); break;
	    case 2: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1]); break;
	    case 3: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2]); break;
	    case 4: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2], kc_subtmp[3]); break;
	    case 5: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2], kc_subtmp[3], kc_subtmp[4]); break;
	    case 6: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2], kc_subtmp[3], kc_subtmp[4], kc_subtmp[5]); break;
	    case 7: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2], kc_subtmp[3], kc_subtmp[4], kc_subtmp[5], kc_subtmp[6]); break;
	    default: assertionFailed("unexpected number of sub-phyla");
	}
    }
    if (kc_copy_attributes)
	copy_attributes(kc_phy, this, kc_answer);
    return kc_answer;
}


} // namespace kc
