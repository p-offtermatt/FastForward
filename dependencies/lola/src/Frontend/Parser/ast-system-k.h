/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#ifndef KC_TYPES_HEADER
#define KC_TYPES_HEADER

#define KIMWITUVERSIONMAJOR 2
#define KIMWITUVERSIONMINOR 3
#define KIMWITUVERSIONMICRO 13

#include <stdio.h>
#include <stddef.h>
#include <string>
#include <vector>

namespace kc {

#ifndef INTEGER
# define INTEGER int
#endif
#ifndef REAL
# define REAL double
#endif

#ifdef KC_UNICODE

#define kc_t(TEXT) L ## TEXT
typedef wchar_t kc_char_t;
typedef std::wstring kc_string_t;

#if defined(_WIN32) && ! defined (__GNUC__)
#define kc_strlen wcslen
#define kc_strcmp wcscmp
#define kc_strcasecmp _wcsicmp
#define kc_strcpy wcscpy
#define kc_strncpy wcsncpy
#define kc_tolower towlower
#define kc_print_integer(buf,number) swprintf(buf,kc_t("%d"),number)
#define kc_print_real(buf,number) swprintf(buf,kc_t("%g"),number)

// needed for printdot and csgio only
inline
std::string kc_to_cstring(const std::wstring& s) {
    USES_CONVERSION;
    return W2CA(s.c_str());
}

// needed for csgio only
inline
std::wstring kc_to_wstring(const std::string& s) {
    USES_CONVERSION;
    return A2CW(s.c_str());
}

#else // !defined(_WIN32) || defined(__GNUC__)
// if you want to use UNICODE on other platforms you have to write
// the following functions on your own
int kc_strlen(const kc_char_t*);
int kc_strcmp(const kc_char_t*,const kc_char_t*);
int kc_strcasecmp(const kc_char_t*,const kc_char_t*);
int kc_strcpy(kc_char_t*,const kc_char_t*);
int kc_strncpy(kc_char_t*,const kc_char_t*, int);
kc_char_t kc_tolower(kc_char_t);
int kc_print_integer(kc_char_t* buffer, INTEGER number );
int kc_print_real(kc_char_t* buffer, REAL number);

// needed for printdot and csgio only
std::string kc_to_cstring(const std::wstring& );
// needed for csgio only
std::wstring kc_to_wstring(const std::string& );

#endif

#else // !KC_UNICODE

#define kc_t(TEXT) TEXT  
typedef char kc_char_t;
typedef std::string kc_string_t;

#define kc_strlen strlen
#define kc_strcmp strcmp
#if defined(_WIN32) && ! defined (__GNUC__)
#define kc_strcasecmp _stricmp
#else
#define kc_strcasecmp strcasecmp
#endif
#define kc_strcpy strcpy
#define kc_strncpy strncpy
#define kc_tolower tolower  
#define kc_print_integer(buf,number) sprintf(buf,kc_t("%d"),number)
#define kc_print_real(buf,number) sprintf(buf,kc_t("%g"),number)
#endif
class uview_class;
typedef uview_class& uview;
typedef const uview_class& c_uview;

typedef class printer_functor_class& printer_functor;
typedef void (*printer_function)(const kc_char_t*, uview);

class rview_class;
typedef rview_class& rview;
typedef const rview_class& c_rview;

}

// Some compilers know __attribute__. Right now we test for the GNU compiler
// and Intel's icc (for ia32) and ecc (for ia64).
#if !defined __GNUC__ && !defined __ICC && !defined __ECC
# define __attribute__(x)
#endif

// Since all definitions are in namespace kc now, there is no need
// give them a kc_ prefix. Old code may still rely on the prefix, so these
// macros are generated for backwards compatibility
#ifdef KC_DEPRECATED
#define kc_PhylumInfo           phylum_info
#define kc_OperatorInfo         operator_info
#define kc_last_uview           last_uview
#define kc_uviews               uviews
#define kc_rviews               rviews
#define kc_ht_reuse             ht_clear
#define kc_ht_clear             ht_clear
#define kc_ht_assign            ht_assign
#define kc_ht_assigned          ht_assigned
#define kc_phylum_nocasestring phylum_nocasestring
#define kc_tag_nocasestring_NoCaseStr impl_nocasestring_NoCaseStr
#define kc_phylum_casestring phylum_casestring
#define kc_tag_casestring__Str impl_casestring__Str
#define kc_phylum_real phylum_real
#define kc_tag_real__Real impl_real__Real
#define kc_phylum_integer phylum_integer
#define kc_tag_integer__Int impl_integer__Int
#define kc_phylum_voidptr phylum_voidptr
#define kc_tag_voidptr__VoidPtr impl_voidptr__VoidPtr
#define kc_phylum_tFormula phylum_tFormula
#define kc_tag_tFormula_StatePredicateFormula impl_tFormula_StatePredicateFormula
#define kc_tag_tFormula_ComputeBound impl_tFormula_ComputeBound
#define kc_tag_tFormula_Compound impl_tFormula_Compound
#define kc_phylum_tStatePredicate phylum_tStatePredicate
#define kc_tag_tStatePredicate_AtomicProposition impl_tStatePredicate_AtomicProposition
#define kc_tag_tStatePredicate_Negation impl_tStatePredicate_Negation
#define kc_tag_tStatePredicate_Conjunction impl_tStatePredicate_Conjunction
#define kc_tag_tStatePredicate_Disjunction impl_tStatePredicate_Disjunction
#define kc_tag_tStatePredicate_ExclusiveDisjunction impl_tStatePredicate_ExclusiveDisjunction
#define kc_tag_tStatePredicate_Implication impl_tStatePredicate_Implication
#define kc_tag_tStatePredicate_Equivalence impl_tStatePredicate_Equivalence
#define kc_tag_tStatePredicate_AllPath impl_tStatePredicate_AllPath
#define kc_tag_tStatePredicate_ExPath impl_tStatePredicate_ExPath
#define kc_tag_tStatePredicate_Always impl_tStatePredicate_Always
#define kc_tag_tStatePredicate_Eventually impl_tStatePredicate_Eventually
#define kc_tag_tStatePredicate_NextState impl_tStatePredicate_NextState
#define kc_tag_tStatePredicate_Until impl_tStatePredicate_Until
#define kc_tag_tStatePredicate_Release impl_tStatePredicate_Release
#define kc_tag_tStatePredicate_AU impl_tStatePredicate_AU
#define kc_tag_tStatePredicate_EU impl_tStatePredicate_EU
#define kc_tag_tStatePredicate_AR impl_tStatePredicate_AR
#define kc_tag_tStatePredicate_ER impl_tStatePredicate_ER
#define kc_tag_tStatePredicate_AF impl_tStatePredicate_AF
#define kc_tag_tStatePredicate_EF impl_tStatePredicate_EF
#define kc_tag_tStatePredicate_AG impl_tStatePredicate_AG
#define kc_tag_tStatePredicate_EG impl_tStatePredicate_EG
#define kc_tag_tStatePredicate_AX impl_tStatePredicate_AX
#define kc_tag_tStatePredicate_EX impl_tStatePredicate_EX
#define kc_tag_tStatePredicate_ConjunctionList impl_tStatePredicate_ConjunctionList
#define kc_tag_tStatePredicate_DisjunctionList impl_tStatePredicate_DisjunctionList
#define kc_phylum_tConjunction_list phylum_tConjunction_list
#define kc_tag_tConjunction_list_NiltConjunction_list impl_tConjunction_list_NiltConjunction_list
#define kc_tag_tConjunction_list_ConstConjunction_list impl_tConjunction_list_ConstConjunction_list
#define kc_phylum_tDisjunction_list phylum_tDisjunction_list
#define kc_tag_tDisjunction_list_NiltDisjunction_list impl_tDisjunction_list_NiltDisjunction_list
#define kc_tag_tDisjunction_list_ConstDisjunction_list impl_tDisjunction_list_ConstDisjunction_list
#define kc_phylum_tAtomicProposition phylum_tAtomicProposition
#define kc_tag_tAtomicProposition_EqualsAtomicProposition impl_tAtomicProposition_EqualsAtomicProposition
#define kc_tag_tAtomicProposition_NotEqualsAtomicProposition impl_tAtomicProposition_NotEqualsAtomicProposition
#define kc_tag_tAtomicProposition_GreaterAtomicProposition impl_tAtomicProposition_GreaterAtomicProposition
#define kc_tag_tAtomicProposition_GreaterEqualAtomicProposition impl_tAtomicProposition_GreaterEqualAtomicProposition
#define kc_tag_tAtomicProposition_LessAtomicProposition impl_tAtomicProposition_LessAtomicProposition
#define kc_tag_tAtomicProposition_LessEqualAtomicProposition impl_tAtomicProposition_LessEqualAtomicProposition
#define kc_tag_tAtomicProposition_True impl_tAtomicProposition_True
#define kc_tag_tAtomicProposition_False impl_tAtomicProposition_False
#define kc_tag_tAtomicProposition_NoDeadlock impl_tAtomicProposition_NoDeadlock
#define kc_tag_tAtomicProposition_Deadlock impl_tAtomicProposition_Deadlock
#define kc_tag_tAtomicProposition_Initial impl_tAtomicProposition_Initial
#define kc_tag_tAtomicProposition_Fireable impl_tAtomicProposition_Fireable
#define kc_tag_tAtomicProposition_Unfireable impl_tAtomicProposition_Unfireable
#define kc_phylum_tTerm phylum_tTerm
#define kc_tag_tTerm_Node impl_tTerm_Node
#define kc_tag_tTerm_Number impl_tTerm_Number
#define kc_tag_tTerm_Sum impl_tTerm_Sum
#define kc_tag_tTerm_Difference impl_tTerm_Difference
#define kc_tag_tTerm_Product impl_tTerm_Product
#define kc_tag_tTerm_ProductList impl_tTerm_ProductList
#define kc_phylum_tProduct_list phylum_tProduct_list
#define kc_tag_tProduct_list_NiltProduct_list impl_tProduct_list_NiltProduct_list
#define kc_tag_tProduct_list_ConstProduct_list impl_tProduct_list_ConstProduct_list
#define kc_phylum_tBuechiAutomata phylum_tBuechiAutomata
#define kc_tag_tBuechiAutomata_BuechiAutomaton impl_tBuechiAutomata_BuechiAutomaton
#define kc_tag_tBuechiAutomata_BuechiNull impl_tBuechiAutomata_BuechiNull
#define kc_phylum_tBuechiRules phylum_tBuechiRules
#define kc_tag_tBuechiRules_EmptyBuechiRules impl_tBuechiRules_EmptyBuechiRules
#define kc_tag_tBuechiRules_BuechiRule impl_tBuechiRules_BuechiRule
#define kc_tag_tBuechiRules_ExpandedBuechiRule impl_tBuechiRules_ExpandedBuechiRule
#define kc_tag_tBuechiRules_BuechiRules impl_tBuechiRules_BuechiRules
#define kc_phylum_tTransitionRules phylum_tTransitionRules
#define kc_tag_tTransitionRules_EmptyTransitionRules impl_tTransitionRules_EmptyTransitionRules
#define kc_tag_tTransitionRules_TransitionRule impl_tTransitionRules_TransitionRule
#define kc_tag_tTransitionRules_TransitionRules impl_tTransitionRules_TransitionRules
#define kc_phylum_tAcceptingSet phylum_tAcceptingSet
#define kc_tag_tAcceptingSet_EmptyAcceptingSet impl_tAcceptingSet_EmptyAcceptingSet
#define kc_tag_tAcceptingSet_AcceptingState impl_tAcceptingSet_AcceptingState
#define kc_tag_tAcceptingSet_AcceptingSet impl_tAcceptingSet_AcceptingSet
#define kc_phylum_net phylum_net
#define kc_tag_net_Net impl_net_Net
#define kc_phylum_definitionsList phylum_definitionsList
#define kc_tag_definitionsList_EmptyDefinitionsList impl_definitionsList_EmptyDefinitionsList
#define kc_tag_definitionsList_DefinitionsList impl_definitionsList_DefinitionsList
#define kc_phylum_definitions phylum_definitions
#define kc_tag_definitions_Constant impl_definitions_Constant
#define kc_tag_definitions_Sort impl_definitions_Sort
#define kc_tag_definitions_Function impl_definitions_Function
#define kc_phylum_type phylum_type
#define kc_tag_type_TypeBool impl_type_TypeBool
#define kc_tag_type_TypeEnum impl_type_TypeEnum
#define kc_tag_type_TypeIdent impl_type_TypeIdent
#define kc_tag_type_TypeIntInterval impl_type_TypeIntInterval
#define kc_tag_type_TypeStruct impl_type_TypeStruct
#define kc_tag_type_TypeInt impl_type_TypeInt
#define kc_tag_type_TypeMultiset impl_type_TypeMultiset
#define kc_tag_type_TypeArray impl_type_TypeArray
#define kc_tag_type_TypeBlack impl_type_TypeBlack
#define kc_phylum_optionalNumber phylum_optionalNumber
#define kc_tag_optionalNumber_EmptyOptNumber impl_optionalNumber_EmptyOptNumber
#define kc_tag_optionalNumber_OptNumber impl_optionalNumber_OptNumber
#define kc_phylum_identList phylum_identList
#define kc_tag_identList_EmptyIdentList impl_identList_EmptyIdentList
#define kc_tag_identList_IdentList impl_identList_IdentList
#define kc_phylum_idents phylum_idents
#define kc_tag_idents_Idents impl_idents_Idents
#define kc_phylum_structTypeList phylum_structTypeList
#define kc_tag_structTypeList_EmptyStructTypeList impl_structTypeList_EmptyStructTypeList
#define kc_tag_structTypeList_StructTypeList impl_structTypeList_StructTypeList
#define kc_phylum_structType phylum_structType
#define kc_tag_structType_StructType impl_structType_StructType
#define kc_phylum_varOrArray phylum_varOrArray
#define kc_tag_varOrArray_VarOrArray impl_varOrArray_VarOrArray
#define kc_phylum_arrayList phylum_arrayList
#define kc_tag_arrayList_EmptyArrayList impl_arrayList_EmptyArrayList
#define kc_tag_arrayList_ArrayList impl_arrayList_ArrayList
#define kc_phylum_functionParametersList phylum_functionParametersList
#define kc_tag_functionParametersList_EmptyFunctionParametersList impl_functionParametersList_EmptyFunctionParametersList
#define kc_tag_functionParametersList_FunctionParametersList impl_functionParametersList_FunctionParametersList
#define kc_phylum_functionParameters phylum_functionParameters
#define kc_tag_functionParameters_FunctionParameters impl_functionParameters_FunctionParameters
#define kc_phylum_expression phylum_expression
#define kc_tag_expression_ExprLeftvalue impl_expression_ExprLeftvalue
#define kc_tag_expression_ExprInitializerList impl_expression_ExprInitializerList
#define kc_tag_expression_AssignEqual impl_expression_AssignEqual
#define kc_tag_expression_AssignPlus impl_expression_AssignPlus
#define kc_tag_expression_AssignMinus impl_expression_AssignMinus
#define kc_tag_expression_AssignTimes impl_expression_AssignTimes
#define kc_tag_expression_AssignDivide impl_expression_AssignDivide
#define kc_tag_expression_AssignMod impl_expression_AssignMod
#define kc_tag_expression_IncrementVal impl_expression_IncrementVal
#define kc_tag_expression_DecrementVal impl_expression_DecrementVal
#define kc_tag_expression_ValIncrement impl_expression_ValIncrement
#define kc_tag_expression_ValDecrement impl_expression_ValDecrement
#define kc_tag_expression_PositiveExpr impl_expression_PositiveExpr
#define kc_tag_expression_NegativeExpr impl_expression_NegativeExpr
#define kc_tag_expression_ExprAddition impl_expression_ExprAddition
#define kc_tag_expression_ExprSubtraction impl_expression_ExprSubtraction
#define kc_tag_expression_ExprMultiplication impl_expression_ExprMultiplication
#define kc_tag_expression_ExprDivision impl_expression_ExprDivision
#define kc_tag_expression_ExprModulo impl_expression_ExprModulo
#define kc_tag_expression_ExprNumber impl_expression_ExprNumber
#define kc_tag_expression_NotExpr impl_expression_NotExpr
#define kc_tag_expression_ExprAnd impl_expression_ExprAnd
#define kc_tag_expression_ExprOr impl_expression_ExprOr
#define kc_tag_expression_ExprTrue impl_expression_ExprTrue
#define kc_tag_expression_ExprFalse impl_expression_ExprFalse
#define kc_tag_expression_ExprEquivalent impl_expression_ExprEquivalent
#define kc_tag_expression_ExprNotEqual impl_expression_ExprNotEqual
#define kc_tag_expression_ExprLessThan impl_expression_ExprLessThan
#define kc_tag_expression_ExprGreaterThan impl_expression_ExprGreaterThan
#define kc_tag_expression_ExprLessOrEqual impl_expression_ExprLessOrEqual
#define kc_tag_expression_ExprGreaterOrEqual impl_expression_ExprGreaterOrEqual
#define kc_tag_expression_FunctionCall impl_expression_FunctionCall
#define kc_tag_expression_ExprCommaSeparated impl_expression_ExprCommaSeparated
#define kc_tag_expression_ExprOtherIf impl_expression_ExprOtherIf
#define kc_tag_expression_ExprAll impl_expression_ExprAll
#define kc_phylum_leftvalue phylum_leftvalue
#define kc_tag_leftvalue_LeftValIdent impl_leftvalue_LeftValIdent
#define kc_tag_leftvalue_LeftValBrackets impl_leftvalue_LeftValBrackets
#define kc_tag_leftvalue_LeftValDot impl_leftvalue_LeftValDot
#define kc_phylum_expressionlist phylum_expressionlist
#define kc_tag_expressionlist_EmptyExpressionList impl_expressionlist_EmptyExpressionList
#define kc_tag_expressionlist_ExpressionList impl_expressionlist_ExpressionList
#define kc_phylum_initializerList phylum_initializerList
#define kc_tag_initializerList_ExprInBraces impl_initializerList_ExprInBraces
#define kc_tag_initializerList_ExprInBracesColon impl_initializerList_ExprInBracesColon
#define kc_phylum_expressionListColon phylum_expressionListColon
#define kc_tag_expressionListColon_EmptyExpressionListColon impl_expressionListColon_EmptyExpressionListColon
#define kc_tag_expressionListColon_ExpressionListColon impl_expressionListColon_ExpressionListColon
#define kc_phylum_placeblocklist phylum_placeblocklist
#define kc_tag_placeblocklist_EmptyPlaceBlockList impl_placeblocklist_EmptyPlaceBlockList
#define kc_tag_placeblocklist_PlaceBlockList impl_placeblocklist_PlaceBlockList
#define kc_phylum_optSafe phylum_optSafe
#define kc_tag_optSafe_EmptySafe impl_optSafe_EmptySafe
#define kc_tag_optSafe_Safe impl_optSafe_Safe
#define kc_phylum_place phylum_place
#define kc_tag_place_Place impl_place_Place
#define kc_phylum_placelist phylum_placelist
#define kc_tag_placelist_EmptyPlaceList impl_placelist_EmptyPlaceList
#define kc_tag_placelist_PlaceList impl_placelist_PlaceList
#define kc_phylum_placeblock phylum_placeblock
#define kc_tag_placeblock_PlaceBlock impl_placeblock_PlaceBlock
#define kc_phylum_marking phylum_marking
#define kc_tag_marking_EmptyMarking impl_marking_EmptyMarking
#define kc_tag_marking_Marking impl_marking_Marking
#define kc_phylum_transition phylum_transition
#define kc_tag_transition_EmptyTransition impl_transition_EmptyTransition
#define kc_tag_transition_Transition impl_transition_Transition
#define kc_phylum_fairness phylum_fairness
#define kc_tag_fairness_EmptyFairness impl_fairness_EmptyFairness
#define kc_tag_fairness_WeakFair impl_fairness_WeakFair
#define kc_tag_fairness_StrongFair impl_fairness_StrongFair
#define kc_phylum_variable phylum_variable
#define kc_tag_variable_EmptyVariable impl_variable_EmptyVariable
#define kc_tag_variable_Variable impl_variable_Variable
#define kc_phylum_varOrArrayList phylum_varOrArrayList
#define kc_tag_varOrArrayList_EmptyVarOrArrayList impl_varOrArrayList_EmptyVarOrArrayList
#define kc_tag_varOrArrayList_VarOrArrayList impl_varOrArrayList_VarOrArrayList
#define kc_phylum_guard phylum_guard
#define kc_tag_guard_Guard impl_guard_Guard
#define kc_phylum_identExprList phylum_identExprList
#define kc_tag_identExprList_EmptyIdentExprList impl_identExprList_EmptyIdentExprList
#define kc_tag_identExprList_IdentExprList impl_identExprList_IdentExprList
#define kc_phylum_block phylum_block
#define kc_tag_block_Block impl_block_Block
#define kc_phylum_declarationOrStatement phylum_declarationOrStatement
#define kc_tag_declarationOrStatement_EmptyDeclarationOrStatement impl_declarationOrStatement_EmptyDeclarationOrStatement
#define kc_tag_declarationOrStatement_DeclOrStatemDeclaration impl_declarationOrStatement_DeclOrStatemDeclaration
#define kc_tag_declarationOrStatement_DeclOrStatemStatement impl_declarationOrStatement_DeclOrStatemStatement
#define kc_phylum_declaration phylum_declaration
#define kc_tag_declaration_Declaration impl_declaration_Declaration
#define kc_phylum_statement phylum_statement
#define kc_tag_statement_StatementBlock impl_statement_StatementBlock
#define kc_tag_statement_StatementExprSemicolon impl_statement_StatementExprSemicolon
#define kc_tag_statement_StatementIf impl_statement_StatementIf
#define kc_tag_statement_StatementWhile impl_statement_StatementWhile
#define kc_tag_statement_StatementDoWhile impl_statement_StatementDoWhile
#define kc_tag_statement_StatementForExpr impl_statement_StatementForExpr
#define kc_tag_statement_StatementForTypeExpr impl_statement_StatementForTypeExpr
#define kc_tag_statement_StatementForIdentColon impl_statement_StatementForIdentColon
#define kc_tag_statement_StatementForAll impl_statement_StatementForAll
#define kc_tag_statement_StatementSwitch impl_statement_StatementSwitch
#define kc_tag_statement_StatementBreak impl_statement_StatementBreak
#define kc_tag_statement_StatementContinue impl_statement_StatementContinue
#define kc_tag_statement_StatementReturn impl_statement_StatementReturn
#define kc_tag_statement_StatementSkip impl_statement_StatementSkip
#define kc_phylum_switchCase phylum_switchCase
#define kc_tag_switchCase_SwitchCase impl_switchCase_SwitchCase
#define kc_tag_switchCase_SwitchDefault impl_switchCase_SwitchDefault
#define kc_phylum_switchCaseList phylum_switchCaseList
#define kc_tag_switchCaseList_EmptySwitchCaseList impl_switchCaseList_EmptySwitchCaseList
#define kc_tag_switchCaseList_SwitchCaseList impl_switchCaseList_SwitchCaseList

#endif // KC_DEPRECATED

// Some compilers are too stupid to detect that a function will always return
// a proper value when it returns one in all branches of an if- or switch-
// statement (with final else or default, of course).
#if !defined __GNUC__
# define NORETURN throw 0;
#else
# define NORETURN
#endif

namespace kc {


typedef enum { one_before_first_phylum = 0 ,
    phylum_nocasestring = 1,
    phylum_casestring = 2,
    phylum_real = 3,
    phylum_integer = 4,
    phylum_voidptr = 5,
    phylum_tFormula = 6,
    phylum_tStatePredicate = 7,
    phylum_tConjunction_list = 8,
    phylum_tDisjunction_list = 9,
    phylum_tAtomicProposition = 10,
    phylum_tTerm = 11,
    phylum_tProduct_list = 12,
    phylum_tBuechiAutomata = 13,
    phylum_tBuechiRules = 14,
    phylum_tTransitionRules = 15,
    phylum_tAcceptingSet = 16,
    phylum_net = 17,
    phylum_definitionsList = 18,
    phylum_definitions = 19,
    phylum_type = 20,
    phylum_optionalNumber = 21,
    phylum_identList = 22,
    phylum_idents = 23,
    phylum_structTypeList = 24,
    phylum_structType = 25,
    phylum_varOrArray = 26,
    phylum_arrayList = 27,
    phylum_functionParametersList = 28,
    phylum_functionParameters = 29,
    phylum_expression = 30,
    phylum_leftvalue = 31,
    phylum_expressionlist = 32,
    phylum_initializerList = 33,
    phylum_expressionListColon = 34,
    phylum_placeblocklist = 35,
    phylum_optSafe = 36,
    phylum_place = 37,
    phylum_placelist = 38,
    phylum_placeblock = 39,
    phylum_marking = 40,
    phylum_transition = 41,
    phylum_fairness = 42,
    phylum_variable = 43,
    phylum_varOrArrayList = 44,
    phylum_guard = 45,
    phylum_identExprList = 46,
    phylum_block = 47,
    phylum_declarationOrStatement = 48,
    phylum_declaration = 49,
    phylum_statement = 50,
    phylum_switchCase = 51,
    phylum_switchCaseList = 52,
    last_phylum = 53
} enum_phyla;

typedef enum { one_before_first_operator = 0 ,
    sel_NoCaseStr = 1,
    sel__Str = 2,
    sel__Real = 3,
    sel__Int = 4,
    sel__VoidPtr = 5,
    sel_StatePredicateFormula = 6,
    sel_ComputeBound = 7,
    sel_Compound = 8,
    sel_AtomicProposition = 9,
    sel_Negation = 10,
    sel_Conjunction = 11,
    sel_Disjunction = 12,
    sel_ExclusiveDisjunction = 13,
    sel_Implication = 14,
    sel_Equivalence = 15,
    sel_AllPath = 16,
    sel_ExPath = 17,
    sel_Always = 18,
    sel_Eventually = 19,
    sel_NextState = 20,
    sel_Until = 21,
    sel_Release = 22,
    sel_AU = 23,
    sel_EU = 24,
    sel_AR = 25,
    sel_ER = 26,
    sel_AF = 27,
    sel_EF = 28,
    sel_AG = 29,
    sel_EG = 30,
    sel_AX = 31,
    sel_EX = 32,
    sel_ConjunctionList = 33,
    sel_DisjunctionList = 34,
    sel_NiltConjunction_list = 35,
    sel_ConstConjunction_list = 36,
    sel_NiltDisjunction_list = 37,
    sel_ConstDisjunction_list = 38,
    sel_EqualsAtomicProposition = 39,
    sel_NotEqualsAtomicProposition = 40,
    sel_GreaterAtomicProposition = 41,
    sel_GreaterEqualAtomicProposition = 42,
    sel_LessAtomicProposition = 43,
    sel_LessEqualAtomicProposition = 44,
    sel_True = 45,
    sel_False = 46,
    sel_NoDeadlock = 47,
    sel_Deadlock = 48,
    sel_Initial = 49,
    sel_Fireable = 50,
    sel_Unfireable = 51,
    sel_Node = 52,
    sel_Number = 53,
    sel_Sum = 54,
    sel_Difference = 55,
    sel_Product = 56,
    sel_ProductList = 57,
    sel_NiltProduct_list = 58,
    sel_ConstProduct_list = 59,
    sel_BuechiAutomaton = 60,
    sel_BuechiNull = 61,
    sel_EmptyBuechiRules = 62,
    sel_BuechiRule = 63,
    sel_ExpandedBuechiRule = 64,
    sel_BuechiRules = 65,
    sel_EmptyTransitionRules = 66,
    sel_TransitionRule = 67,
    sel_TransitionRules = 68,
    sel_EmptyAcceptingSet = 69,
    sel_AcceptingState = 70,
    sel_AcceptingSet = 71,
    sel_Net = 72,
    sel_EmptyDefinitionsList = 73,
    sel_DefinitionsList = 74,
    sel_Constant = 75,
    sel_Sort = 76,
    sel_Function = 77,
    sel_TypeBool = 78,
    sel_TypeEnum = 79,
    sel_TypeIdent = 80,
    sel_TypeIntInterval = 81,
    sel_TypeStruct = 82,
    sel_TypeInt = 83,
    sel_TypeMultiset = 84,
    sel_TypeArray = 85,
    sel_TypeBlack = 86,
    sel_EmptyOptNumber = 87,
    sel_OptNumber = 88,
    sel_EmptyIdentList = 89,
    sel_IdentList = 90,
    sel_Idents = 91,
    sel_EmptyStructTypeList = 92,
    sel_StructTypeList = 93,
    sel_StructType = 94,
    sel_VarOrArray = 95,
    sel_EmptyArrayList = 96,
    sel_ArrayList = 97,
    sel_EmptyFunctionParametersList = 98,
    sel_FunctionParametersList = 99,
    sel_FunctionParameters = 100,
    sel_ExprLeftvalue = 101,
    sel_ExprInitializerList = 102,
    sel_AssignEqual = 103,
    sel_AssignPlus = 104,
    sel_AssignMinus = 105,
    sel_AssignTimes = 106,
    sel_AssignDivide = 107,
    sel_AssignMod = 108,
    sel_IncrementVal = 109,
    sel_DecrementVal = 110,
    sel_ValIncrement = 111,
    sel_ValDecrement = 112,
    sel_PositiveExpr = 113,
    sel_NegativeExpr = 114,
    sel_ExprAddition = 115,
    sel_ExprSubtraction = 116,
    sel_ExprMultiplication = 117,
    sel_ExprDivision = 118,
    sel_ExprModulo = 119,
    sel_ExprNumber = 120,
    sel_NotExpr = 121,
    sel_ExprAnd = 122,
    sel_ExprOr = 123,
    sel_ExprTrue = 124,
    sel_ExprFalse = 125,
    sel_ExprEquivalent = 126,
    sel_ExprNotEqual = 127,
    sel_ExprLessThan = 128,
    sel_ExprGreaterThan = 129,
    sel_ExprLessOrEqual = 130,
    sel_ExprGreaterOrEqual = 131,
    sel_FunctionCall = 132,
    sel_ExprCommaSeparated = 133,
    sel_ExprOtherIf = 134,
    sel_ExprAll = 135,
    sel_LeftValIdent = 136,
    sel_LeftValBrackets = 137,
    sel_LeftValDot = 138,
    sel_EmptyExpressionList = 139,
    sel_ExpressionList = 140,
    sel_ExprInBraces = 141,
    sel_ExprInBracesColon = 142,
    sel_EmptyExpressionListColon = 143,
    sel_ExpressionListColon = 144,
    sel_EmptyPlaceBlockList = 145,
    sel_PlaceBlockList = 146,
    sel_EmptySafe = 147,
    sel_Safe = 148,
    sel_Place = 149,
    sel_EmptyPlaceList = 150,
    sel_PlaceList = 151,
    sel_PlaceBlock = 152,
    sel_EmptyMarking = 153,
    sel_Marking = 154,
    sel_EmptyTransition = 155,
    sel_Transition = 156,
    sel_EmptyFairness = 157,
    sel_WeakFair = 158,
    sel_StrongFair = 159,
    sel_EmptyVariable = 160,
    sel_Variable = 161,
    sel_EmptyVarOrArrayList = 162,
    sel_VarOrArrayList = 163,
    sel_Guard = 164,
    sel_EmptyIdentExprList = 165,
    sel_IdentExprList = 166,
    sel_Block = 167,
    sel_EmptyDeclarationOrStatement = 168,
    sel_DeclOrStatemDeclaration = 169,
    sel_DeclOrStatemStatement = 170,
    sel_Declaration = 171,
    sel_StatementBlock = 172,
    sel_StatementExprSemicolon = 173,
    sel_StatementIf = 174,
    sel_StatementWhile = 175,
    sel_StatementDoWhile = 176,
    sel_StatementForExpr = 177,
    sel_StatementForTypeExpr = 178,
    sel_StatementForIdentColon = 179,
    sel_StatementForAll = 180,
    sel_StatementSwitch = 181,
    sel_StatementBreak = 182,
    sel_StatementContinue = 183,
    sel_StatementReturn = 184,
    sel_StatementSkip = 185,
    sel_SwitchCase = 186,
    sel_SwitchDefault = 187,
    sel_EmptySwitchCaseList = 188,
    sel_SwitchCaseList = 189,
    last_operator = 190
} enum_operators;

class impl_abstract_phylum;
typedef impl_abstract_phylum * abstract_phylum;
typedef const impl_abstract_phylum * c_abstract_phylum;
class impl_abstract_list;
typedef impl_abstract_list * abstract_list;
typedef const impl_abstract_list * c_abstract_list;

template <typename P, typename T>
P phylum_cast(T* t) {
    return static_cast<P>(t);
}
template <typename P, typename T>
const P phylum_cast(const T* t) {
    return static_cast<const P>(t);
}
class impl_nocasestring_NoCaseStr;
class impl_casestring__Str;
class impl_real__Real;
class impl_integer__Int;
class impl_voidptr__VoidPtr;
class impl_tFormula;
class impl_tStatePredicate;
class impl_tConjunction_list;
class impl_tDisjunction_list;
class impl_tAtomicProposition;
class impl_tTerm;
class impl_tProduct_list;
class impl_tBuechiAutomata;
class impl_tBuechiRules;
class impl_tTransitionRules;
class impl_tAcceptingSet;
class impl_net;
class impl_definitionsList;
class impl_definitions;
class impl_type;
class impl_optionalNumber;
class impl_identList;
class impl_idents;
class impl_structTypeList;
class impl_structType;
class impl_varOrArray;
class impl_arrayList;
class impl_functionParametersList;
class impl_functionParameters;
class impl_expression;
class impl_leftvalue;
class impl_expressionlist;
class impl_initializerList;
class impl_expressionListColon;
class impl_placeblocklist;
class impl_optSafe;
class impl_place;
class impl_placelist;
class impl_placeblock;
class impl_marking;
class impl_transition;
class impl_fairness;
class impl_variable;
class impl_varOrArrayList;
class impl_guard;
class impl_identExprList;
class impl_block;
class impl_declarationOrStatement;
class impl_declaration;
class impl_statement;
class impl_switchCase;
class impl_switchCaseList;


void kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line,
    const char *kc_file, enum_operators kc_oper ) __attribute__ ((noreturn));

typedef enum_phyla *enum_phyla_list;

/*
 * make sure that the first 'real' storage class _always_ gets a value > 0
 * and kc_not_uniq gets a value == 0
 * (because then we can use it as a C boolean)
 */
enum kc_storageclass_t {
    kc_not_uniq,
    uniq,
    last_storageclass
};

typedef struct {
    const char *name;			// name of the phylum
    enum_operators first_operator;	// index in operator_info[]
    enum_operators last_operator;	// index in operator_info[]
    kc_storageclass_t uniq_stored;	// storage class
} KC_PHYLUM_INFO;

typedef struct {
    const char *name;			// name of the operator
    size_t no_sons;			// number of sons
    bool atomicity;			// atomic type or not
    enum_phyla phylum;			// index in phylum_info[]
    enum_phyla_list subphylum;		// indexes in phylum_info[]
    int no_attrs;			// number of attributes
    enum_phyla_list attribute;		// indexes in phylum_info[]
    size_t size;			// size of operator (for statistics)
} KC_OPERATOR_INFO;

typedef enum_phyla_list KC_UNIQ_INFO;

extern KC_OPERATOR_INFO operator_info[];
extern KC_PHYLUM_INFO phylum_info[];
extern KC_UNIQ_INFO kc_UniqInfo[];

#define KC_OP_NAME(op) (operator_info[op].name)
#define KC_NO_SONS(prod) (operator_info[prod].no_sons)
#define KC_ATOMICITY(prod) (operator_info[prod].atomicity)

typedef class impl_kc_dotedgenode_t *kc_dotedgenode_t;

typedef impl_nocasestring_NoCaseStr *nocasestring;
typedef const impl_nocasestring_NoCaseStr *c_nocasestring;
typedef impl_casestring__Str *casestring;
typedef const impl_casestring__Str *c_casestring;
typedef impl_real__Real *real;
typedef const impl_real__Real *c_real;
typedef impl_integer__Int *integer;
typedef const impl_integer__Int *c_integer;
typedef impl_voidptr__VoidPtr *voidptr;
typedef const impl_voidptr__VoidPtr *c_voidptr;
typedef impl_tFormula *tFormula;
typedef const impl_tFormula *c_tFormula;
typedef impl_tStatePredicate *tStatePredicate;
typedef const impl_tStatePredicate *c_tStatePredicate;
typedef impl_tConjunction_list *tConjunction_list;
typedef const impl_tConjunction_list *c_tConjunction_list;
typedef impl_tDisjunction_list *tDisjunction_list;
typedef const impl_tDisjunction_list *c_tDisjunction_list;
typedef impl_tAtomicProposition *tAtomicProposition;
typedef const impl_tAtomicProposition *c_tAtomicProposition;
typedef impl_tTerm *tTerm;
typedef const impl_tTerm *c_tTerm;
typedef impl_tProduct_list *tProduct_list;
typedef const impl_tProduct_list *c_tProduct_list;
typedef impl_tBuechiAutomata *tBuechiAutomata;
typedef const impl_tBuechiAutomata *c_tBuechiAutomata;
typedef impl_tBuechiRules *tBuechiRules;
typedef const impl_tBuechiRules *c_tBuechiRules;
typedef impl_tTransitionRules *tTransitionRules;
typedef const impl_tTransitionRules *c_tTransitionRules;
typedef impl_tAcceptingSet *tAcceptingSet;
typedef const impl_tAcceptingSet *c_tAcceptingSet;
typedef impl_net *net;
typedef const impl_net *c_net;
typedef impl_definitionsList *definitionsList;
typedef const impl_definitionsList *c_definitionsList;
typedef impl_definitions *definitions;
typedef const impl_definitions *c_definitions;
typedef impl_type *type;
typedef const impl_type *c_type;
typedef impl_optionalNumber *optionalNumber;
typedef const impl_optionalNumber *c_optionalNumber;
typedef impl_identList *identList;
typedef const impl_identList *c_identList;
typedef impl_idents *idents;
typedef const impl_idents *c_idents;
typedef impl_structTypeList *structTypeList;
typedef const impl_structTypeList *c_structTypeList;
typedef impl_structType *structType;
typedef const impl_structType *c_structType;
typedef impl_varOrArray *varOrArray;
typedef const impl_varOrArray *c_varOrArray;
typedef impl_arrayList *arrayList;
typedef const impl_arrayList *c_arrayList;
typedef impl_functionParametersList *functionParametersList;
typedef const impl_functionParametersList *c_functionParametersList;
typedef impl_functionParameters *functionParameters;
typedef const impl_functionParameters *c_functionParameters;
typedef impl_expression *expression;
typedef const impl_expression *c_expression;
typedef impl_leftvalue *leftvalue;
typedef const impl_leftvalue *c_leftvalue;
typedef impl_expressionlist *expressionlist;
typedef const impl_expressionlist *c_expressionlist;
typedef impl_initializerList *initializerList;
typedef const impl_initializerList *c_initializerList;
typedef impl_expressionListColon *expressionListColon;
typedef const impl_expressionListColon *c_expressionListColon;
typedef impl_placeblocklist *placeblocklist;
typedef const impl_placeblocklist *c_placeblocklist;
typedef impl_optSafe *optSafe;
typedef const impl_optSafe *c_optSafe;
typedef impl_place *place;
typedef const impl_place *c_place;
typedef impl_placelist *placelist;
typedef const impl_placelist *c_placelist;
typedef impl_placeblock *placeblock;
typedef const impl_placeblock *c_placeblock;
typedef impl_marking *marking;
typedef const impl_marking *c_marking;
typedef impl_transition *transition;
typedef const impl_transition *c_transition;
typedef impl_fairness *fairness;
typedef const impl_fairness *c_fairness;
typedef impl_variable *variable;
typedef const impl_variable *c_variable;
typedef impl_varOrArrayList *varOrArrayList;
typedef const impl_varOrArrayList *c_varOrArrayList;
typedef impl_guard *guard;
typedef const impl_guard *c_guard;
typedef impl_identExprList *identExprList;
typedef const impl_identExprList *c_identExprList;
typedef impl_block *block;
typedef const impl_block *c_block;
typedef impl_declarationOrStatement *declarationOrStatement;
typedef const impl_declarationOrStatement *c_declarationOrStatement;
typedef impl_declaration *declaration;
typedef const impl_declaration *c_declaration;
typedef impl_statement *statement;
typedef const impl_statement *c_statement;
typedef impl_switchCase *switchCase;
typedef const impl_switchCase *c_switchCase;
typedef impl_switchCaseList *switchCaseList;
typedef const impl_switchCaseList *c_switchCaseList;

#define KC_NO_OF_OPERATORS 190


} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 19 "Frontend/Parser/formula_abstract.k"
#include <Core/Dimensions.h>
#include <Formula/StatePredicate/StatePredicate.h>
#include <Formula/LTL/BuechiAutomata.h>
#include <Formula/LTL/BuechiFromLTL.h>
#include <Formula/CTL/CTLFormula.h>
#include <cstring>
#include <map>
#include <string>
#include <Planning/Task.h>

// required, because the abstract grammar does not allow pointer types
typedef Task* Task_p;
typedef StatePredicate* StatePredicate_p;
typedef BuechiAutomata* BuechiAutomata_p;
typedef CTLFormula* CTLFormula_p;
typedef tl_Node* LTLTree_p;
typedef char* char_p;
typedef enum{UNDEF,BOOL,NUMB}checkName;
typedef void ** voidstar;
typedef kc::type type_t;

// don't use hash sets, since they are deprecated and unordered sets are not yet supported by Kimwitu++
#define DONT_USE_HASHSET

#line  888 "ast-system-k.h"
/* end included stuff */


namespace kc {

#ifndef KC_NO_DEFAULT_IN_WITH
# define KC_NO_DEFAULT_IN_WITH "Internal Error: no default action defined in function %s at %s:%d\n"
#endif
void kc_no_default_in_with (const char*, int, const char*);
void kc_returnless_function (const char *, int, const char*);

#ifndef NDEBUG
# define assertCond(t) do {if (!(t)) kc_assertionFailed(__FILE__,__LINE__);}while(false)
# define assertReason(t,s) do {if (!(t)) kc_assertionReasonFailed(__FILE__,__LINE__,s);}while(false)
# define assertNonNull(p) do {if (p == 0) kc_assertionNonNullFailed(__FILE__,__LINE__,#p);}while(false)
# define assertPhylum(ptr,phy) do { \
    assertNonNull(ptr); \
    if (ptr->phylum()!=phy) \
	kc_assertionOperatorInPhylumFailed(ptr->prod_sel(),#ptr,"->prod_sel()","phy",__FILE__,__LINE__); \
} while(false)
#else
# define assertCond(t)
# define assertReason(t,s)
# define assertNonNull(ptr)
# define assertPhylum(op,phy)
#endif
#define assertionFailed(s) kc_assertionReasonFailed(__FILE__,__LINE__,s)

void kc_assertionFailed (const char*, int) __attribute__ ((noreturn));
void kc_assertionReasonFailed (const char*, int, const char*) __attribute__ ((noreturn));
void kc_assertionNonNullFailed (const char*, int, const char*) __attribute__ ((noreturn));
void kc_assertionOperatorInPhylumFailed (int, const char*, const char*, const char*, const char*, int) __attribute__ ((noreturn));

casestring mkcasestring( const kc_char_t *, int length = -1);
nocasestring mknocasestring( const kc_char_t *, int length = -1);
integer mkinteger( const INTEGER );
real mkreal( const REAL );
inline casestring _Str( const kc_char_t * cc) { return mkcasestring(cc); }
inline nocasestring NoCaseStr( const kc_char_t * cc) { return mknocasestring(cc); }
inline integer _Int( const INTEGER cc) { return mkinteger(cc); }
inline real _Real( const REAL cc) { return mkreal(cc); }
class impl_tFormula_StatePredicateFormula* StatePredicateFormula (tStatePredicate);
class impl_tFormula_ComputeBound* ComputeBound (tAtomicProposition);
class impl_tFormula_Compound* Compound (tFormula, tFormula);
class impl_tStatePredicate_AtomicProposition* AtomicProposition (tAtomicProposition);
class impl_tStatePredicate_Negation* Negation (tStatePredicate);
class impl_tStatePredicate_Conjunction* Conjunction (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_Disjunction* Disjunction (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_ExclusiveDisjunction* ExclusiveDisjunction (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_Implication* Implication (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_Equivalence* Equivalence (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_AllPath* AllPath (tStatePredicate);
class impl_tStatePredicate_ExPath* ExPath (tStatePredicate);
class impl_tStatePredicate_Always* Always (tStatePredicate);
class impl_tStatePredicate_Eventually* Eventually (tStatePredicate);
class impl_tStatePredicate_NextState* NextState (tStatePredicate);
class impl_tStatePredicate_Until* Until (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_Release* Release (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_AU* AU (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_EU* EU (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_AR* AR (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_ER* ER (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_AF* AF (tStatePredicate);
class impl_tStatePredicate_EF* EF (tStatePredicate);
class impl_tStatePredicate_AG* AG (tStatePredicate);
class impl_tStatePredicate_EG* EG (tStatePredicate);
class impl_tStatePredicate_AX* AX (tStatePredicate);
class impl_tStatePredicate_EX* EX (tStatePredicate);
class impl_tStatePredicate_ConjunctionList* ConjunctionList (tConjunction_list);
class impl_tStatePredicate_DisjunctionList* DisjunctionList (tDisjunction_list);
tConjunction_list NiltConjunction_list();
tConjunction_list ConstConjunction_list(tStatePredicate,tConjunction_list);
tDisjunction_list NiltDisjunction_list();
tDisjunction_list ConstDisjunction_list(tStatePredicate,tDisjunction_list);
class impl_tAtomicProposition_EqualsAtomicProposition* EqualsAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_NotEqualsAtomicProposition* NotEqualsAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_GreaterAtomicProposition* GreaterAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_GreaterEqualAtomicProposition* GreaterEqualAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_LessAtomicProposition* LessAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_LessEqualAtomicProposition* LessEqualAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_True* True ();
class impl_tAtomicProposition_False* False ();
class impl_tAtomicProposition_NoDeadlock* NoDeadlock ();
class impl_tAtomicProposition_Deadlock* Deadlock ();
class impl_tAtomicProposition_Initial* Initial ();
class impl_tAtomicProposition_Fireable* Fireable (integer);
class impl_tAtomicProposition_Unfireable* Unfireable (integer);
class impl_tTerm_Node* Node (integer);
class impl_tTerm_Number* Number (integer);
class impl_tTerm_Sum* Sum (tTerm, tTerm);
class impl_tTerm_Difference* Difference (tTerm, tTerm);
class impl_tTerm_Product* Product (integer, tTerm);
class impl_tTerm_ProductList* ProductList (tProduct_list);
tProduct_list NiltProduct_list();
tProduct_list ConstProduct_list(tTerm,tProduct_list);
class impl_tBuechiAutomata_BuechiAutomaton* BuechiAutomaton (tBuechiRules, tAcceptingSet);
class impl_tBuechiAutomata_BuechiNull* BuechiNull ();
class impl_tBuechiRules_EmptyBuechiRules* EmptyBuechiRules ();
class impl_tBuechiRules_BuechiRule* BuechiRule (integer, tTransitionRules);
class impl_tBuechiRules_ExpandedBuechiRule* ExpandedBuechiRule (integer, tFormula, integer);
class impl_tBuechiRules_BuechiRules* BuechiRules (tBuechiRules, tBuechiRules);
class impl_tTransitionRules_EmptyTransitionRules* EmptyTransitionRules ();
class impl_tTransitionRules_TransitionRule* TransitionRule (tFormula, integer);
class impl_tTransitionRules_TransitionRules* TransitionRules (tTransitionRules, tTransitionRules);
class impl_tAcceptingSet_EmptyAcceptingSet* EmptyAcceptingSet ();
class impl_tAcceptingSet_AcceptingState* AcceptingState (integer);
class impl_tAcceptingSet_AcceptingSet* AcceptingSet (tAcceptingSet, tAcceptingSet);
class impl_net_Net* Net (casestring, definitionsList, placeblocklist, marking, transition);
class impl_definitionsList_EmptyDefinitionsList* EmptyDefinitionsList ();
class impl_definitionsList_DefinitionsList* DefinitionsList (definitionsList, definitions);
class impl_definitions_Constant* Constant (type, casestring, arrayList, expression);
class impl_definitions_Sort* Sort (type, casestring, arrayList);
class impl_definitions_Function* Function (type, casestring, arrayList, functionParametersList, block);
class impl_type_TypeBool* TypeBool ();
class impl_type_TypeEnum* TypeEnum (identList);
class impl_type_TypeIdent* TypeIdent (casestring);
class impl_type_TypeIntInterval* TypeIntInterval (expression, expression);
class impl_type_TypeStruct* TypeStruct (structTypeList);
class impl_type_TypeInt* TypeInt ();
class impl_type_TypeMultiset* TypeMultiset (type);
class impl_type_TypeArray* TypeArray (type, integer);
class impl_type_TypeBlack* TypeBlack ();
class impl_optionalNumber_EmptyOptNumber* EmptyOptNumber ();
class impl_optionalNumber_OptNumber* OptNumber (integer);
class impl_identList_EmptyIdentList* EmptyIdentList ();
class impl_identList_IdentList* IdentList (identList, idents);
class impl_idents_Idents* Idents (casestring, optionalNumber);
class impl_structTypeList_EmptyStructTypeList* EmptyStructTypeList ();
class impl_structTypeList_StructTypeList* StructTypeList (structTypeList, structType);
class impl_structType_StructType* StructType (type, casestring, arrayList);
class impl_varOrArray_VarOrArray* VarOrArray (casestring, arrayList);
class impl_arrayList_EmptyArrayList* EmptyArrayList ();
class impl_arrayList_ArrayList* ArrayList (arrayList, expression);
class impl_functionParametersList_EmptyFunctionParametersList* EmptyFunctionParametersList ();
class impl_functionParametersList_FunctionParametersList* FunctionParametersList (functionParameters, functionParametersList);
class impl_functionParameters_FunctionParameters* FunctionParameters (type, varOrArray);
class impl_expression_ExprLeftvalue* ExprLeftvalue (leftvalue);
class impl_expression_ExprInitializerList* ExprInitializerList (initializerList);
class impl_expression_AssignEqual* AssignEqual (leftvalue, expression);
class impl_expression_AssignPlus* AssignPlus (leftvalue, expression);
class impl_expression_AssignMinus* AssignMinus (leftvalue, expression);
class impl_expression_AssignTimes* AssignTimes (leftvalue, expression);
class impl_expression_AssignDivide* AssignDivide (leftvalue, expression);
class impl_expression_AssignMod* AssignMod (leftvalue, expression);
class impl_expression_IncrementVal* IncrementVal (leftvalue);
class impl_expression_DecrementVal* DecrementVal (leftvalue);
class impl_expression_ValIncrement* ValIncrement (leftvalue);
class impl_expression_ValDecrement* ValDecrement (leftvalue);
class impl_expression_PositiveExpr* PositiveExpr (expression);
class impl_expression_NegativeExpr* NegativeExpr (expression);
class impl_expression_ExprAddition* ExprAddition (expression, expression);
class impl_expression_ExprSubtraction* ExprSubtraction (expression, expression);
class impl_expression_ExprMultiplication* ExprMultiplication (expression, expression);
class impl_expression_ExprDivision* ExprDivision (expression, expression);
class impl_expression_ExprModulo* ExprModulo (expression, expression);
class impl_expression_ExprNumber* ExprNumber (integer);
class impl_expression_NotExpr* NotExpr (expression);
class impl_expression_ExprAnd* ExprAnd (expression, expression);
class impl_expression_ExprOr* ExprOr (expression, expression);
class impl_expression_ExprTrue* ExprTrue ();
class impl_expression_ExprFalse* ExprFalse ();
class impl_expression_ExprEquivalent* ExprEquivalent (expression, expression);
class impl_expression_ExprNotEqual* ExprNotEqual (expression, expression);
class impl_expression_ExprLessThan* ExprLessThan (expression, expression);
class impl_expression_ExprGreaterThan* ExprGreaterThan (expression, expression);
class impl_expression_ExprLessOrEqual* ExprLessOrEqual (expression, expression);
class impl_expression_ExprGreaterOrEqual* ExprGreaterOrEqual (expression, expression);
class impl_expression_FunctionCall* FunctionCall (casestring, expressionlist);
class impl_expression_ExprCommaSeparated* ExprCommaSeparated (expressionlist);
class impl_expression_ExprOtherIf* ExprOtherIf (expression, expression, expression);
class impl_expression_ExprAll* ExprAll (type);
class impl_leftvalue_LeftValIdent* LeftValIdent (casestring);
class impl_leftvalue_LeftValBrackets* LeftValBrackets (leftvalue, expression);
class impl_leftvalue_LeftValDot* LeftValDot (leftvalue, casestring);
class impl_expressionlist_EmptyExpressionList* EmptyExpressionList ();
class impl_expressionlist_ExpressionList* ExpressionList (expression, expressionlist);
class impl_initializerList_ExprInBraces* ExprInBraces (expressionlist);
class impl_initializerList_ExprInBracesColon* ExprInBracesColon (expression, expression, expressionListColon);
class impl_expressionListColon_EmptyExpressionListColon* EmptyExpressionListColon ();
class impl_expressionListColon_ExpressionListColon* ExpressionListColon (expression, expression, expressionListColon);
class impl_placeblocklist_EmptyPlaceBlockList* EmptyPlaceBlockList ();
class impl_placeblocklist_PlaceBlockList* PlaceBlockList (placeblock, placeblocklist);
class impl_optSafe_EmptySafe* EmptySafe ();
class impl_optSafe_Safe* Safe (integer);
class impl_place_Place* Place (casestring);
class impl_placelist_EmptyPlaceList* EmptyPlaceList ();
class impl_placelist_PlaceList* PlaceList (place, placelist);
class impl_placeblock_PlaceBlock* PlaceBlock (optSafe, type, placelist);
class impl_marking_EmptyMarking* EmptyMarking ();
class impl_marking_Marking* Marking (casestring, expression, marking);
class impl_transition_EmptyTransition* EmptyTransition ();
class impl_transition_Transition* Transition (casestring, fairness, variable, guard, identExprList, identExprList, transition);
class impl_fairness_EmptyFairness* EmptyFairness ();
class impl_fairness_WeakFair* WeakFair ();
class impl_fairness_StrongFair* StrongFair ();
class impl_variable_EmptyVariable* EmptyVariable ();
class impl_variable_Variable* Variable (type, varOrArrayList, variable);
class impl_varOrArrayList_EmptyVarOrArrayList* EmptyVarOrArrayList ();
class impl_varOrArrayList_VarOrArrayList* VarOrArrayList (varOrArray, varOrArrayList);
class impl_guard_Guard* Guard (expression);
class impl_identExprList_EmptyIdentExprList* EmptyIdentExprList ();
class impl_identExprList_IdentExprList* IdentExprList (casestring, expression, identExprList);
class impl_block_Block* Block (declarationOrStatement);
class impl_declarationOrStatement_EmptyDeclarationOrStatement* EmptyDeclarationOrStatement ();
class impl_declarationOrStatement_DeclOrStatemDeclaration* DeclOrStatemDeclaration (declaration, declarationOrStatement);
class impl_declarationOrStatement_DeclOrStatemStatement* DeclOrStatemStatement (statement, declarationOrStatement);
class impl_declaration_Declaration* Declaration (type, varOrArrayList);
class impl_statement_StatementBlock* StatementBlock (block);
class impl_statement_StatementExprSemicolon* StatementExprSemicolon (expression);
class impl_statement_StatementIf* StatementIf (expression, statement, statement);
class impl_statement_StatementWhile* StatementWhile (expression, statement);
class impl_statement_StatementDoWhile* StatementDoWhile (statement, expression);
class impl_statement_StatementForExpr* StatementForExpr (expression, expression, expression, statement);
class impl_statement_StatementForTypeExpr* StatementForTypeExpr (type, casestring, expression, expression, expression, statement);
class impl_statement_StatementForIdentColon* StatementForIdentColon (casestring, expression, statement);
class impl_statement_StatementForAll* StatementForAll (type, casestring, type);
class impl_statement_StatementSwitch* StatementSwitch (expression, switchCaseList);
class impl_statement_StatementBreak* StatementBreak ();
class impl_statement_StatementContinue* StatementContinue ();
class impl_statement_StatementReturn* StatementReturn (expression);
class impl_statement_StatementSkip* StatementSkip ();
class impl_switchCase_SwitchCase* SwitchCase (expression, statement);
class impl_switchCase_SwitchDefault* SwitchDefault (statement);
class impl_switchCaseList_EmptySwitchCaseList* EmptySwitchCaseList ();
class impl_switchCaseList_SwitchCaseList* SwitchCaseList (switchCase, switchCaseList);

//namespace Phylum {

class impl_abstract_phylum {
public:
    virtual enum_operators prod_sel() const =0;
    static const enum_phyla phylum_sel_;
    enum_phyla phylum() const;
    const char* phylum_name() const;
    const char* op_name() const;
    virtual abstract_phylum subphylum(int) const;
    virtual void set_subphylum(int, abstract_phylum);
    void free(bool recursive=true);
    bool eq(c_abstract_phylum) const;
    void print();
    void fprint(FILE *);
    abstract_phylum copy(bool kc_copy_attributes) const;
    void unparse(printer_functor pf, uview uv)
	{ do_unparse(pf, uv); }
    void unparse(printer_function opf, uview uv);

    void printdot_add_edge (c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*) const;
    void do_printdot_id (FILE*, bool, c_abstract_phylum, int) const;
    void do_printdot (FILE*, bool, int*, kc_dotedgenode_t*, const char*, bool, bool, c_abstract_phylum, int) const;

    virtual void fprintdot(FILE *,
	const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes,
	bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const =0;
    virtual abstract_phylum rewrite(rview v) { return do_rewrite(v); }
    virtual abstract_phylum do_rewrite(rview) { return this;}
    // called if a subphylum of an op is rewritten and a new op is created by default rule
    virtual void rewrite_members(abstract_phylum from) {} 
    virtual void post_create(){}
    virtual ~impl_abstract_phylum() { }
private:
    virtual void do_unparse(printer_functor, uview) =0;
protected:
    virtual void default_unparse(printer_functor, uview);
};


class impl_abstract_list: public impl_abstract_phylum{
private:
    void fprint_list(FILE *);
    friend class impl_abstract_phylum;
protected:
    abstract_phylum do_concat(c_abstract_phylum other, enum_operators) const;
    abstract_phylum do_reverse(c_abstract_phylum tail, enum_operators) const;
    abstract_phylum do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_operators);
    abstract_phylum do_filter(bool (*kc_fp)(abstract_phylum), enum_operators);
    abstract_list   do_append(abstract_phylum, abstract_list);
    abstract_phylum do_merge(abstract_list,abstract_phylum (*kc_fp)(abstract_phylum,abstract_phylum), enum_operators);
    abstract_phylum do_reduce(abstract_phylum neutral, abstract_phylum (*kc_fp)(abstract_phylum,abstract_phylum));
public:
    virtual bool is_nil() const =0;
    virtual abstract_list reverse() const =0;
    int length() const;
    abstract_phylum last() const;
    // Non-virtual, non-existing... Type must be known exactly anyway because
    // of the function given as a parameter
    //virtual abstract_list map( abstract_phylum (*)( abstract_phylum )) =0;
    //virtual abstract_list filter(bool (*)(abstract_phylum)) =0;
    void freelist();
};

abstract_phylum kc_create(enum_operators createOp, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0);
abstract_phylum kc_create(enum_operators createOp, const std::vector<abstract_phylum>& kc_ps);
abstract_phylum& attributeOf(abstract_phylum kc_p, int no);

class impl_nocasestring_NoCaseStr;
typedef impl_nocasestring_NoCaseStr impl_nocasestring;
class impl_nocasestring_NoCaseStr:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel_NoCaseStr; }
    static const enum_phyla phylum_sel_;
private:
    explicit impl_nocasestring_NoCaseStr(const kc_char_t*);
    void make_own(int length);
    friend nocasestring mknocasestring(const kc_char_t*, int);
public:
    ~impl_nocasestring_NoCaseStr() {
#if defined (_MSC_VER) && _MSC_VER<1300
	delete [] (kc_char_t*)name;
#else
	delete [] name;
#endif
    }
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    nocasestring rewrite( rview )
	{ return this; }
    kc_char_t const* name;
private:
    void do_unparse(printer_functor, uview);
};
class impl_casestring__Str;
typedef impl_casestring__Str impl_casestring;
class impl_casestring__Str:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Str; }
    static const enum_phyla phylum_sel_;
private:
    explicit impl_casestring__Str(const kc_char_t*);
    void make_own(int length);
    friend casestring mkcasestring(const kc_char_t*, int);
public:
    ~impl_casestring__Str() {
#if defined (_MSC_VER) && _MSC_VER<1300
	delete [] (kc_char_t*)name;
#else
	delete [] name;
#endif
    }
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    casestring rewrite( rview )
	{ return this; }
    kc_char_t const* name;
private:
    void do_unparse(printer_functor, uview);
};
class impl_real__Real;
typedef impl_real__Real impl_real;
class impl_real__Real:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Real; }
    static const enum_phyla phylum_sel_;
    explicit impl_real__Real(REAL _value);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    real rewrite( rview )
	{ return this; }
    REAL value;
private:
    void do_unparse(printer_functor, uview);
};
class impl_integer__Int;
typedef impl_integer__Int impl_integer;
class impl_integer__Int:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Int; }
    static const enum_phyla phylum_sel_;
    explicit impl_integer__Int(INTEGER _value);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    integer rewrite( rview )
	{ return this; }
    INTEGER value;
private:
    void do_unparse(printer_functor, uview);
};
class impl_voidptr__VoidPtr;
typedef impl_voidptr__VoidPtr impl_voidptr;
class impl_voidptr__VoidPtr:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__VoidPtr; }
    static const enum_phyla phylum_sel_;
    explicit impl_voidptr__VoidPtr(void* _pointer);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    voidptr rewrite( rview )
	{ return this; }
    void* pointer;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tFormula: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    formula_t type;
    StatePredicate_p formula;
    CTLFormula_p ctl_formula;
    LTLTree_p ltl_tree;
    bool cannotcompute;
    Task_p task;
    int containsDeadlock;
    double length;
    double number_of_or_dnf;
    double number_of_or;
    double number_of_and;
    bool only_fireable;
    tFormula rewrite(rview) =0;
};
class impl_tFormula_Compound:public impl_tFormula{
public:
    enum_operators prod_sel() const
	{ return sel_Compound; }
    explicit impl_tFormula_Compound(tFormula, tFormula);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tFormula rewrite( rview );
    impl_tFormula* tFormula_1;
    impl_tFormula* tFormula_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tFormula_ComputeBound:public impl_tFormula{
public:
    enum_operators prod_sel() const
	{ return sel_ComputeBound; }
    explicit impl_tFormula_ComputeBound(tAtomicProposition);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tFormula rewrite( rview );
    impl_tAtomicProposition* tAtomicProposition_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tFormula_StatePredicateFormula:public impl_tFormula{
public:
    enum_operators prod_sel() const
	{ return sel_StatePredicateFormula; }
    explicit impl_tFormula_StatePredicateFormula(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tFormula rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    bool containsTemporal;
    bool validCTLPathFormula;
    bool validCTLStateFormula;
    bool validLTLFormula;
    bool cannotcompute;
    Task_p task;
    int priority;
    formula_t type;
    int containsDeadlock;
    double length;
    double number_of_or_dnf;
    double number_of_or;
    double number_of_and;
    bool only_fireable;
    tStatePredicate rewrite(rview) =0;
};
class impl_tStatePredicate_DisjunctionList:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_DisjunctionList; }
    explicit impl_tStatePredicate_DisjunctionList(tDisjunction_list);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tDisjunction_list* tDisjunction_list_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_ConjunctionList:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_ConjunctionList; }
    explicit impl_tStatePredicate_ConjunctionList(tConjunction_list);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tConjunction_list* tConjunction_list_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_EX:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_EX; }
    explicit impl_tStatePredicate_EX(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AX:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AX; }
    explicit impl_tStatePredicate_AX(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_EG:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_EG; }
    explicit impl_tStatePredicate_EG(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AG:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AG; }
    explicit impl_tStatePredicate_AG(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_EF:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_EF; }
    explicit impl_tStatePredicate_EF(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AF:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AF; }
    explicit impl_tStatePredicate_AF(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_ER:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_ER; }
    explicit impl_tStatePredicate_ER(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AR:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AR; }
    explicit impl_tStatePredicate_AR(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_EU:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_EU; }
    explicit impl_tStatePredicate_EU(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AU:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AU; }
    explicit impl_tStatePredicate_AU(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Release:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Release; }
    explicit impl_tStatePredicate_Release(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Until:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Until; }
    explicit impl_tStatePredicate_Until(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_NextState:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_NextState; }
    explicit impl_tStatePredicate_NextState(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Eventually:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Eventually; }
    explicit impl_tStatePredicate_Eventually(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Always:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Always; }
    explicit impl_tStatePredicate_Always(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_ExPath:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_ExPath; }
    explicit impl_tStatePredicate_ExPath(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AllPath:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AllPath; }
    explicit impl_tStatePredicate_AllPath(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Equivalence:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Equivalence; }
    explicit impl_tStatePredicate_Equivalence(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Implication:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Implication; }
    explicit impl_tStatePredicate_Implication(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_ExclusiveDisjunction:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_ExclusiveDisjunction; }
    explicit impl_tStatePredicate_ExclusiveDisjunction(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Disjunction:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Disjunction; }
    explicit impl_tStatePredicate_Disjunction(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Conjunction:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Conjunction; }
    explicit impl_tStatePredicate_Conjunction(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Negation:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Negation; }
    explicit impl_tStatePredicate_Negation(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AtomicProposition:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AtomicProposition; }
    explicit impl_tStatePredicate_AtomicProposition(tAtomicProposition);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tAtomicProposition* tAtomicProposition_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tConjunction_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    int containsDeadlock;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltConjunction_list: sel_ConstConjunction_list;
    }
    explicit impl_tConjunction_list(tStatePredicate = 0, tConjunction_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tConjunction_list concat(c_tConjunction_list, c_tConjunction_list);
    tConjunction_list reverse() const;
    tConjunction_list rewrite(rview);
    tStatePredicate last() const;
    tConjunction_list append(tStatePredicate);
    tConjunction_list map(tStatePredicate (*)(tStatePredicate));
    tConjunction_list filter( bool (*)(tStatePredicate));
    tConjunction_list merge( tConjunction_list, tStatePredicate (*)(tStatePredicate, tStatePredicate));
    tStatePredicate reduce( tStatePredicate, tStatePredicate (*)(tStatePredicate, tStatePredicate));
    bool is_nil() const;
    tStatePredicate tStatePredicate_1;
    tConjunction_list tConjunction_list_1;
private:
    impl_tConjunction_list* nil_rewrite(rview);
    impl_tConjunction_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tDisjunction_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    int containsDeadlock;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltDisjunction_list: sel_ConstDisjunction_list;
    }
    explicit impl_tDisjunction_list(tStatePredicate = 0, tDisjunction_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tDisjunction_list concat(c_tDisjunction_list, c_tDisjunction_list);
    tDisjunction_list reverse() const;
    tDisjunction_list rewrite(rview);
    tStatePredicate last() const;
    tDisjunction_list append(tStatePredicate);
    tDisjunction_list map(tStatePredicate (*)(tStatePredicate));
    tDisjunction_list filter( bool (*)(tStatePredicate));
    tDisjunction_list merge( tDisjunction_list, tStatePredicate (*)(tStatePredicate, tStatePredicate));
    tStatePredicate reduce( tStatePredicate, tStatePredicate (*)(tStatePredicate, tStatePredicate));
    bool is_nil() const;
    tStatePredicate tStatePredicate_1;
    tDisjunction_list tDisjunction_list_1;
private:
    impl_tDisjunction_list* nil_rewrite(rview);
    impl_tDisjunction_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    bool only_fireable;
    int containsDeadlock;
    tAtomicProposition rewrite(rview) =0;
};
class impl_tAtomicProposition_Unfireable:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_Unfireable; }
    explicit impl_tAtomicProposition_Unfireable(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_Fireable:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_Fireable; }
    explicit impl_tAtomicProposition_Fireable(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_Initial:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_Initial; }
    explicit impl_tAtomicProposition_Initial();

    tAtomicProposition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_Deadlock:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_Deadlock; }
    explicit impl_tAtomicProposition_Deadlock();

    tAtomicProposition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_NoDeadlock:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_NoDeadlock; }
    explicit impl_tAtomicProposition_NoDeadlock();

    tAtomicProposition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_False:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_False; }
    explicit impl_tAtomicProposition_False();

    tAtomicProposition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_True:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_True; }
    explicit impl_tAtomicProposition_True();

    tAtomicProposition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_LessEqualAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_LessEqualAtomicProposition; }
    explicit impl_tAtomicProposition_LessEqualAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_LessAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_LessAtomicProposition; }
    explicit impl_tAtomicProposition_LessAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_GreaterEqualAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_GreaterEqualAtomicProposition; }
    explicit impl_tAtomicProposition_GreaterEqualAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_GreaterAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_GreaterAtomicProposition; }
    explicit impl_tAtomicProposition_GreaterAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_NotEqualsAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_NotEqualsAtomicProposition; }
    explicit impl_tAtomicProposition_NotEqualsAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_EqualsAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_EqualsAtomicProposition; }
    explicit impl_tAtomicProposition_EqualsAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tTerm rewrite(rview) =0;
};
class impl_tTerm_ProductList:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_ProductList; }
    explicit impl_tTerm_ProductList(tProduct_list);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_tProduct_list* tProduct_list_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm_Product:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_Product; }
    explicit impl_tTerm_Product(integer, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_integer* integer_1;
    impl_tTerm* tTerm_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm_Difference:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_Difference; }
    explicit impl_tTerm_Difference(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm_Sum:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_Sum; }
    explicit impl_tTerm_Sum(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm_Number:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_Number; }
    explicit impl_tTerm_Number(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm_Node:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_Node; }
    explicit impl_tTerm_Node(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tProduct_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltProduct_list: sel_ConstProduct_list;
    }
    explicit impl_tProduct_list(tTerm = 0, tProduct_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tProduct_list concat(c_tProduct_list, c_tProduct_list);
    tProduct_list reverse() const;
    tProduct_list rewrite(rview);
    tTerm last() const;
    tProduct_list append(tTerm);
    tProduct_list map(tTerm (*)(tTerm));
    tProduct_list filter( bool (*)(tTerm));
    tProduct_list merge( tProduct_list, tTerm (*)(tTerm, tTerm));
    tTerm reduce( tTerm, tTerm (*)(tTerm, tTerm));
    bool is_nil() const;
    tTerm tTerm_1;
    tProduct_list tProduct_list_1;
private:
    impl_tProduct_list* nil_rewrite(rview);
    impl_tProduct_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiAutomata: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    BuechiAutomata_p automata;
    tBuechiAutomata rewrite(rview) =0;
};
class impl_tBuechiAutomata_BuechiNull:public impl_tBuechiAutomata{
public:
    enum_operators prod_sel() const
	{ return sel_BuechiNull; }
    explicit impl_tBuechiAutomata_BuechiNull();

    tBuechiAutomata rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiAutomata_BuechiAutomaton:public impl_tBuechiAutomata{
public:
    enum_operators prod_sel() const
	{ return sel_BuechiAutomaton; }
    explicit impl_tBuechiAutomata_BuechiAutomaton(tBuechiRules, tAcceptingSet);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tBuechiAutomata rewrite( rview );
    impl_tBuechiRules* tBuechiRules_1;
    impl_tAcceptingSet* tAcceptingSet_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiRules: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tBuechiRules rewrite(rview) =0;
};
class impl_tBuechiRules_BuechiRules:public impl_tBuechiRules{
public:
    enum_operators prod_sel() const
	{ return sel_BuechiRules; }
    explicit impl_tBuechiRules_BuechiRules(tBuechiRules, tBuechiRules);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tBuechiRules rewrite( rview );
    impl_tBuechiRules* tBuechiRules_1;
    impl_tBuechiRules* tBuechiRules_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiRules_ExpandedBuechiRule:public impl_tBuechiRules{
public:
    enum_operators prod_sel() const
	{ return sel_ExpandedBuechiRule; }
    explicit impl_tBuechiRules_ExpandedBuechiRule(integer, tFormula, integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tBuechiRules rewrite( rview );
    impl_integer* integer_1;
    impl_tFormula* tFormula_1;
    impl_integer* integer_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiRules_BuechiRule:public impl_tBuechiRules{
public:
    enum_operators prod_sel() const
	{ return sel_BuechiRule; }
    explicit impl_tBuechiRules_BuechiRule(integer, tTransitionRules);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tBuechiRules rewrite( rview );
    impl_integer* integer_1;
    impl_tTransitionRules* tTransitionRules_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiRules_EmptyBuechiRules:public impl_tBuechiRules{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyBuechiRules; }
    explicit impl_tBuechiRules_EmptyBuechiRules();

    tBuechiRules rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTransitionRules: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tTransitionRules rewrite(rview) =0;
};
class impl_tTransitionRules_TransitionRules:public impl_tTransitionRules{
public:
    enum_operators prod_sel() const
	{ return sel_TransitionRules; }
    explicit impl_tTransitionRules_TransitionRules(tTransitionRules, tTransitionRules);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTransitionRules rewrite( rview );
    impl_tTransitionRules* tTransitionRules_1;
    impl_tTransitionRules* tTransitionRules_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTransitionRules_TransitionRule:public impl_tTransitionRules{
public:
    enum_operators prod_sel() const
	{ return sel_TransitionRule; }
    explicit impl_tTransitionRules_TransitionRule(tFormula, integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTransitionRules rewrite( rview );
    impl_tFormula* tFormula_1;
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTransitionRules_EmptyTransitionRules:public impl_tTransitionRules{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyTransitionRules; }
    explicit impl_tTransitionRules_EmptyTransitionRules();

    tTransitionRules rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAcceptingSet: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tAcceptingSet rewrite(rview) =0;
};
class impl_tAcceptingSet_AcceptingSet:public impl_tAcceptingSet{
public:
    enum_operators prod_sel() const
	{ return sel_AcceptingSet; }
    explicit impl_tAcceptingSet_AcceptingSet(tAcceptingSet, tAcceptingSet);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAcceptingSet rewrite( rview );
    impl_tAcceptingSet* tAcceptingSet_1;
    impl_tAcceptingSet* tAcceptingSet_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAcceptingSet_AcceptingState:public impl_tAcceptingSet{
public:
    enum_operators prod_sel() const
	{ return sel_AcceptingState; }
    explicit impl_tAcceptingSet_AcceptingState(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAcceptingSet rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAcceptingSet_EmptyAcceptingSet:public impl_tAcceptingSet{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyAcceptingSet; }
    explicit impl_tAcceptingSet_EmptyAcceptingSet();

    tAcceptingSet rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_net: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    net rewrite(rview) =0;
};
class impl_net_Net:public impl_net{
public:
    enum_operators prod_sel() const
	{ return sel_Net; }
    explicit impl_net_Net(casestring, definitionsList, placeblocklist, marking, transition);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    net rewrite( rview );
    impl_casestring* casestring_1;
    impl_definitionsList* definitionsList_1;
    impl_placeblocklist* placeblocklist_1;
    impl_marking* marking_1;
    impl_transition* transition_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_definitionsList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    definitionsList rewrite(rview) =0;
};
class impl_definitionsList_DefinitionsList:public impl_definitionsList{
public:
    enum_operators prod_sel() const
	{ return sel_DefinitionsList; }
    explicit impl_definitionsList_DefinitionsList(definitionsList, definitions);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    definitionsList rewrite( rview );
    impl_definitionsList* definitionsList_1;
    impl_definitions* definitions_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_definitionsList_EmptyDefinitionsList:public impl_definitionsList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyDefinitionsList; }
    explicit impl_definitionsList_EmptyDefinitionsList();

    definitionsList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_definitions: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    definitions rewrite(rview) =0;
};
class impl_definitions_Function:public impl_definitions{
public:
    enum_operators prod_sel() const
	{ return sel_Function; }
    explicit impl_definitions_Function(type, casestring, arrayList, functionParametersList, block);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    definitions rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_arrayList* arrayList_1;
    impl_functionParametersList* functionParametersList_1;
    impl_block* block_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_definitions_Sort:public impl_definitions{
public:
    enum_operators prod_sel() const
	{ return sel_Sort; }
    explicit impl_definitions_Sort(type, casestring, arrayList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    definitions rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_arrayList* arrayList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_definitions_Constant:public impl_definitions{
public:
    enum_operators prod_sel() const
	{ return sel_Constant; }
    explicit impl_definitions_Constant(type, casestring, arrayList, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    definitions rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_arrayList* arrayList_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    bool is_finite;
    bool is_scalar;
    arrayindex_t size;
    type rewrite(rview) =0;
};
class impl_type_TypeBlack:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeBlack; }
    explicit impl_type_TypeBlack();

    type rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeArray:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeArray; }
    explicit impl_type_TypeArray(type, integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type rewrite( rview );
    impl_type* type_1;
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeMultiset:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeMultiset; }
    explicit impl_type_TypeMultiset(type);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type rewrite( rview );
    impl_type* type_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeInt:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeInt; }
    explicit impl_type_TypeInt();

    type rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeStruct:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeStruct; }
    explicit impl_type_TypeStruct(structTypeList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type rewrite( rview );
    impl_structTypeList* structTypeList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeIntInterval:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeIntInterval; }
    explicit impl_type_TypeIntInterval(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeIdent:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeIdent; }
    explicit impl_type_TypeIdent(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeEnum:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeEnum; }
    explicit impl_type_TypeEnum(identList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type rewrite( rview );
    impl_identList* identList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeBool:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeBool; }
    explicit impl_type_TypeBool();

    type rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_optionalNumber: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    arrayindex_t value;
    bool set;
    optionalNumber rewrite(rview) =0;
};
class impl_optionalNumber_OptNumber:public impl_optionalNumber{
public:
    enum_operators prod_sel() const
	{ return sel_OptNumber; }
    explicit impl_optionalNumber_OptNumber(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    optionalNumber rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optionalNumber_EmptyOptNumber:public impl_optionalNumber{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyOptNumber; }
    explicit impl_optionalNumber_EmptyOptNumber();

    optionalNumber rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_identList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    arrayindex_t maxvalue;
    arrayindex_t nrvalues;
    identList rewrite(rview) =0;
};
class impl_identList_IdentList:public impl_identList{
public:
    enum_operators prod_sel() const
	{ return sel_IdentList; }
    explicit impl_identList_IdentList(identList, idents);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    identList rewrite( rview );
    impl_identList* identList_1;
    impl_idents* idents_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_identList_EmptyIdentList:public impl_identList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyIdentList; }
    explicit impl_identList_EmptyIdentList();

    identList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_idents: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    arrayindex_t value;
    bool set;
    idents rewrite(rview) =0;
};
class impl_idents_Idents:public impl_idents{
public:
    enum_operators prod_sel() const
	{ return sel_Idents; }
    explicit impl_idents_Idents(casestring, optionalNumber);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    idents rewrite( rview );
    impl_casestring* casestring_1;
    impl_optionalNumber* optionalNumber_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_structTypeList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    bool is_finite;
    arrayindex_t size;
    arrayindex_t nrcomponents;
    structTypeList rewrite(rview) =0;
};
class impl_structTypeList_StructTypeList:public impl_structTypeList{
public:
    enum_operators prod_sel() const
	{ return sel_StructTypeList; }
    explicit impl_structTypeList_StructTypeList(structTypeList, structType);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    structTypeList rewrite( rview );
    impl_structTypeList* structTypeList_1;
    impl_structType* structType_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_structTypeList_EmptyStructTypeList:public impl_structTypeList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyStructTypeList; }
    explicit impl_structTypeList_EmptyStructTypeList();

    structTypeList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_structType: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    bool is_finite;
    bool is_scalar;
    arrayindex_t size;
    structType rewrite(rview) =0;
};
class impl_structType_StructType:public impl_structType{
public:
    enum_operators prod_sel() const
	{ return sel_StructType; }
    explicit impl_structType_StructType(type, casestring, arrayList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    structType rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_arrayList* arrayList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_varOrArray: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    type_t inherited_type;
    type_t type;
    arrayindex_t nrdimensions;
    arrayindex_t nrelements;
    varOrArray rewrite(rview) =0;
};
class impl_varOrArray_VarOrArray:public impl_varOrArray{
public:
    enum_operators prod_sel() const
	{ return sel_VarOrArray; }
    explicit impl_varOrArray_VarOrArray(casestring, arrayList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    varOrArray rewrite( rview );
    impl_casestring* casestring_1;
    impl_arrayList* arrayList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arrayList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    type_t inherited_type;
    arrayindex_t nrdimensions;
    arrayindex_t nrelements;
    type_t type;
    arrayList rewrite(rview) =0;
};
class impl_arrayList_ArrayList:public impl_arrayList{
public:
    enum_operators prod_sel() const
	{ return sel_ArrayList; }
    explicit impl_arrayList_ArrayList(arrayList, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arrayList rewrite( rview );
    impl_arrayList* arrayList_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arrayList_EmptyArrayList:public impl_arrayList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyArrayList; }
    explicit impl_arrayList_EmptyArrayList();

    arrayList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_functionParametersList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    functionParametersList rewrite(rview) =0;
};
class impl_functionParametersList_FunctionParametersList:public impl_functionParametersList{
public:
    enum_operators prod_sel() const
	{ return sel_FunctionParametersList; }
    explicit impl_functionParametersList_FunctionParametersList(functionParameters, functionParametersList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    functionParametersList rewrite( rview );
    impl_functionParameters* functionParameters_1;
    impl_functionParametersList* functionParametersList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_functionParametersList_EmptyFunctionParametersList:public impl_functionParametersList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyFunctionParametersList; }
    explicit impl_functionParametersList_EmptyFunctionParametersList();

    functionParametersList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_functionParameters: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    functionParameters rewrite(rview) =0;
};
class impl_functionParameters_FunctionParameters:public impl_functionParameters{
public:
    enum_operators prod_sel() const
	{ return sel_FunctionParameters; }
    explicit impl_functionParameters_FunctionParameters(type, varOrArray);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    functionParameters rewrite( rview );
    impl_type* type_1;
    impl_varOrArray* varOrArray_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    bool is_constant;
    voidstar value;
    bool is_scalar;
    expression rewrite(rview) =0;
};
class impl_expression_ExprAll:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprAll; }
    explicit impl_expression_ExprAll(type);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_type* type_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprOtherIf:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprOtherIf; }
    explicit impl_expression_ExprOtherIf(expression, expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
    impl_expression* expression_3;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprCommaSeparated:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprCommaSeparated; }
    explicit impl_expression_ExprCommaSeparated(expressionlist);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expressionlist* expressionlist_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_FunctionCall:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_FunctionCall; }
    explicit impl_expression_FunctionCall(casestring, expressionlist);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_casestring* casestring_1;
    impl_expressionlist* expressionlist_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprGreaterOrEqual:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprGreaterOrEqual; }
    explicit impl_expression_ExprGreaterOrEqual(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprLessOrEqual:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprLessOrEqual; }
    explicit impl_expression_ExprLessOrEqual(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprGreaterThan:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprGreaterThan; }
    explicit impl_expression_ExprGreaterThan(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprLessThan:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprLessThan; }
    explicit impl_expression_ExprLessThan(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprNotEqual:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprNotEqual; }
    explicit impl_expression_ExprNotEqual(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprEquivalent:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprEquivalent; }
    explicit impl_expression_ExprEquivalent(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprFalse:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprFalse; }
    explicit impl_expression_ExprFalse();

    expression rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprTrue:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprTrue; }
    explicit impl_expression_ExprTrue();

    expression rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprOr:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprOr; }
    explicit impl_expression_ExprOr(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprAnd:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprAnd; }
    explicit impl_expression_ExprAnd(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_NotExpr:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_NotExpr; }
    explicit impl_expression_NotExpr(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprNumber:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprNumber; }
    explicit impl_expression_ExprNumber(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprModulo:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprModulo; }
    explicit impl_expression_ExprModulo(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprDivision:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprDivision; }
    explicit impl_expression_ExprDivision(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprMultiplication:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprMultiplication; }
    explicit impl_expression_ExprMultiplication(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprSubtraction:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprSubtraction; }
    explicit impl_expression_ExprSubtraction(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprAddition:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprAddition; }
    explicit impl_expression_ExprAddition(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_NegativeExpr:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_NegativeExpr; }
    explicit impl_expression_NegativeExpr(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_PositiveExpr:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_PositiveExpr; }
    explicit impl_expression_PositiveExpr(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ValDecrement:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ValDecrement; }
    explicit impl_expression_ValDecrement(leftvalue);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ValIncrement:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ValIncrement; }
    explicit impl_expression_ValIncrement(leftvalue);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_DecrementVal:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_DecrementVal; }
    explicit impl_expression_DecrementVal(leftvalue);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_IncrementVal:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_IncrementVal; }
    explicit impl_expression_IncrementVal(leftvalue);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_AssignMod:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_AssignMod; }
    explicit impl_expression_AssignMod(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_AssignDivide:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_AssignDivide; }
    explicit impl_expression_AssignDivide(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_AssignTimes:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_AssignTimes; }
    explicit impl_expression_AssignTimes(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_AssignMinus:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_AssignMinus; }
    explicit impl_expression_AssignMinus(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_AssignPlus:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_AssignPlus; }
    explicit impl_expression_AssignPlus(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_AssignEqual:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_AssignEqual; }
    explicit impl_expression_AssignEqual(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprInitializerList:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprInitializerList; }
    explicit impl_expression_ExprInitializerList(initializerList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_initializerList* initializerList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprLeftvalue:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprLeftvalue; }
    explicit impl_expression_ExprLeftvalue(leftvalue);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_leftvalue: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    leftvalue rewrite(rview) =0;
};
class impl_leftvalue_LeftValDot:public impl_leftvalue{
public:
    enum_operators prod_sel() const
	{ return sel_LeftValDot; }
    explicit impl_leftvalue_LeftValDot(leftvalue, casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    leftvalue rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_leftvalue_LeftValBrackets:public impl_leftvalue{
public:
    enum_operators prod_sel() const
	{ return sel_LeftValBrackets; }
    explicit impl_leftvalue_LeftValBrackets(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    leftvalue rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_leftvalue_LeftValIdent:public impl_leftvalue{
public:
    enum_operators prod_sel() const
	{ return sel_LeftValIdent; }
    explicit impl_leftvalue_LeftValIdent(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    leftvalue rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionlist: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    expressionlist rewrite(rview) =0;
};
class impl_expressionlist_ExpressionList:public impl_expressionlist{
public:
    enum_operators prod_sel() const
	{ return sel_ExpressionList; }
    explicit impl_expressionlist_ExpressionList(expression, expressionlist);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expressionlist rewrite( rview );
    impl_expression* expression_1;
    impl_expressionlist* expressionlist_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionlist_EmptyExpressionList:public impl_expressionlist{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyExpressionList; }
    explicit impl_expressionlist_EmptyExpressionList();

    expressionlist rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_initializerList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    initializerList rewrite(rview) =0;
};
class impl_initializerList_ExprInBracesColon:public impl_initializerList{
public:
    enum_operators prod_sel() const
	{ return sel_ExprInBracesColon; }
    explicit impl_initializerList_ExprInBracesColon(expression, expression, expressionListColon);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    initializerList rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
    impl_expressionListColon* expressionListColon_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_initializerList_ExprInBraces:public impl_initializerList{
public:
    enum_operators prod_sel() const
	{ return sel_ExprInBraces; }
    explicit impl_initializerList_ExprInBraces(expressionlist);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    initializerList rewrite( rview );
    impl_expressionlist* expressionlist_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionListColon: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    expressionListColon rewrite(rview) =0;
};
class impl_expressionListColon_ExpressionListColon:public impl_expressionListColon{
public:
    enum_operators prod_sel() const
	{ return sel_ExpressionListColon; }
    explicit impl_expressionListColon_ExpressionListColon(expression, expression, expressionListColon);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expressionListColon rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
    impl_expressionListColon* expressionListColon_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionListColon_EmptyExpressionListColon:public impl_expressionListColon{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyExpressionListColon; }
    explicit impl_expressionListColon_EmptyExpressionListColon();

    expressionListColon rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_placeblocklist: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    placeblocklist rewrite(rview) =0;
};
class impl_placeblocklist_PlaceBlockList:public impl_placeblocklist{
public:
    enum_operators prod_sel() const
	{ return sel_PlaceBlockList; }
    explicit impl_placeblocklist_PlaceBlockList(placeblock, placeblocklist);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    placeblocklist rewrite( rview );
    impl_placeblock* placeblock_1;
    impl_placeblocklist* placeblocklist_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_placeblocklist_EmptyPlaceBlockList:public impl_placeblocklist{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyPlaceBlockList; }
    explicit impl_placeblocklist_EmptyPlaceBlockList();

    placeblocklist rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_optSafe: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    optSafe rewrite(rview) =0;
};
class impl_optSafe_Safe:public impl_optSafe{
public:
    enum_operators prod_sel() const
	{ return sel_Safe; }
    explicit impl_optSafe_Safe(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    optSafe rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optSafe_EmptySafe:public impl_optSafe{
public:
    enum_operators prod_sel() const
	{ return sel_EmptySafe; }
    explicit impl_optSafe_EmptySafe();

    optSafe rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_place: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    place rewrite(rview) =0;
};
class impl_place_Place:public impl_place{
public:
    enum_operators prod_sel() const
	{ return sel_Place; }
    explicit impl_place_Place(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    place rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_placelist: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    placelist rewrite(rview) =0;
};
class impl_placelist_PlaceList:public impl_placelist{
public:
    enum_operators prod_sel() const
	{ return sel_PlaceList; }
    explicit impl_placelist_PlaceList(place, placelist);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    placelist rewrite( rview );
    impl_place* place_1;
    impl_placelist* placelist_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_placelist_EmptyPlaceList:public impl_placelist{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyPlaceList; }
    explicit impl_placelist_EmptyPlaceList();

    placelist rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_placeblock: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    placeblock rewrite(rview) =0;
};
class impl_placeblock_PlaceBlock:public impl_placeblock{
public:
    enum_operators prod_sel() const
	{ return sel_PlaceBlock; }
    explicit impl_placeblock_PlaceBlock(optSafe, type, placelist);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    placeblock rewrite( rview );
    impl_optSafe* optSafe_1;
    impl_type* type_1;
    impl_placelist* placelist_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_marking: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    marking rewrite(rview) =0;
};
class impl_marking_Marking:public impl_marking{
public:
    enum_operators prod_sel() const
	{ return sel_Marking; }
    explicit impl_marking_Marking(casestring, expression, marking);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    marking rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression* expression_1;
    impl_marking* marking_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_marking_EmptyMarking:public impl_marking{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyMarking; }
    explicit impl_marking_EmptyMarking();

    marking rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_transition: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    transition rewrite(rview) =0;
};
class impl_transition_Transition:public impl_transition{
public:
    enum_operators prod_sel() const
	{ return sel_Transition; }
    explicit impl_transition_Transition(casestring, fairness, variable, guard, identExprList, identExprList, transition);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    transition rewrite( rview );
    impl_casestring* casestring_1;
    impl_fairness* fairness_1;
    impl_variable* variable_1;
    impl_guard* guard_1;
    impl_identExprList* identExprList_1;
    impl_identExprList* identExprList_2;
    impl_transition* transition_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_transition_EmptyTransition:public impl_transition{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyTransition; }
    explicit impl_transition_EmptyTransition();

    transition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_fairness: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    fairness rewrite(rview) =0;
};
class impl_fairness_StrongFair:public impl_fairness{
public:
    enum_operators prod_sel() const
	{ return sel_StrongFair; }
    explicit impl_fairness_StrongFair();

    fairness rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_fairness_WeakFair:public impl_fairness{
public:
    enum_operators prod_sel() const
	{ return sel_WeakFair; }
    explicit impl_fairness_WeakFair();

    fairness rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_fairness_EmptyFairness:public impl_fairness{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyFairness; }
    explicit impl_fairness_EmptyFairness();

    fairness rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_variable: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    variable rewrite(rview) =0;
};
class impl_variable_Variable:public impl_variable{
public:
    enum_operators prod_sel() const
	{ return sel_Variable; }
    explicit impl_variable_Variable(type, varOrArrayList, variable);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    variable rewrite( rview );
    impl_type* type_1;
    impl_varOrArrayList* varOrArrayList_1;
    impl_variable* variable_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_variable_EmptyVariable:public impl_variable{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyVariable; }
    explicit impl_variable_EmptyVariable();

    variable rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_varOrArrayList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    type_t inherited_type;
    type_t type;
    varOrArrayList rewrite(rview) =0;
};
class impl_varOrArrayList_VarOrArrayList:public impl_varOrArrayList{
public:
    enum_operators prod_sel() const
	{ return sel_VarOrArrayList; }
    explicit impl_varOrArrayList_VarOrArrayList(varOrArray, varOrArrayList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    varOrArrayList rewrite( rview );
    impl_varOrArray* varOrArray_1;
    impl_varOrArrayList* varOrArrayList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_varOrArrayList_EmptyVarOrArrayList:public impl_varOrArrayList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyVarOrArrayList; }
    explicit impl_varOrArrayList_EmptyVarOrArrayList();

    varOrArrayList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_guard: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    guard rewrite(rview) =0;
};
class impl_guard_Guard:public impl_guard{
public:
    enum_operators prod_sel() const
	{ return sel_Guard; }
    explicit impl_guard_Guard(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    guard rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_identExprList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    identExprList rewrite(rview) =0;
};
class impl_identExprList_IdentExprList:public impl_identExprList{
public:
    enum_operators prod_sel() const
	{ return sel_IdentExprList; }
    explicit impl_identExprList_IdentExprList(casestring, expression, identExprList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    identExprList rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression* expression_1;
    impl_identExprList* identExprList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_identExprList_EmptyIdentExprList:public impl_identExprList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyIdentExprList; }
    explicit impl_identExprList_EmptyIdentExprList();

    identExprList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_block: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    block rewrite(rview) =0;
};
class impl_block_Block:public impl_block{
public:
    enum_operators prod_sel() const
	{ return sel_Block; }
    explicit impl_block_Block(declarationOrStatement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    block rewrite( rview );
    impl_declarationOrStatement* declarationOrStatement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_declarationOrStatement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    declarationOrStatement rewrite(rview) =0;
};
class impl_declarationOrStatement_DeclOrStatemStatement:public impl_declarationOrStatement{
public:
    enum_operators prod_sel() const
	{ return sel_DeclOrStatemStatement; }
    explicit impl_declarationOrStatement_DeclOrStatemStatement(statement, declarationOrStatement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    declarationOrStatement rewrite( rview );
    impl_statement* statement_1;
    impl_declarationOrStatement* declarationOrStatement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_declarationOrStatement_DeclOrStatemDeclaration:public impl_declarationOrStatement{
public:
    enum_operators prod_sel() const
	{ return sel_DeclOrStatemDeclaration; }
    explicit impl_declarationOrStatement_DeclOrStatemDeclaration(declaration, declarationOrStatement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    declarationOrStatement rewrite( rview );
    impl_declaration* declaration_1;
    impl_declarationOrStatement* declarationOrStatement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_declarationOrStatement_EmptyDeclarationOrStatement:public impl_declarationOrStatement{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyDeclarationOrStatement; }
    explicit impl_declarationOrStatement_EmptyDeclarationOrStatement();

    declarationOrStatement rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_declaration: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    declaration rewrite(rview) =0;
};
class impl_declaration_Declaration:public impl_declaration{
public:
    enum_operators prod_sel() const
	{ return sel_Declaration; }
    explicit impl_declaration_Declaration(type, varOrArrayList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    declaration rewrite( rview );
    impl_type* type_1;
    impl_varOrArrayList* varOrArrayList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    statement rewrite(rview) =0;
};
class impl_statement_StatementSkip:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementSkip; }
    explicit impl_statement_StatementSkip();

    statement rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementReturn:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementReturn; }
    explicit impl_statement_StatementReturn(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementContinue:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementContinue; }
    explicit impl_statement_StatementContinue();

    statement rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementBreak:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementBreak; }
    explicit impl_statement_StatementBreak();

    statement rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementSwitch:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementSwitch; }
    explicit impl_statement_StatementSwitch(expression, switchCaseList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_expression* expression_1;
    impl_switchCaseList* switchCaseList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementForAll:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementForAll; }
    explicit impl_statement_StatementForAll(type, casestring, type);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_type* type_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementForIdentColon:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementForIdentColon; }
    explicit impl_statement_StatementForIdentColon(casestring, expression, statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression* expression_1;
    impl_statement* statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementForTypeExpr:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementForTypeExpr; }
    explicit impl_statement_StatementForTypeExpr(type, casestring, expression, expression, expression, statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_expression* expression_1;
    impl_expression* expression_2;
    impl_expression* expression_3;
    impl_statement* statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementForExpr:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementForExpr; }
    explicit impl_statement_StatementForExpr(expression, expression, expression, statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
    impl_expression* expression_3;
    impl_statement* statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementDoWhile:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementDoWhile; }
    explicit impl_statement_StatementDoWhile(statement, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_statement* statement_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementWhile:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementWhile; }
    explicit impl_statement_StatementWhile(expression, statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_expression* expression_1;
    impl_statement* statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementIf:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementIf; }
    explicit impl_statement_StatementIf(expression, statement, statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_expression* expression_1;
    impl_statement* statement_1;
    impl_statement* statement_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementExprSemicolon:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementExprSemicolon; }
    explicit impl_statement_StatementExprSemicolon(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementBlock:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementBlock; }
    explicit impl_statement_StatementBlock(block);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_block* block_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_switchCase: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    switchCase rewrite(rview) =0;
};
class impl_switchCase_SwitchDefault:public impl_switchCase{
public:
    enum_operators prod_sel() const
	{ return sel_SwitchDefault; }
    explicit impl_switchCase_SwitchDefault(statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    switchCase rewrite( rview );
    impl_statement* statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_switchCase_SwitchCase:public impl_switchCase{
public:
    enum_operators prod_sel() const
	{ return sel_SwitchCase; }
    explicit impl_switchCase_SwitchCase(expression, statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    switchCase rewrite( rview );
    impl_expression* expression_1;
    impl_statement* statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_switchCaseList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    switchCaseList rewrite(rview) =0;
};
class impl_switchCaseList_SwitchCaseList:public impl_switchCaseList{
public:
    enum_operators prod_sel() const
	{ return sel_SwitchCaseList; }
    explicit impl_switchCaseList_SwitchCaseList(switchCase, switchCaseList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    switchCaseList rewrite( rview );
    impl_switchCase* switchCase_1;
    impl_switchCaseList* switchCaseList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_switchCaseList_EmptySwitchCaseList:public impl_switchCaseList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptySwitchCaseList; }
    explicit impl_switchCaseList_EmptySwitchCaseList();

    switchCaseList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};

//} // namespace Phylum


extern bool kc_storageclass_still_uniq[];

typedef struct {
    int created;
    int existing_not_found;
    int free_called[2];
    int freed[2];
} KC_OPERATOR_STATISTICS;

#ifdef KC_STATISTICS
# define print_operator_statistics(kc_f) do_print_operator_statistics(kc_f)
void	do_print_operator_statistics(FILE*);
#else
# define print_operator_statistics(kc_f)
#endif

typedef class hashtable_struct_t* hashtable_t;
void	ht_static (kc_storageclass_t);
void	ht_dynamic (kc_storageclass_t);
void	ht_inc_level (kc_storageclass_t);
void	ht_dec_level (kc_storageclass_t);
void	ht_free_level (kc_storageclass_t);
hashtable_t	ht_create_simple ();
hashtable_t	ht_assign (hashtable_t, kc_storageclass_t, bool still_unique=false);
hashtable_t	ht_assigned (kc_storageclass_t);
void	ht_clear (hashtable_t);
void	ht_delete (hashtable_t);
const char *phylumname_or_error ( enum_phyla );
const char *kc_operatorname_or_error ( enum_operators );


void fprintdotprologue ( FILE* );
void fprintdotepilogue ( FILE* );

} // namespace kc
#endif // KC_TYPES_HEADER
