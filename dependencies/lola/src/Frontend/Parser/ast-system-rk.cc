/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#define KC_REWRITE

#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include "ast-system-k.h"
#include "ast-system-rk.h"


namespace kc {
base_rview_class base_rview;
goodbye_doublearrows_class goodbye_doublearrows;
goodbye_singlearrows_class goodbye_singlearrows;
goodbye_xor_class goodbye_xor;
goodbye_fireable_class goodbye_fireable;
goodbye_unfireable_class goodbye_unfireable;
goodbye_initial_class goodbye_initial;
sides_class sides;
productlists_class productlists;
leq_class leq;
tautology_class tautology;
emptyquantifiers_class emptyquantifiers;
singletemporal_class singletemporal;
simpleneg_class simpleneg;
booleanlists_class booleanlists;
ctloperators_class ctloperators;
rbuechi_class rbuechi;
dnf_class dnf;
simpletautology_class simpletautology;

impl_rviews rviews[] = {
    {"base_rview",&base_rview},
    {"goodbye_doublearrows",&goodbye_doublearrows},
    {"goodbye_singlearrows",&goodbye_singlearrows},
    {"goodbye_xor",&goodbye_xor},
    {"goodbye_fireable",&goodbye_fireable},
    {"goodbye_unfireable",&goodbye_unfireable},
    {"goodbye_initial",&goodbye_initial},
    {"sides",&sides},
    {"productlists",&productlists},
    {"leq",&leq},
    {"tautology",&tautology},
    {"emptyquantifiers",&emptyquantifiers},
    {"singletemporal",&singletemporal},
    {"simpleneg",&simpleneg},
    {"booleanlists",&booleanlists},
    {"ctloperators",&ctloperators},
    {"rbuechi",&rbuechi},
    {"dnf",&dnf},
    {"simpletautology",&simpletautology},
    {0,0}
};

} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 24 "Frontend/Parser/formula_rewrite.k"
#include <Frontend/Parser/ast-system-rk.h>
#include <CoverGraph/CoverGraph.h>
#include <Net/Marking.h>
#include <Net/Net.h>

/*
Uncomment the next line to define a debug function that traces all matches in
the rewriting process.
*/
//#define KC_TRACE_REWRITE_RESULT(VIEW,FILE,LINE,NODE) { RT::rep->status("rewrite %s:%d", FILE, LINE); }

/*!
Count the rule applications
*/
size_t rule_applications = 0;
#define KC_TRACE_REWRITE_MATCH(VIEW,FILE,LINE,NODE) { ++rule_applications; }

integer plus( integer a, integer b ) {
    // +-----+-----+-----+-----+
    // |   + |   y |  oo | -oo |
    // +-----+-----+-----+-----+
    // |   x | x+y |  oo | -oo |
    // |  oo |  oo |  oo | n.d.|
    // | -oo | -oo | n.d.| -oo |
    // +-----+-----+-----+-----+

    // exclude undefinied behavior
    if(  (a->value == -OMEGA and b->value == OMEGA) ||
	    (a->value == OMEGA and b->value == -OMEGA))
    {
	RT::rep->status("error in formula: invalid addition of oo or appearance of oo on both sides of a comparison");
	RT::rep->abort(ERROR_SYNTAX);
    }

    if (a->value == OMEGA or b->value == OMEGA)
    {
	return mkinteger(OMEGA);
    }

    if (a->value == -OMEGA or b->value == -OMEGA)
    {
	return mkinteger(-OMEGA);
    }

    return mkinteger( a->value + b->value );
}

integer minus( integer a, integer b ) {
    // +-----+-----+-----+-----+
    // |   - |   y |  oo | -oo |
    // +-----+-----+-----+-----+
    // |   x | x-y | -oo |  oo |
    // |  oo |  oo | n.d.|  oo |
    // | -oo | -oo | -oo | n.d.|
    // +-----+-----+-----+-----+

    // exclude undefinied behavior
    if(  (a->value == OMEGA and b->value == OMEGA) ||
	    (a->value == -OMEGA and b->value == -OMEGA))
    {
	RT::rep->status("error in formula: invalid subtraction of oo or appearance of oo on both sides of a comparison");
	RT::rep->abort(ERROR_SYNTAX);
    }

    if (a->value == OMEGA or b->value == -OMEGA)
    {
	return mkinteger(OMEGA);
    }

    if (a->value == -OMEGA or b->value == OMEGA)
    {
	return mkinteger(-OMEGA);
    }

    return mkinteger( a->value - b->value );
}

integer mult( integer a, integer b ) {
    // exclude OMEGAS for now
    if(a->value == OMEGA || b->value == OMEGA || a->value == -OMEGA || b->value == -OMEGA)
    {
	RT::rep->status("error in formula: invalid multiplication with oo");
	RT::rep->abort(ERROR_SYNTAX);
    }

    return mkinteger( a->value * b->value );
}

/*!
This function unfolds the FIREABLE() predicate to a conjunction that contains,
for each preplace, a term from the arc weight.
\only GreaterAtomicProposition will be performed
\param x  the id of a transition
\return  a statepredicate that is true if the given transition is fireable
*/
tStatePredicate FIREABLE_unfolder(const integer x)
{
    // start with TRUE and conjunct an atomic proposition for each preplace
    // (the TRUE predicate will be removed in later rewriting %rview tautology;)
    tStatePredicate result = AtomicProposition(True());

    // iterate preset
    for (arrayindex_t p = 0; p < Net::CardArcs[TR][PRE][x->value]; ++p)
    {
	result = Conjunction(
	    result,
	    AtomicProposition(
		GreaterAtomicProposition(
		    Node(mkinteger(Net::Arc[TR][PRE][x->value][p])),
		    Number(minus(mkinteger(Net::Mult[TR][PRE][x->value][p]),mkinteger(1)))
		)
	    )
	);
    }

    return result;
}

/*! This fuction unfolds the Unfireable() predicate to a disjunction that contains, for each preplace, a term from the arc weight.
\only LessEqualAtomicProposition will be performed
\parm x the id of a transition
\return a statepredicate that is true if the given transition is not fireable
*/
tStatePredicate UNFIREABLE_unfolder(const integer x)
{
    // start with FALSE and disjunct an atomic proposition for each preplace
    // (the FALSE predicate will be removed in later rewriting %rview tautology;)
    tStatePredicate result = AtomicProposition(False());

    // iterate preset
    for (arrayindex_t p = 0; p < Net::CardArcs[TR][PRE][x->value]; ++p)
    {
	result = Disjunction(
	    result,
	    AtomicProposition(
		LessEqualAtomicProposition(
		    Node(mkinteger(Net::Arc[TR][PRE][x->value][p])),
		    Number(minus(mkinteger(Net::Mult[TR][PRE][x->value][p]),mkinteger(1)))
		)
	    )
	);
    }

    return result;
}

/*!
This function unfolds the INITIAL() predicate to a conjunction that contains
for each place a term from its initial marking.

\return  a statpredicate that is exactly true in the initial marking
*/
tStatePredicate INITIAL_unfolder()
{
    // start with TRUE and conjunct an atomic proposition for each place
    // (the TRUE predicate will be removed in later rewritings)
    tStatePredicate result = AtomicProposition(True());

    // iterate places
    for (arrayindex_t p = 0; p < Net::Card[PL]; ++p)
    {
	result = Conjunction(
	    result,
	    AtomicProposition(
		EqualsAtomicProposition(
		    Node(mkinteger(p)),
		    Number(mkinteger(Marking::Initial[p]))
		)
	    )
	);
    }

    return result;
}


#line  244 "ast-system-rk.cc"
/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif
#ifndef KC_TRACE_REWRITE_MATCH
#define KC_TRACE_REWRITE_MATCH(VIEW,FILE,LINE,NODE)
#endif
#ifndef KC_TRACE_REWRITE_RESULT
#define KC_TRACE_REWRITE_RESULT(VIEW,FILE,LINE,NODE)
#endif

tFormula impl_tFormula_Compound::rewrite(rview kc_current_view_base)
{
    tFormula l_tFormula_1 =
	tFormula_1->rewrite(kc_current_view_base);
    tFormula l_tFormula_2 =
	tFormula_2->rewrite(kc_current_view_base);
    if ((l_tFormula_1 == tFormula_1) &&  (l_tFormula_2 == tFormula_2))
	return this;
    else {
	impl_tFormula_Compound* kc_result= Compound(l_tFormula_1, l_tFormula_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tFormula impl_tFormula_ComputeBound::rewrite(rview kc_current_view_base)
{
    tAtomicProposition l_tAtomicProposition_1 =
	tAtomicProposition_1->rewrite(kc_current_view_base);
    if ((l_tAtomicProposition_1 == tAtomicProposition_1))
	return this;
    else {
	impl_tFormula_ComputeBound* kc_result= ComputeBound(l_tAtomicProposition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tFormula impl_tFormula_StatePredicateFormula::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case singletemporal_enum: {
	    singletemporal_class& kc_current_view=static_cast<singletemporal_class&>(kc_current_view_base);
#line 825 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 825, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 825, this);
#line 825 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 825 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  302 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",825,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 829 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 829, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 829, this);
#line 829 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 829 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  314 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",829,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 804 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 804, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 804, this);
#line 804 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 804 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  326 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",804,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 821 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 821, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 821, this);
#line 821 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 821 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  338 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",821,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 812 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 812, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 812, this);
#line 812 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 812 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  350 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",812,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 816 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 816, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 816, this);
#line 816 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 816 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  362 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",816,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tFormula_StatePredicateFormula* kc_result= StatePredicateFormula(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_DisjunctionList::rewrite(rview kc_current_view_base)
{
    tDisjunction_list l_tDisjunction_list_1 =
	tDisjunction_list_1->rewrite(kc_current_view_base);
    if ((l_tDisjunction_list_1 == tDisjunction_list_1))
	return this;
    else {
	impl_tStatePredicate_DisjunctionList* kc_result= DisjunctionList(l_tDisjunction_list_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ConjunctionList::rewrite(rview kc_current_view_base)
{
    tConjunction_list l_tConjunction_list_1 =
	tConjunction_list_1->rewrite(kc_current_view_base);
    if ((l_tConjunction_list_1 == tConjunction_list_1))
	return this;
    else {
	impl_tStatePredicate_ConjunctionList* kc_result= ConjunctionList(l_tConjunction_list_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EX::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EX* kc_result= EX(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AX::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AX* kc_result= AX(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EG::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EG* kc_result= EG(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AG::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AG* kc_result= AG(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EF::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EF* kc_result= EF(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AF::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AF* kc_result= AF(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ER::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_ER* kc_result= ER(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AR::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_AR* kc_result= AR(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EU::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_EU* kc_result= EU(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AU::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_AU* kc_result= AU(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Release::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 503 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 503, this);
#line 503 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 503 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  561 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",503,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 512 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 512, this);
#line 512 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 512 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(x);

#line  573 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",512,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 533 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 533, this);
#line 533 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 533 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  585 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",533,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 536 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 536, this);
#line 536 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 536 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(x);

#line  597 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",536,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 500 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 500, this);
#line 500 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 500 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  609 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",500,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 515 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 515, this);
#line 515 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 515 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  621 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",515,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Release* kc_result= Release(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Until::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 497 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 497, this);
#line 497 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 497 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(x);

#line  656 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",497,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 509 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 509, this);
#line 509 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 509 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  668 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",509,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 527 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 527, this);
#line 527 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 527 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  680 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",527,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 530 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 530, this);
#line 530 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 530 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(x);

#line  692 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",530,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 703 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 703, this);
#line 703 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 703 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 703 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Until(x, y));

#line  706 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",703,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 494 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 494, this);
#line 494 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 494 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  718 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",494,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 506 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 506, this);
#line 506 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 506 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  730 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",506,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 706 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_1->eq(l_tStatePredicate_1))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 706, this);
#line 706 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 706 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 706 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  744 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",706,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Until* kc_result= Until(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_NextState::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 476 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 476, this);
#line 476 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 476 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  777 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",476,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 479 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 479, this);
#line 479 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 479 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  789 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",479,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_NextState* kc_result= NextState(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Eventually::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 464 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 464, this);
#line 464 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 464 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  822 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",464,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 467 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 467, this);
#line 467 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 467 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  834 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",467,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 521 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 521, this);
#line 521 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 521 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  846 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",521,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 682 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 682, this);
#line 682 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 682 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  858 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",682,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 667 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 667, this);
#line 667 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 667 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  870 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",667,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Eventually* kc_result= Eventually(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Always::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 470 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 470, this);
#line 470 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 470 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  903 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",470,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 473 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 473, this);
#line 473 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 473 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  915 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",473,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 524 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 524, this);
#line 524 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 524 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  927 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",524,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 685 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 685, this);
#line 685 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 685 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  939 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",685,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Always* kc_result= Always(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ExPath::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case ctloperators_enum: {
	    ctloperators_class& kc_current_view=static_cast<ctloperators_class&>(kc_current_view_base);
#line 886 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 886, this);
#line 886 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 886 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EU(AtomicProposition(True()), x);

#line  972 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",886,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 888 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 888, this);
#line 888 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 888 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EX(x);

#line  984 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",888,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 891 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 891, this);
#line 891 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 891 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(AU(AtomicProposition(True()), Negation(x)));

#line  996 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",891,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 893 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 893, this);
#line 893 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 893 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 893 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EU(x, y);

#line  1010 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",893,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 896 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 896, this);
#line 896 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 896 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 896 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(AU(Negation(x), Negation(y)));

#line  1024 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",896,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case emptyquantifiers_enum: {
	    emptyquantifiers_class& kc_current_view=static_cast<emptyquantifiers_class&>(kc_current_view_base);
#line 769 "Frontend/Parser/formula_rewrite.k"
	    if ((KC_TRACE_PROVIDED((not l_tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 769, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 769, this);
#line 769 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 769 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1040 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",769,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 700 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 700, this);
#line 700 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 700 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1056 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",700,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 694 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 694, this);
#line 694 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 694 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1068 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",694,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 482 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 482, this);
#line 482 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 482 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1080 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",482,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 485 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 485, this);
#line 485 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 485 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1092 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",485,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 542 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 542, this);
#line 542 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 542 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1104 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",542,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 548 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 548, this);
#line 548 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 548 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1116 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",548,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 676 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 676, this);
#line 676 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 676 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1128 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",676,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 679 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 679, this);
#line 679 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 679 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1140 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",679,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 731 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 731, this);
#line 731 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 731 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 731 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(ExPath(x), ExPath(y));

#line  1154 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",731,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_ExPath* kc_result= ExPath(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AllPath::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case ctloperators_enum: {
	    ctloperators_class& kc_current_view=static_cast<ctloperators_class&>(kc_current_view_base);
#line 899 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 899, this);
#line 899 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 899 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AU(AtomicProposition(True()), x);

#line  1187 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",899,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 901 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 901, this);
#line 901 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 901 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AX(x);

#line  1199 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",901,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 904 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 904, this);
#line 904 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 904 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(EU(AtomicProposition(True()), Negation(x)));

#line  1211 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",904,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 906 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 906, this);
#line 906 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 906 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 906 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AU(x, y);

#line  1225 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",906,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 909 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 909, this);
#line 909 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 909 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 909 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(EU(Negation(x), Negation(y)));

#line  1239 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",909,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case emptyquantifiers_enum: {
	    emptyquantifiers_class& kc_current_view=static_cast<emptyquantifiers_class&>(kc_current_view_base);
#line 770 "Frontend/Parser/formula_rewrite.k"
	    if ((KC_TRACE_PROVIDED((not l_tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 770, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 770, this);
#line 770 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 770 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1255 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",770,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 697 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 697, this);
#line 697 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 697 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1271 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",697,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 688 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 688, this);
#line 688 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 688 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1283 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",688,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 691 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 691, this);
#line 691 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 691 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1295 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",691,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 488 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 488, this);
#line 488 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 488 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1307 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",488,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 491 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 491, this);
#line 491 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 491 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1319 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",491,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 539 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 539, this);
#line 539 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 539 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1331 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",539,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 545 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 545, this);
#line 545 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 545 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1343 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",545,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 670 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 670, this);
#line 670 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 670 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1355 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",670,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 673 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 673, this);
#line 673 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 673 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1367 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",673,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 734 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 734, this);
#line 734 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 734 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 734 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(AllPath(x), AllPath(y));

#line  1381 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",734,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AllPath* kc_result= AllPath(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Equivalence::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_doublearrows_enum: {
	    goodbye_doublearrows_class& kc_current_view=static_cast<goodbye_doublearrows_class&>(kc_current_view_base);
#line 220 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 220, this);
#line 220 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 220 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 221 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Disjunction(x, Negation(y)), Disjunction(Negation(x), y));

#line  1418 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",221,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Equivalence* kc_result= Equivalence(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Implication::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_singlearrows_enum: {
	    goodbye_singlearrows_class& kc_current_view=static_cast<goodbye_singlearrows_class&>(kc_current_view_base);
#line 226 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 226, this);
#line 226 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 226 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 226 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), y);

#line  1453 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",226,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Implication* kc_result= Implication(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ExclusiveDisjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_xor_enum: {
	    goodbye_xor_class& kc_current_view=static_cast<goodbye_xor_class&>(kc_current_view_base);
#line 231 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 231, this);
#line 231 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 231 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 231 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Conjunction(x, Negation(y)), Conjunction(Negation(x), y));

#line  1488 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",231,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_ExclusiveDisjunction* kc_result= ExclusiveDisjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Disjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case simpletautology_enum: {
	    simpletautology_class& kc_current_view=static_cast<simpletautology_class&>(kc_current_view_base);
#line 963 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 963, this);
#line 963 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 963 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1521 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",963,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 965 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 965, this);
#line 965 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate t = l_tStatePredicate_1;
#line 965 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = t;

#line  1533 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",965,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 975 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 975, this);
#line 975 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 975 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 975 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_2;
#line 975 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(x, Disjunction(y, z));

#line  1549 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",975,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 962 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 962, this);
#line 962 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 962 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1561 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",962,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 964 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 964, this);
#line 964 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate t = l_tStatePredicate_2;
#line 964 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = t;

#line  1573 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",964,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case booleanlists_enum: {
	    booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 871 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 871, this);
#line 871 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 871 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 871 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = DisjunctionList(ConstDisjunction_list(x, ConstDisjunction_list(y, NiltDisjunction_list())));

#line  1591 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",871,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 570 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 570, this);
#line 570 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1604 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",570,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 571 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 571, this);
#line 571 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1614 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",571,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 572 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 572, this);
#line 572 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 572 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1626 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",572,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 573 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 573, this);
#line 573 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 573 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1638 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",573,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 560 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 560, this);
#line 560 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1648 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",560,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 561 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 561, this);
#line 561 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1658 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",561,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 562 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 562, this);
#line 562 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 562 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1670 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",562,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 563 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 563, this);
#line 563 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 563 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1682 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",563,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 746 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (l_tStatePredicate_2->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 746, this);
#line 746 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 746 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 746 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(Disjunction(a, b)));

#line  1696 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",746,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 752 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 752, this);
#line 752 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 752 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 752 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(NextState(Disjunction(a, b)));

#line  1710 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",752,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 456 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 456, this);
#line 456 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 456 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1722 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",456,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 458 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 458, this);
#line 458 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate t = l_tStatePredicate_1;
#line 458 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = t;

#line  1734 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",458,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 717 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (l_tStatePredicate_2->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 717, this);
#line 717 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 717 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 717 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(Disjunction(x, y));

#line  1748 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",717,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 726 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 726, this);
#line 726 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 726 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 726 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Disjunction(x, y));

#line  1762 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",726,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 587 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 587, this);
#line 587 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 587 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 587 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_2;
#line 587 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(x, Disjunction(y, z));

#line  1778 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",587,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 455 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 455, this);
#line 455 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 455 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1790 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",455,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 457 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 457, this);
#line 457 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate t = l_tStatePredicate_2;
#line 457 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = t;

#line  1802 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",457,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Disjunction* kc_result= Disjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Conjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case simpletautology_enum: {
	    simpletautology_class& kc_current_view=static_cast<simpletautology_class&>(kc_current_view_base);
#line 957 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 957, this);
#line 957 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 957 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1837 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",957,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 959 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 959, this);
#line 959 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = l_tStatePredicate_1;
#line 959 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  1849 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",959,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 972 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 972, this);
#line 972 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 972 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 972 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_2;
#line 972 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(x, Conjunction(y, z));

#line  1865 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",972,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 956 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 956, this);
#line 956 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 956 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1877 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",956,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 958 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 958, this);
#line 958 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = l_tStatePredicate_2;
#line 958 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  1889 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",958,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case dnf_enum: {
	    dnf_class& kc_current_view=static_cast<dnf_class&>(kc_current_view_base);
#line 932 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 932, this);
#line 932 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 932 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 932 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 933 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Conjunction(y, x), Conjunction(z, x));

#line  1909 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",933,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 928 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 928, this);
#line 928 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 928 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 928 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_2;
#line 929 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Conjunction(x, y), Conjunction(x, z));

#line  1925 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",929,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case booleanlists_enum: {
	    booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 867 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 867, this);
#line 867 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 867 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 867 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ConjunctionList(ConstConjunction_list(x, ConstConjunction_list(y, NiltConjunction_list())));

#line  1943 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",867,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 575 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 575, this);
#line 575 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1956 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",575,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 576 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 576, this);
#line 576 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1966 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",576,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 577 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 577, this);
#line 577 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 577 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1978 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",577,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 578 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 578, this);
#line 578 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 578 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1990 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",578,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 565 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 565, this);
#line 565 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  2000 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",565,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 566 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 566, this);
#line 566 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  2010 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",566,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 567 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 567, this);
#line 567 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 567 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2022 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",567,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 568 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 568, this);
#line 568 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 568 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2034 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",568,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 743 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (l_tStatePredicate_2->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 743, this);
#line 743 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 743 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 743 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(Conjunction(a, b)));

#line  2048 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",743,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 749 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 749, this);
#line 749 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 749 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 749 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(NextState(Conjunction(a, b)));

#line  2062 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",749,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 450 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 450, this);
#line 450 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 450 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  2074 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",450,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 452 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 452, this);
#line 452 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = l_tStatePredicate_1;
#line 452 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  2086 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",452,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 720 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (l_tStatePredicate_2->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 720, this);
#line 720 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 720 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 720 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(Conjunction(x, y));

#line  2100 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",720,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 723 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 723, this);
#line 723 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 723 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 723 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Conjunction(x, y));

#line  2114 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",723,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 584 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 584, this);
#line 584 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 584 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 584 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_2;
#line 584 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(x, Conjunction(y, z));

#line  2130 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",584,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 449 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 449, this);
#line 449 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 449 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  2142 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",449,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 451 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 451, this);
#line 451 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = l_tStatePredicate_2;
#line 451 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  2154 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",451,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Conjunction* kc_result= Conjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Negation::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case simpleneg_enum: {
	    simpleneg_class& kc_current_view=static_cast<simpleneg_class&>(kc_current_view_base);
#line 840 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 840, this);
#line 840 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  2185 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",840,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 843 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 843, this);
#line 843 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2195 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",843,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 846 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 846, this);
#line 846 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NoDeadlock());

#line  2205 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",846,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 849 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 849, this);
#line 849 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Deadlock());

#line  2215 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",849,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 852 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Fireable)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 852, this);
#line 852 "Frontend/Parser/formula_rewrite.k"
		const integer t = phylum_cast<const impl_tAtomicProposition_Fireable*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->integer_1;
#line 852 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Unfireable(t));

#line  2227 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",852,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 855 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Unfireable)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 855, this);
#line 855 "Frontend/Parser/formula_rewrite.k"
		const integer t = phylum_cast<const impl_tAtomicProposition_Unfireable*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->integer_1;
#line 855 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Fireable(t));

#line  2239 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",855,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 858 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_GreaterAtomicProposition)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 858, this);
#line 858 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = phylum_cast<const impl_tAtomicProposition_GreaterAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_1;
#line 858 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_GreaterAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_2;
#line 858 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(LessEqualAtomicProposition(p, n));

#line  2253 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",858,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 861 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_LessEqualAtomicProposition)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 861, this);
#line 861 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_1;
#line 861 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_2;
#line 861 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(GreaterAtomicProposition(p, n));

#line  2267 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",861,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 834 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 834, this);
#line 834 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 834 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 834 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), Negation(y));

#line  2281 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",834,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 837 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 837, this);
#line 837 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 837 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 837 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Negation(x), Negation(y));

#line  2295 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",837,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 606 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_GreaterAtomicProposition)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 606, this);
#line 606 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = phylum_cast<const impl_tAtomicProposition_GreaterAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_1;
#line 606 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_GreaterAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_2;
#line 606 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(LessEqualAtomicProposition(p, n));

#line  2313 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",606,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 609 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_LessEqualAtomicProposition)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 609, this);
#line 609 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_1;
#line 609 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_2;
#line 609 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(GreaterAtomicProposition(p, n));

#line  2327 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",609,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 612 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 612, this);
#line 612 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  2337 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",612,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 615 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 615, this);
#line 615 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2347 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",615,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 618 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 618, this);
#line 618 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NoDeadlock());

#line  2357 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",618,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 621 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 621, this);
#line 621 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Deadlock());

#line  2367 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",621,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 624 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Fireable)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 624, this);
#line 624 "Frontend/Parser/formula_rewrite.k"
		const integer t = phylum_cast<const impl_tAtomicProposition_Fireable*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->integer_1;
#line 624 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Unfireable(t));

#line  2379 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",624,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 627 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Unfireable)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 627, this);
#line 627 "Frontend/Parser/formula_rewrite.k"
		const integer t = phylum_cast<const impl_tAtomicProposition_Unfireable*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->integer_1;
#line 627 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Fireable(t));

#line  2391 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",627,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 632 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Negation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 632, this);
#line 632 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Negation*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 632 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2403 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",632,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 635 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 635, this);
#line 635 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 635 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 635 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), Negation(y));

#line  2417 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",635,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 638 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 638, this);
#line 638 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 638 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 638 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Negation(x), Negation(y));

#line  2431 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",638,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 643 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 643, this);
#line 643 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 643 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Negation(x));

#line  2443 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",643,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 646 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 646, this);
#line 646 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 646 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Negation(x));

#line  2455 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",646,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 649 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 649, this);
#line 649 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 649 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(Negation(x));

#line  2467 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",649,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 652 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 652, this);
#line 652 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 652 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(Negation(x));

#line  2479 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",652,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 655 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 655, this);
#line 655 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 655 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Negation(x));

#line  2491 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",655,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 658 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 658, this);
#line 658 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 658 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 658 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Release(Negation(x), Negation(y));

#line  2505 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",658,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 661 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 661, this);
#line 661 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 661 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 661 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(Negation(x), Negation(y));

#line  2519 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",661,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Negation* kc_result= Negation(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AtomicProposition::rewrite(rview kc_current_view_base)
{
    tAtomicProposition l_tAtomicProposition_1 =
	tAtomicProposition_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case leq_enum: {
	    leq_class& kc_current_view=static_cast<leq_class&>(kc_current_view_base);
#line 412 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_EqualsAtomicProposition) && (phylum_cast<const impl_tAtomicProposition_EqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 412, this);
#line 412 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = phylum_cast<const impl_tAtomicProposition_EqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_1;
#line 412 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_EqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2;
#line 412 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tAtomicProposition_EqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2)->integer_1;
#line 412 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(AtomicProposition(LessEqualAtomicProposition(x, n)), AtomicProposition(GreaterAtomicProposition(x, Number(minus(y, mkinteger(1))))));

#line  2556 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",412,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 415 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_NotEqualsAtomicProposition) && (phylum_cast<const impl_tAtomicProposition_NotEqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 415, this);
#line 415 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = phylum_cast<const impl_tAtomicProposition_NotEqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_1;
#line 415 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_NotEqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2;
#line 415 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tAtomicProposition_NotEqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2)->integer_1;
#line 415 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(AtomicProposition(LessEqualAtomicProposition(x, Number(minus(y, mkinteger(1))))), AtomicProposition(GreaterAtomicProposition(x, n)));

#line  2572 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",415,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case goodbye_initial_enum: {
	    goodbye_initial_class& kc_current_view=static_cast<goodbye_initial_class&>(kc_current_view_base);
#line 246 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_Initial)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 246, this);
#line 246 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = INITIAL_unfolder();

#line  2586 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",246,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case goodbye_unfireable_enum: {
	    goodbye_unfireable_class& kc_current_view=static_cast<goodbye_unfireable_class&>(kc_current_view_base);
#line 241 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_Unfireable)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 241, this);
#line 241 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tAtomicProposition_Unfireable*>(l_tAtomicProposition_1)->integer_1;
#line 241 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = UNFIREABLE_unfolder(x);

#line  2602 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",241,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case goodbye_fireable_enum: {
	    goodbye_fireable_class& kc_current_view=static_cast<goodbye_fireable_class&>(kc_current_view_base);
#line 236 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_Fireable)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 236, this);
#line 236 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tAtomicProposition_Fireable*>(l_tAtomicProposition_1)->integer_1;
#line 236 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = FIREABLE_unfolder(x);

#line  2618 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",236,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tAtomicProposition_1 == tAtomicProposition_1))
	return this;
    else {
	impl_tStatePredicate_AtomicProposition* kc_result= AtomicProposition(l_tAtomicProposition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tConjunction_list impl_tConjunction_list::rewrite(rview kc_current_view_base)
{
    if (is_nil()) {
	return this;
    } else { // not Nil, Cons
	tStatePredicate l_tStatePredicate_1 =
	    tStatePredicate_1->rewrite(kc_current_view_base);
	tConjunction_list l_tConjunction_list_1 =
	    tConjunction_list_1->rewrite(kc_current_view_base);
	switch(kc_current_view_base) {
	    case booleanlists_enum: {
		booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 868 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ConjunctionList)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 868, this);
#line 868 "Frontend/Parser/formula_rewrite.k"
		    const tConjunction_list x = phylum_cast<const impl_tStatePredicate_ConjunctionList*>(l_tStatePredicate_1)->tConjunction_list_1;
#line 868 "Frontend/Parser/formula_rewrite.k"
		    const tConjunction_list y = l_tConjunction_list_1;
#line 868 "Frontend/Parser/formula_rewrite.k"
		    tConjunction_list kc_result = concat(x, y);

#line  2658 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",868,kc_result);
		    return (const_cast<const impl_tConjunction_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
			goto kc_rewrite_default;
	    }
	    kc_rewrite_default:
	    default:;
	}
	if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tConjunction_list_1 == tConjunction_list_1))
	    return this;
	else {
	    impl_tConjunction_list* kc_result= ConstConjunction_list(l_tStatePredicate_1, l_tConjunction_list_1);
	    kc_result->rewrite_members(this);
	    return kc_result;
	}   }
}

tDisjunction_list impl_tDisjunction_list::rewrite(rview kc_current_view_base)
{
    if (is_nil()) {
	return this;
    } else { // not Nil, Cons
	tStatePredicate l_tStatePredicate_1 =
	    tStatePredicate_1->rewrite(kc_current_view_base);
	tDisjunction_list l_tDisjunction_list_1 =
	    tDisjunction_list_1->rewrite(kc_current_view_base);
	switch(kc_current_view_base) {
	    case booleanlists_enum: {
		booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 872 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_DisjunctionList)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 872, this);
#line 872 "Frontend/Parser/formula_rewrite.k"
		    const tDisjunction_list x = phylum_cast<const impl_tStatePredicate_DisjunctionList*>(l_tStatePredicate_1)->tDisjunction_list_1;
#line 872 "Frontend/Parser/formula_rewrite.k"
		    const tDisjunction_list y = l_tDisjunction_list_1;
#line 872 "Frontend/Parser/formula_rewrite.k"
		    tDisjunction_list kc_result = concat(x, y);

#line  2698 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",872,kc_result);
		    return (const_cast<const impl_tDisjunction_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
			goto kc_rewrite_default;
	    }
	    kc_rewrite_default:
	    default:;
	}
	if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tDisjunction_list_1 == tDisjunction_list_1))
	    return this;
	else {
	    impl_tDisjunction_list* kc_result= ConstDisjunction_list(l_tStatePredicate_1, l_tDisjunction_list_1);
	    kc_result->rewrite_members(this);
	    return kc_result;
	}   }
}

tAtomicProposition impl_tAtomicProposition_Unfireable::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_tAtomicProposition_Unfireable* kc_result= Unfireable(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_Fireable::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_tAtomicProposition_Fireable* kc_result= Fireable(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_Initial::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_Deadlock::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_NoDeadlock::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_False::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_True::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_LessEqualAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case leq_enum: {
	    leq_class& kc_current_view=static_cast<leq_class&>(kc_current_view_base);
#line 426 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value <= phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 426, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 426, this);
#line 426 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 426 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 426 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  2791 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",426,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 427 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value > phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 427, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 427, this);
#line 427 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 427 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 427 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  2805 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",427,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 310 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 310, this);
#line 310 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 310 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 310 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 310 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(y, Number(minus(z, x)));

#line  2825 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",310,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 374 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value <= phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 374, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 374, this);
#line 374 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 374 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 374 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  2839 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",374,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 375 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value > phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 375, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 375, this);
#line 375 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 375 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 375 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  2853 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",375,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 319 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 319, this);
#line 319 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 319 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 319 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Product(mkinteger(1), n), m);

#line  2867 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",319,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 363 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 363, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 363, this);
#line 363 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 363 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  2879 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",363,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 287 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 287, this);
#line 287 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 287 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 287 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  2893 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",287,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 294 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 294, this);
#line 294 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 294 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 294 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  2907 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",294,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 301 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 301, this);
#line 301 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 301 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 301 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  2921 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",301,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_LessEqualAtomicProposition* kc_result= LessEqualAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_LessAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case leq_enum: {
	    leq_class& kc_current_view=static_cast<leq_class&>(kc_current_view_base);
#line 421 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 421, this);
#line 421 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 421 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 421 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(x, Number(minus(y, mkinteger(1))));

#line  2958 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",421,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 311 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 311, this);
#line 311 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 311 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 311 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 311 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessAtomicProposition(y, Number(minus(z, x)));

#line  2978 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",311,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 376 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value < phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 376, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 376, this);
#line 376 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 376 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 376 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  2992 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",376,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 377 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value >= phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 377, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 377, this);
#line 377 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 377 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 377 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  3006 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",377,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 320 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 320, this);
#line 320 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 320 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 320 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessAtomicProposition(Product(mkinteger(1), n), m);

#line  3020 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",320,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 357 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 357, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 357, this);
#line 357 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 357 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 357 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(x, Number(mkinteger(FINITE)));

#line  3034 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",357,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 288 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 288, this);
#line 288 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 288 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 288 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  3048 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",288,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 295 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 295, this);
#line 295 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 295 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 295 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  3062 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",295,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 302 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 302, this);
#line 302 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 302 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 302 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  3076 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",302,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_LessAtomicProposition* kc_result= LessAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_GreaterEqualAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case leq_enum: {
	    leq_class& kc_current_view=static_cast<leq_class&>(kc_current_view_base);
#line 418 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 418, this);
#line 418 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 418 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 418 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(x, Number(minus(y, mkinteger(1))));

#line  3113 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",418,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 312 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 312, this);
#line 312 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 312 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 312 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 312 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterEqualAtomicProposition(y, Number(minus(z, x)));

#line  3133 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",312,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 378 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value >= phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 378, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 378, this);
#line 378 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 378 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 378 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  3147 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",378,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 379 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value < phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 379, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 379, this);
#line 379 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 379 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 379 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  3161 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",379,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 321 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 321, this);
#line 321 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 321 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 321 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterEqualAtomicProposition(Product(mkinteger(1), n), m);

#line  3175 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",321,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 366 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 366, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 366, this);
#line 366 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 366 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 366 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Product(mkinteger(-1), x), Number(minus(mkinteger(0), y)));

#line  3189 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",366,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 289 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 289, this);
#line 289 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 289 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 289 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterEqualAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  3203 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",289,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 296 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 296, this);
#line 296 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 296 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 296 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterEqualAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  3217 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",296,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 303 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 303, this);
#line 303 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 303 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 303 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterEqualAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  3231 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",303,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_GreaterEqualAtomicProposition* kc_result= GreaterEqualAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_GreaterAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case leq_enum: {
	    leq_class& kc_current_view=static_cast<leq_class&>(kc_current_view_base);
#line 430 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value > phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 430, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 430, this);
#line 430 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 430 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 430 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  3268 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",430,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 431 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value <= phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 431, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 431, this);
#line 431 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 431 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 431 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  3282 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",431,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 313 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 313, this);
#line 313 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 313 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 313 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 313 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(y, Number(minus(z, x)));

#line  3302 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",313,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 380 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value > phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 380, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 380, this);
#line 380 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 380 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 380 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  3316 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",380,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 381 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value <= phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 381, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 381, this);
#line 381 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 381 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 381 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  3330 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",381,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 322 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 322, this);
#line 322 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 322 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 322 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(Product(mkinteger(1), n), m);

#line  3344 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",322,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 360 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 360, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 360, this);
#line 360 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 360 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  3356 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",360,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 290 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 290, this);
#line 290 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 290 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 290 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  3370 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",290,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 297 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 297, this);
#line 297 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 297 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 297 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  3384 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",297,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 304 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 304, this);
#line 304 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 304 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 304 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  3398 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",304,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_GreaterAtomicProposition* kc_result= GreaterAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_NotEqualsAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 315 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 315, this);
#line 315 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 315 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 315 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 315 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NotEqualsAtomicProposition(y, Number(minus(z, x)));

#line  3437 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",315,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 384 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value != phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 384, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 384, this);
#line 384 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 384 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 384 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  3451 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",384,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 385 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value == phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 385, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 385, this);
#line 385 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 385 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 385 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  3465 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",385,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 324 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 324, this);
#line 324 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 324 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 324 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NotEqualsAtomicProposition(Product(mkinteger(1), n), m);

#line  3479 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",324,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 371 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 371, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 371, this);
#line 371 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 371 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 371 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(x, Number(mkinteger(FINITE)));

#line  3493 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",371,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 292 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 292, this);
#line 292 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 292 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 292 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NotEqualsAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  3507 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",292,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 299 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 299, this);
#line 299 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 299 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 299 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NotEqualsAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  3521 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",299,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 306 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 306, this);
#line 306 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 306 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 306 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NotEqualsAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  3535 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",306,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_NotEqualsAtomicProposition* kc_result= NotEqualsAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_EqualsAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 314 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 314, this);
#line 314 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 314 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 314 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 314 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = EqualsAtomicProposition(y, Number(minus(z, x)));

#line  3574 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",314,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 382 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value == phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 382, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 382, this);
#line 382 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 382 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 382 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  3588 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",382,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 383 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value != phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 383, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 383, this);
#line 383 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 383 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 383 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  3602 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",383,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 323 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 323, this);
#line 323 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 323 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 323 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = EqualsAtomicProposition(Product(mkinteger(1), n), m);

#line  3616 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",323,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 369 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 369, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 369, this);
#line 369 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 369 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 369 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Product(mkinteger(-1), x), Number(minus(mkinteger(0), y)));

#line  3630 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",369,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 291 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 291, this);
#line 291 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 291 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 291 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = EqualsAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  3644 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",291,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 298 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 298, this);
#line 298 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 298 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 298 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = EqualsAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  3658 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",298,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 305 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 305, this);
#line 305 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 305 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 305 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = EqualsAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  3672 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",305,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_EqualsAtomicProposition* kc_result= EqualsAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_ProductList::rewrite(rview kc_current_view_base)
{
    tProduct_list l_tProduct_list_1 =
	tProduct_list_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case productlists_enum: {
	    productlists_class& kc_current_view=static_cast<productlists_class&>(kc_current_view_base);
#line 404 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tProduct_list_1->prod_sel() == sel_NiltProduct_list)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 404, this);
#line 404 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Number(mkinteger(0));

#line  3703 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",404,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tProduct_list_1 == tProduct_list_1))
	return this;
    else {
	impl_tTerm_ProductList* kc_result= ProductList(l_tProduct_list_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_Product::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case productlists_enum: {
	    productlists_class& kc_current_view=static_cast<productlists_class&>(kc_current_view_base);
#line 402 "Frontend/Parser/formula_rewrite.k"
	    if ((KC_TRACE_PROVIDED((l_integer_1->value == 0), "Frontend/Parser/formula_rewrite.k", 402, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 402, this);
#line 402 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 402 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Number(mkinteger(0));

#line  3738 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",402,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 345 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 345, this);
#line 345 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 345 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 345 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 345 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(Number(mult(x, y)), Product(x, z));

#line  3758 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",345,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 282 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Sum) && (KC_TRACE_PROVIDED((l_integer_1->value == 1), "Frontend/Parser/formula_rewrite.k", 282, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 282, this);
#line 282 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 282 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = l_tTerm_1;
#line 282 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = y;

#line  3772 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",282,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 283 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 283, this);
#line 283 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 283 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 283 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Number(mult(x, y));

#line  3786 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",283,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 344 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 344, this);
#line 344 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 344 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->integer_1;
#line 344 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1;
#line 344 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Product(mult(x, y), z);

#line  3802 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",344,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 346 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 346, this);
#line 346 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 346 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1;
#line 346 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 346 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(Product(x, y), Product(x, z));

#line  3818 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",346,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 281 "Frontend/Parser/formula_rewrite.k"
		if ((KC_TRACE_PROVIDED((l_integer_1->value == 0), "Frontend/Parser/formula_rewrite.k", 281, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 281, this);
#line 281 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 281 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Number(mkinteger(0));

#line  3830 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",281,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_integer_1 == integer_1) &&  (l_tTerm_1 == tTerm_1))
	return this;
    else {
	impl_tTerm_Product* kc_result= Product(l_integer_1, l_tTerm_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_Difference::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 331 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 331, this);
#line 331 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 331 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = l_tTerm_2;
#line 331 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(x, Product(mkinteger(-1), y));

#line  3867 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",331,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tTerm_Difference* kc_result= Difference(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_Sum::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case productlists_enum: {
	    productlists_class& kc_current_view=static_cast<productlists_class&>(kc_current_view_base);
#line 390 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 390, this);
#line 390 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 390 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = l_tTerm_2;
#line 390 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = ProductList(ConstProduct_list(x, ConstProduct_list(y, NiltProduct_list())));

#line  3902 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",390,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 279 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_1->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 279, this);
#line 279 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 279 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_1)->integer_1;
#line 279 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_2;
#line 279 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(Number(plus(x, y)), z);

#line  3921 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",279,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 278 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 278, this);
#line 278 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 278 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 278 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Number(plus(x, y));

#line  3935 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",278,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 280 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value == 0), "Frontend/Parser/formula_rewrite.k", 280, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 280, this);
#line 280 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 280 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = l_tTerm_2;
#line 280 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = y;

#line  3949 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",280,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 326 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 326, this);
#line 326 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 326 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = l_tTerm_2;
#line 326 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(Product(mkinteger(1), n), y);

#line  3963 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",326,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 340 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 340, this);
#line 340 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1;
#line 340 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 340 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = l_tTerm_2;
#line 340 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(x, Sum(y, z));

#line  3979 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",340,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 336 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_1->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 336, this);
#line 336 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 336 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_1;
#line 336 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_2;
#line 336 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(n, Sum(x, z));

#line  3995 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",336,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 327 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 327, this);
#line 327 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 327 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 327 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(x, Product(mkinteger(1), n));

#line  4009 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",327,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 335 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 335, this);
#line 335 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 335 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 335 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(n, x);

#line  4023 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",335,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tTerm_Sum* kc_result= Sum(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_Number::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_tTerm_Number* kc_result= Number(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_Node::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_tTerm_Node* kc_result= Node(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tProduct_list impl_tProduct_list::rewrite(rview kc_current_view_base)
{
    if (is_nil()) {
	return this;
    } else { // not Nil, Cons
	tTerm l_tTerm_1 =
	    tTerm_1->rewrite(kc_current_view_base);
	tProduct_list l_tProduct_list_1 =
	    tProduct_list_1->rewrite(kc_current_view_base);
	switch(kc_current_view_base) {
	    case productlists_enum: {
		productlists_class& kc_current_view=static_cast<productlists_class&>(kc_current_view_base);
#line 399 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Product) && (phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Node) && (l_tProduct_list_1->prod_sel() == sel_ConstProduct_list) && ((l_tProduct_list_1)->tTerm_1->prod_sel() == sel_Product) && (phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->tTerm_1->prod_sel() == sel_Node) && (phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->tTerm_1)->integer_1->eq(phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1)->integer_1))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 399, this);
#line 399 "Frontend/Parser/formula_rewrite.k"
		    const integer x = phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->integer_1;
#line 399 "Frontend/Parser/formula_rewrite.k"
		    const integer u = phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 399 "Frontend/Parser/formula_rewrite.k"
		    const integer y = phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->integer_1;
#line 399 "Frontend/Parser/formula_rewrite.k"
		    const tProduct_list l = (l_tProduct_list_1)->tProduct_list_1;
#line 399 "Frontend/Parser/formula_rewrite.k"
		    tProduct_list kc_result = ConstProduct_list(Product(plus(x, y), Node(u)), l);

#line  4093 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",399,kc_result);
		    return (const_cast<const impl_tProduct_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
#line 396 "Frontend/Parser/formula_rewrite.k"
		    if ((l_tTerm_1->prod_sel() == sel_Product) && (phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Node) && (l_tProduct_list_1->prod_sel() == sel_ConstProduct_list) && ((l_tProduct_list_1)->tTerm_1->prod_sel() == sel_Product) && (phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->tTerm_1->prod_sel() == sel_Node) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1)->integer_1->value > phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->tTerm_1)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 396, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 396, this);
#line 396 "Frontend/Parser/formula_rewrite.k"
		    const tTerm p1 = l_tTerm_1;
#line 396 "Frontend/Parser/formula_rewrite.k"
		    const integer pid1 = phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 396 "Frontend/Parser/formula_rewrite.k"
		    const tTerm p2 = (l_tProduct_list_1)->tTerm_1;
#line 396 "Frontend/Parser/formula_rewrite.k"
		    const integer pid2 = phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->tTerm_1)->integer_1;
#line 396 "Frontend/Parser/formula_rewrite.k"
		    const tProduct_list l = (l_tProduct_list_1)->tProduct_list_1;
#line 396 "Frontend/Parser/formula_rewrite.k"
		    tProduct_list kc_result = ConstProduct_list(p2, ConstProduct_list(p1, l));

#line  4113 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",396,kc_result);
		    return (const_cast<const impl_tProduct_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
#line 403 "Frontend/Parser/formula_rewrite.k"
		    if ((l_tTerm_1->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value == 0), "Frontend/Parser/formula_rewrite.k", 403, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 403, this);
#line 403 "Frontend/Parser/formula_rewrite.k"
		    const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 403 "Frontend/Parser/formula_rewrite.k"
		    const tProduct_list y = l_tProduct_list_1;
#line 403 "Frontend/Parser/formula_rewrite.k"
		    tProduct_list kc_result = y;

#line  4127 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",403,kc_result);
		    return (const_cast<const impl_tProduct_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
#line 393 "Frontend/Parser/formula_rewrite.k"
		    if ((l_tTerm_1->prod_sel() == sel_ProductList)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 393, this);
#line 393 "Frontend/Parser/formula_rewrite.k"
		    const tProduct_list x = phylum_cast<const impl_tTerm_ProductList*>(l_tTerm_1)->tProduct_list_1;
#line 393 "Frontend/Parser/formula_rewrite.k"
		    const tProduct_list y = l_tProduct_list_1;
#line 393 "Frontend/Parser/formula_rewrite.k"
		    tProduct_list kc_result = concat(x, y);

#line  4141 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",393,kc_result);
		    return (const_cast<const impl_tProduct_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
			goto kc_rewrite_default;
	    }
	    kc_rewrite_default:
	    default:;
	}
	if ((l_tTerm_1 == tTerm_1) &&  (l_tProduct_list_1 == tProduct_list_1))
	    return this;
	else {
	    impl_tProduct_list* kc_result= ConstProduct_list(l_tTerm_1, l_tProduct_list_1);
	    kc_result->rewrite_members(this);
	    return kc_result;
	}   }
}

tBuechiAutomata impl_tBuechiAutomata_BuechiNull::rewrite(rview kc_current_view_base)
{
    return this;

}

tBuechiAutomata impl_tBuechiAutomata_BuechiAutomaton::rewrite(rview kc_current_view_base)
{
    tBuechiRules l_tBuechiRules_1 =
	tBuechiRules_1->rewrite(kc_current_view_base);
    tAcceptingSet l_tAcceptingSet_1 =
	tAcceptingSet_1->rewrite(kc_current_view_base);
    if ((l_tBuechiRules_1 == tBuechiRules_1) &&  (l_tAcceptingSet_1 == tAcceptingSet_1))
	return this;
    else {
	impl_tBuechiAutomata_BuechiAutomaton* kc_result= BuechiAutomaton(l_tBuechiRules_1, l_tAcceptingSet_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_BuechiRules::rewrite(rview kc_current_view_base)
{
    tBuechiRules l_tBuechiRules_1 =
	tBuechiRules_1->rewrite(kc_current_view_base);
    tBuechiRules l_tBuechiRules_2 =
	tBuechiRules_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case rbuechi_enum: {
	    rbuechi_class& kc_current_view=static_cast<rbuechi_class&>(kc_current_view_base);
#line 919 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tBuechiRules_1->prod_sel() == sel_EmptyBuechiRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 919, this);
#line 919 "Frontend/Parser/formula_rewrite.k"
		const tBuechiRules a = l_tBuechiRules_2;
#line 919 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = a;

#line  4197 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",919,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 918 "Frontend/Parser/formula_rewrite.k"
		if ((l_tBuechiRules_2->prod_sel() == sel_EmptyBuechiRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 918, this);
#line 918 "Frontend/Parser/formula_rewrite.k"
		const tBuechiRules a = l_tBuechiRules_1;
#line 918 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = a;

#line  4209 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",918,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tBuechiRules_1 == tBuechiRules_1) &&  (l_tBuechiRules_2 == tBuechiRules_2))
	return this;
    else {
	impl_tBuechiRules_BuechiRules* kc_result= BuechiRules(l_tBuechiRules_1, l_tBuechiRules_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_ExpandedBuechiRule::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    tFormula l_tFormula_1 =
	tFormula_1->rewrite(kc_current_view_base);
    integer l_integer_2 =
	integer_2->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1) &&  (l_tFormula_1 == tFormula_1) &&  (l_integer_2 == integer_2))
	return this;
    else {
	impl_tBuechiRules_ExpandedBuechiRule* kc_result= ExpandedBuechiRule(l_integer_1, l_tFormula_1, l_integer_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_BuechiRule::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    tTransitionRules l_tTransitionRules_1 =
	tTransitionRules_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case rbuechi_enum: {
	    rbuechi_class& kc_current_view=static_cast<rbuechi_class&>(kc_current_view_base);
#line 915 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTransitionRules_1->prod_sel() == sel_TransitionRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 915, this);
#line 915 "Frontend/Parser/formula_rewrite.k"
		const integer from = l_integer_1;
#line 915 "Frontend/Parser/formula_rewrite.k"
		const tTransitionRules lrules = phylum_cast<const impl_tTransitionRules_TransitionRules*>(l_tTransitionRules_1)->tTransitionRules_1;
#line 915 "Frontend/Parser/formula_rewrite.k"
		const tTransitionRules rrules = phylum_cast<const impl_tTransitionRules_TransitionRules*>(l_tTransitionRules_1)->tTransitionRules_2;
#line 915 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = BuechiRules(BuechiRule(from, lrules), BuechiRule(from, rrules));

#line  4265 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",915,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 916 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTransitionRules_1->prod_sel() == sel_TransitionRule)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 916, this);
#line 916 "Frontend/Parser/formula_rewrite.k"
		const integer from = l_integer_1;
#line 916 "Frontend/Parser/formula_rewrite.k"
		const tFormula formula = phylum_cast<const impl_tTransitionRules_TransitionRule*>(l_tTransitionRules_1)->tFormula_1;
#line 916 "Frontend/Parser/formula_rewrite.k"
		const integer to = phylum_cast<const impl_tTransitionRules_TransitionRule*>(l_tTransitionRules_1)->integer_1;
#line 916 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = ExpandedBuechiRule(from, formula, to);

#line  4281 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",916,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 917 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTransitionRules_1->prod_sel() == sel_EmptyTransitionRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 917, this);
#line 917 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = EmptyBuechiRules();

#line  4291 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",917,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_integer_1 == integer_1) &&  (l_tTransitionRules_1 == tTransitionRules_1))
	return this;
    else {
	impl_tBuechiRules_BuechiRule* kc_result= BuechiRule(l_integer_1, l_tTransitionRules_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_EmptyBuechiRules::rewrite(rview kc_current_view_base)
{
    return this;

}

tTransitionRules impl_tTransitionRules_TransitionRules::rewrite(rview kc_current_view_base)
{
    tTransitionRules l_tTransitionRules_1 =
	tTransitionRules_1->rewrite(kc_current_view_base);
    tTransitionRules l_tTransitionRules_2 =
	tTransitionRules_2->rewrite(kc_current_view_base);
    if ((l_tTransitionRules_1 == tTransitionRules_1) &&  (l_tTransitionRules_2 == tTransitionRules_2))
	return this;
    else {
	impl_tTransitionRules_TransitionRules* kc_result= TransitionRules(l_tTransitionRules_1, l_tTransitionRules_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTransitionRules impl_tTransitionRules_TransitionRule::rewrite(rview kc_current_view_base)
{
    tFormula l_tFormula_1 =
	tFormula_1->rewrite(kc_current_view_base);
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_tFormula_1 == tFormula_1) &&  (l_integer_1 == integer_1))
	return this;
    else {
	impl_tTransitionRules_TransitionRule* kc_result= TransitionRule(l_tFormula_1, l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTransitionRules impl_tTransitionRules_EmptyTransitionRules::rewrite(rview kc_current_view_base)
{
    return this;

}

tAcceptingSet impl_tAcceptingSet_AcceptingSet::rewrite(rview kc_current_view_base)
{
    tAcceptingSet l_tAcceptingSet_1 =
	tAcceptingSet_1->rewrite(kc_current_view_base);
    tAcceptingSet l_tAcceptingSet_2 =
	tAcceptingSet_2->rewrite(kc_current_view_base);
    if ((l_tAcceptingSet_1 == tAcceptingSet_1) &&  (l_tAcceptingSet_2 == tAcceptingSet_2))
	return this;
    else {
	impl_tAcceptingSet_AcceptingSet* kc_result= AcceptingSet(l_tAcceptingSet_1, l_tAcceptingSet_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAcceptingSet impl_tAcceptingSet_AcceptingState::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_tAcceptingSet_AcceptingState* kc_result= AcceptingState(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAcceptingSet impl_tAcceptingSet_EmptyAcceptingSet::rewrite(rview kc_current_view_base)
{
    return this;

}

net impl_net_Net::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    definitionsList l_definitionsList_1 =
	definitionsList_1->rewrite(kc_current_view_base);
    placeblocklist l_placeblocklist_1 =
	placeblocklist_1->rewrite(kc_current_view_base);
    marking l_marking_1 =
	marking_1->rewrite(kc_current_view_base);
    transition l_transition_1 =
	transition_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_definitionsList_1 == definitionsList_1) &&  (l_placeblocklist_1 == placeblocklist_1) &&  (l_marking_1 == marking_1) &&  (l_transition_1 == transition_1))
	return this;
    else {
	impl_net_Net* kc_result= Net(l_casestring_1, l_definitionsList_1, l_placeblocklist_1, l_marking_1, l_transition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitionsList impl_definitionsList_DefinitionsList::rewrite(rview kc_current_view_base)
{
    definitionsList l_definitionsList_1 =
	definitionsList_1->rewrite(kc_current_view_base);
    definitions l_definitions_1 =
	definitions_1->rewrite(kc_current_view_base);
    if ((l_definitionsList_1 == definitionsList_1) &&  (l_definitions_1 == definitions_1))
	return this;
    else {
	impl_definitionsList_DefinitionsList* kc_result= DefinitionsList(l_definitionsList_1, l_definitions_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitionsList impl_definitionsList_EmptyDefinitionsList::rewrite(rview kc_current_view_base)
{
    return this;

}

definitions impl_definitions_Function::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    functionParametersList l_functionParametersList_1 =
	functionParametersList_1->rewrite(kc_current_view_base);
    block l_block_1 =
	block_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1) &&  (l_functionParametersList_1 == functionParametersList_1) &&  (l_block_1 == block_1))
	return this;
    else {
	impl_definitions_Function* kc_result= Function(l_type_1, l_casestring_1, l_arrayList_1, l_functionParametersList_1, l_block_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitions impl_definitions_Sort::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1))
	return this;
    else {
	impl_definitions_Sort* kc_result= Sort(l_type_1, l_casestring_1, l_arrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitions impl_definitions_Constant::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_definitions_Constant* kc_result= Constant(l_type_1, l_casestring_1, l_arrayList_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeBlack::rewrite(rview kc_current_view_base)
{
    return this;

}

type impl_type_TypeArray::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_integer_1 == integer_1))
	return this;
    else {
	impl_type_TypeArray* kc_result= TypeArray(l_type_1, l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeMultiset::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1))
	return this;
    else {
	impl_type_TypeMultiset* kc_result= TypeMultiset(l_type_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeInt::rewrite(rview kc_current_view_base)
{
    return this;

}

type impl_type_TypeStruct::rewrite(rview kc_current_view_base)
{
    structTypeList l_structTypeList_1 =
	structTypeList_1->rewrite(kc_current_view_base);
    if ((l_structTypeList_1 == structTypeList_1))
	return this;
    else {
	impl_type_TypeStruct* kc_result= TypeStruct(l_structTypeList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeIntInterval::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_type_TypeIntInterval* kc_result= TypeIntInterval(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeIdent::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1))
	return this;
    else {
	impl_type_TypeIdent* kc_result= TypeIdent(l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeEnum::rewrite(rview kc_current_view_base)
{
    identList l_identList_1 =
	identList_1->rewrite(kc_current_view_base);
    if ((l_identList_1 == identList_1))
	return this;
    else {
	impl_type_TypeEnum* kc_result= TypeEnum(l_identList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeBool::rewrite(rview kc_current_view_base)
{
    return this;

}

optionalNumber impl_optionalNumber_OptNumber::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_optionalNumber_OptNumber* kc_result= OptNumber(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

optionalNumber impl_optionalNumber_EmptyOptNumber::rewrite(rview kc_current_view_base)
{
    return this;

}

identList impl_identList_IdentList::rewrite(rview kc_current_view_base)
{
    identList l_identList_1 =
	identList_1->rewrite(kc_current_view_base);
    idents l_idents_1 =
	idents_1->rewrite(kc_current_view_base);
    if ((l_identList_1 == identList_1) &&  (l_idents_1 == idents_1))
	return this;
    else {
	impl_identList_IdentList* kc_result= IdentList(l_identList_1, l_idents_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

identList impl_identList_EmptyIdentList::rewrite(rview kc_current_view_base)
{
    return this;

}

idents impl_idents_Idents::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    optionalNumber l_optionalNumber_1 =
	optionalNumber_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_optionalNumber_1 == optionalNumber_1))
	return this;
    else {
	impl_idents_Idents* kc_result= Idents(l_casestring_1, l_optionalNumber_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

structTypeList impl_structTypeList_StructTypeList::rewrite(rview kc_current_view_base)
{
    structTypeList l_structTypeList_1 =
	structTypeList_1->rewrite(kc_current_view_base);
    structType l_structType_1 =
	structType_1->rewrite(kc_current_view_base);
    if ((l_structTypeList_1 == structTypeList_1) &&  (l_structType_1 == structType_1))
	return this;
    else {
	impl_structTypeList_StructTypeList* kc_result= StructTypeList(l_structTypeList_1, l_structType_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

structTypeList impl_structTypeList_EmptyStructTypeList::rewrite(rview kc_current_view_base)
{
    return this;

}

structType impl_structType_StructType::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1))
	return this;
    else {
	impl_structType_StructType* kc_result= StructType(l_type_1, l_casestring_1, l_arrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

varOrArray impl_varOrArray_VarOrArray::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1))
	return this;
    else {
	impl_varOrArray_VarOrArray* kc_result= VarOrArray(l_casestring_1, l_arrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

arrayList impl_arrayList_ArrayList::rewrite(rview kc_current_view_base)
{
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_arrayList_1 == arrayList_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_arrayList_ArrayList* kc_result= ArrayList(l_arrayList_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

arrayList impl_arrayList_EmptyArrayList::rewrite(rview kc_current_view_base)
{
    return this;

}

functionParametersList impl_functionParametersList_FunctionParametersList::rewrite(rview kc_current_view_base)
{
    functionParameters l_functionParameters_1 =
	functionParameters_1->rewrite(kc_current_view_base);
    functionParametersList l_functionParametersList_1 =
	functionParametersList_1->rewrite(kc_current_view_base);
    if ((l_functionParameters_1 == functionParameters_1) &&  (l_functionParametersList_1 == functionParametersList_1))
	return this;
    else {
	impl_functionParametersList_FunctionParametersList* kc_result= FunctionParametersList(l_functionParameters_1, l_functionParametersList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

functionParametersList impl_functionParametersList_EmptyFunctionParametersList::rewrite(rview kc_current_view_base)
{
    return this;

}

functionParameters impl_functionParameters_FunctionParameters::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    varOrArray l_varOrArray_1 =
	varOrArray_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_varOrArray_1 == varOrArray_1))
	return this;
    else {
	impl_functionParameters_FunctionParameters* kc_result= FunctionParameters(l_type_1, l_varOrArray_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprAll::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1))
	return this;
    else {
	impl_expression_ExprAll* kc_result= ExprAll(l_type_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprOtherIf::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expression l_expression_3 =
	expression_3->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expression_3 == expression_3))
	return this;
    else {
	impl_expression_ExprOtherIf* kc_result= ExprOtherIf(l_expression_1, l_expression_2, l_expression_3);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprCommaSeparated::rewrite(rview kc_current_view_base)
{
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_expression_ExprCommaSeparated* kc_result= ExprCommaSeparated(l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_FunctionCall::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_expression_FunctionCall* kc_result= FunctionCall(l_casestring_1, l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprGreaterOrEqual::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprGreaterOrEqual* kc_result= ExprGreaterOrEqual(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprLessOrEqual::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprLessOrEqual* kc_result= ExprLessOrEqual(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprGreaterThan::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprGreaterThan* kc_result= ExprGreaterThan(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprLessThan::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprLessThan* kc_result= ExprLessThan(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprNotEqual::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprNotEqual* kc_result= ExprNotEqual(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprEquivalent::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprEquivalent* kc_result= ExprEquivalent(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprFalse::rewrite(rview kc_current_view_base)
{
    return this;

}

expression impl_expression_ExprTrue::rewrite(rview kc_current_view_base)
{
    return this;

}

expression impl_expression_ExprOr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprOr* kc_result= ExprOr(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprAnd::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprAnd* kc_result= ExprAnd(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_NotExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_NotExpr* kc_result= NotExpr(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprNumber::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_expression_ExprNumber* kc_result= ExprNumber(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprModulo::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprModulo* kc_result= ExprModulo(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprDivision::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprDivision* kc_result= ExprDivision(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprMultiplication::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprMultiplication* kc_result= ExprMultiplication(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprSubtraction::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprSubtraction* kc_result= ExprSubtraction(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprAddition::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprAddition* kc_result= ExprAddition(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_NegativeExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_NegativeExpr* kc_result= NegativeExpr(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_PositiveExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_PositiveExpr* kc_result= PositiveExpr(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ValDecrement::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_ValDecrement* kc_result= ValDecrement(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ValIncrement::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_ValIncrement* kc_result= ValIncrement(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_DecrementVal::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_DecrementVal* kc_result= DecrementVal(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_IncrementVal::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_IncrementVal* kc_result= IncrementVal(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignMod::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignMod* kc_result= AssignMod(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignDivide::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignDivide* kc_result= AssignDivide(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignTimes::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignTimes* kc_result= AssignTimes(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignMinus::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignMinus* kc_result= AssignMinus(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignPlus::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignPlus* kc_result= AssignPlus(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignEqual::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignEqual* kc_result= AssignEqual(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprInitializerList::rewrite(rview kc_current_view_base)
{
    initializerList l_initializerList_1 =
	initializerList_1->rewrite(kc_current_view_base);
    if ((l_initializerList_1 == initializerList_1))
	return this;
    else {
	impl_expression_ExprInitializerList* kc_result= ExprInitializerList(l_initializerList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprLeftvalue::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_ExprLeftvalue* kc_result= ExprLeftvalue(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

leftvalue impl_leftvalue_LeftValDot::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_casestring_1 == casestring_1))
	return this;
    else {
	impl_leftvalue_LeftValDot* kc_result= LeftValDot(l_leftvalue_1, l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

leftvalue impl_leftvalue_LeftValBrackets::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_leftvalue_LeftValBrackets* kc_result= LeftValBrackets(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

leftvalue impl_leftvalue_LeftValIdent::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1))
	return this;
    else {
	impl_leftvalue_LeftValIdent* kc_result= LeftValIdent(l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionlist impl_expressionlist_ExpressionList::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_expressionlist_ExpressionList* kc_result= ExpressionList(l_expression_1, l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionlist impl_expressionlist_EmptyExpressionList::rewrite(rview kc_current_view_base)
{
    return this;

}

initializerList impl_initializerList_ExprInBracesColon::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expressionListColon l_expressionListColon_1 =
	expressionListColon_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expressionListColon_1 == expressionListColon_1))
	return this;
    else {
	impl_initializerList_ExprInBracesColon* kc_result= ExprInBracesColon(l_expression_1, l_expression_2, l_expressionListColon_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

initializerList impl_initializerList_ExprInBraces::rewrite(rview kc_current_view_base)
{
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_initializerList_ExprInBraces* kc_result= ExprInBraces(l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionListColon impl_expressionListColon_ExpressionListColon::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expressionListColon l_expressionListColon_1 =
	expressionListColon_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expressionListColon_1 == expressionListColon_1))
	return this;
    else {
	impl_expressionListColon_ExpressionListColon* kc_result= ExpressionListColon(l_expression_1, l_expression_2, l_expressionListColon_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionListColon impl_expressionListColon_EmptyExpressionListColon::rewrite(rview kc_current_view_base)
{
    return this;

}

placeblocklist impl_placeblocklist_PlaceBlockList::rewrite(rview kc_current_view_base)
{
    placeblock l_placeblock_1 =
	placeblock_1->rewrite(kc_current_view_base);
    placeblocklist l_placeblocklist_1 =
	placeblocklist_1->rewrite(kc_current_view_base);
    if ((l_placeblock_1 == placeblock_1) &&  (l_placeblocklist_1 == placeblocklist_1))
	return this;
    else {
	impl_placeblocklist_PlaceBlockList* kc_result= PlaceBlockList(l_placeblock_1, l_placeblocklist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

placeblocklist impl_placeblocklist_EmptyPlaceBlockList::rewrite(rview kc_current_view_base)
{
    return this;

}

optSafe impl_optSafe_Safe::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_optSafe_Safe* kc_result= Safe(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

optSafe impl_optSafe_EmptySafe::rewrite(rview kc_current_view_base)
{
    return this;

}

place impl_place_Place::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1))
	return this;
    else {
	impl_place_Place* kc_result= Place(l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

placelist impl_placelist_PlaceList::rewrite(rview kc_current_view_base)
{
    place l_place_1 =
	place_1->rewrite(kc_current_view_base);
    placelist l_placelist_1 =
	placelist_1->rewrite(kc_current_view_base);
    if ((l_place_1 == place_1) &&  (l_placelist_1 == placelist_1))
	return this;
    else {
	impl_placelist_PlaceList* kc_result= PlaceList(l_place_1, l_placelist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

placelist impl_placelist_EmptyPlaceList::rewrite(rview kc_current_view_base)
{
    return this;

}

placeblock impl_placeblock_PlaceBlock::rewrite(rview kc_current_view_base)
{
    optSafe l_optSafe_1 =
	optSafe_1->rewrite(kc_current_view_base);
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    placelist l_placelist_1 =
	placelist_1->rewrite(kc_current_view_base);
    if ((l_optSafe_1 == optSafe_1) &&  (l_type_1 == type_1) &&  (l_placelist_1 == placelist_1))
	return this;
    else {
	impl_placeblock_PlaceBlock* kc_result= PlaceBlock(l_optSafe_1, l_type_1, l_placelist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

marking impl_marking_Marking::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    marking l_marking_1 =
	marking_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_marking_1 == marking_1))
	return this;
    else {
	impl_marking_Marking* kc_result= Marking(l_casestring_1, l_expression_1, l_marking_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

marking impl_marking_EmptyMarking::rewrite(rview kc_current_view_base)
{
    return this;

}

transition impl_transition_Transition::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    fairness l_fairness_1 =
	fairness_1->rewrite(kc_current_view_base);
    variable l_variable_1 =
	variable_1->rewrite(kc_current_view_base);
    guard l_guard_1 =
	guard_1->rewrite(kc_current_view_base);
    identExprList l_identExprList_1 =
	identExprList_1->rewrite(kc_current_view_base);
    identExprList l_identExprList_2 =
	identExprList_2->rewrite(kc_current_view_base);
    transition l_transition_1 =
	transition_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_fairness_1 == fairness_1) &&  (l_variable_1 == variable_1) &&  (l_guard_1 == guard_1) &&  (l_identExprList_1 == identExprList_1) &&  (l_identExprList_2 == identExprList_2) &&  (l_transition_1 == transition_1))
	return this;
    else {
	impl_transition_Transition* kc_result= Transition(l_casestring_1, l_fairness_1, l_variable_1, l_guard_1, l_identExprList_1, l_identExprList_2, l_transition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

transition impl_transition_EmptyTransition::rewrite(rview kc_current_view_base)
{
    return this;

}

fairness impl_fairness_StrongFair::rewrite(rview kc_current_view_base)
{
    return this;

}

fairness impl_fairness_WeakFair::rewrite(rview kc_current_view_base)
{
    return this;

}

fairness impl_fairness_EmptyFairness::rewrite(rview kc_current_view_base)
{
    return this;

}

variable impl_variable_Variable::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    varOrArrayList l_varOrArrayList_1 =
	varOrArrayList_1->rewrite(kc_current_view_base);
    variable l_variable_1 =
	variable_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_varOrArrayList_1 == varOrArrayList_1) &&  (l_variable_1 == variable_1))
	return this;
    else {
	impl_variable_Variable* kc_result= Variable(l_type_1, l_varOrArrayList_1, l_variable_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

variable impl_variable_EmptyVariable::rewrite(rview kc_current_view_base)
{
    return this;

}

varOrArrayList impl_varOrArrayList_VarOrArrayList::rewrite(rview kc_current_view_base)
{
    varOrArray l_varOrArray_1 =
	varOrArray_1->rewrite(kc_current_view_base);
    varOrArrayList l_varOrArrayList_1 =
	varOrArrayList_1->rewrite(kc_current_view_base);
    if ((l_varOrArray_1 == varOrArray_1) &&  (l_varOrArrayList_1 == varOrArrayList_1))
	return this;
    else {
	impl_varOrArrayList_VarOrArrayList* kc_result= VarOrArrayList(l_varOrArray_1, l_varOrArrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

varOrArrayList impl_varOrArrayList_EmptyVarOrArrayList::rewrite(rview kc_current_view_base)
{
    return this;

}

guard impl_guard_Guard::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_guard_Guard* kc_result= Guard(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

identExprList impl_identExprList_IdentExprList::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    identExprList l_identExprList_1 =
	identExprList_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_identExprList_1 == identExprList_1))
	return this;
    else {
	impl_identExprList_IdentExprList* kc_result= IdentExprList(l_casestring_1, l_expression_1, l_identExprList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

identExprList impl_identExprList_EmptyIdentExprList::rewrite(rview kc_current_view_base)
{
    return this;

}

block impl_block_Block::rewrite(rview kc_current_view_base)
{
    declarationOrStatement l_declarationOrStatement_1 =
	declarationOrStatement_1->rewrite(kc_current_view_base);
    if ((l_declarationOrStatement_1 == declarationOrStatement_1))
	return this;
    else {
	impl_block_Block* kc_result= Block(l_declarationOrStatement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

declarationOrStatement impl_declarationOrStatement_DeclOrStatemStatement::rewrite(rview kc_current_view_base)
{
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    declarationOrStatement l_declarationOrStatement_1 =
	declarationOrStatement_1->rewrite(kc_current_view_base);
    if ((l_statement_1 == statement_1) &&  (l_declarationOrStatement_1 == declarationOrStatement_1))
	return this;
    else {
	impl_declarationOrStatement_DeclOrStatemStatement* kc_result= DeclOrStatemStatement(l_statement_1, l_declarationOrStatement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

declarationOrStatement impl_declarationOrStatement_DeclOrStatemDeclaration::rewrite(rview kc_current_view_base)
{
    declaration l_declaration_1 =
	declaration_1->rewrite(kc_current_view_base);
    declarationOrStatement l_declarationOrStatement_1 =
	declarationOrStatement_1->rewrite(kc_current_view_base);
    if ((l_declaration_1 == declaration_1) &&  (l_declarationOrStatement_1 == declarationOrStatement_1))
	return this;
    else {
	impl_declarationOrStatement_DeclOrStatemDeclaration* kc_result= DeclOrStatemDeclaration(l_declaration_1, l_declarationOrStatement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

declarationOrStatement impl_declarationOrStatement_EmptyDeclarationOrStatement::rewrite(rview kc_current_view_base)
{
    return this;

}

declaration impl_declaration_Declaration::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    varOrArrayList l_varOrArrayList_1 =
	varOrArrayList_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_varOrArrayList_1 == varOrArrayList_1))
	return this;
    else {
	impl_declaration_Declaration* kc_result= Declaration(l_type_1, l_varOrArrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementSkip::rewrite(rview kc_current_view_base)
{
    return this;

}

statement impl_statement_StatementReturn::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_statement_StatementReturn* kc_result= StatementReturn(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementContinue::rewrite(rview kc_current_view_base)
{
    return this;

}

statement impl_statement_StatementBreak::rewrite(rview kc_current_view_base)
{
    return this;

}

statement impl_statement_StatementSwitch::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    switchCaseList l_switchCaseList_1 =
	switchCaseList_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_switchCaseList_1 == switchCaseList_1))
	return this;
    else {
	impl_statement_StatementSwitch* kc_result= StatementSwitch(l_expression_1, l_switchCaseList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForAll::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    type l_type_2 =
	type_2->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_type_2 == type_2))
	return this;
    else {
	impl_statement_StatementForAll* kc_result= StatementForAll(l_type_1, l_casestring_1, l_type_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForIdentColon::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementForIdentColon* kc_result= StatementForIdentColon(l_casestring_1, l_expression_1, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForTypeExpr::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expression l_expression_3 =
	expression_3->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expression_3 == expression_3) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementForTypeExpr* kc_result= StatementForTypeExpr(l_type_1, l_casestring_1, l_expression_1, l_expression_2, l_expression_3, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expression l_expression_3 =
	expression_3->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expression_3 == expression_3) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementForExpr* kc_result= StatementForExpr(l_expression_1, l_expression_2, l_expression_3, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementDoWhile::rewrite(rview kc_current_view_base)
{
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_statement_1 == statement_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_statement_StatementDoWhile* kc_result= StatementDoWhile(l_statement_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementWhile::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementWhile* kc_result= StatementWhile(l_expression_1, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementIf::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    statement l_statement_2 =
	statement_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_statement_1 == statement_1) &&  (l_statement_2 == statement_2))
	return this;
    else {
	impl_statement_StatementIf* kc_result= StatementIf(l_expression_1, l_statement_1, l_statement_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementExprSemicolon::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_statement_StatementExprSemicolon* kc_result= StatementExprSemicolon(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementBlock::rewrite(rview kc_current_view_base)
{
    block l_block_1 =
	block_1->rewrite(kc_current_view_base);
    if ((l_block_1 == block_1))
	return this;
    else {
	impl_statement_StatementBlock* kc_result= StatementBlock(l_block_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCase impl_switchCase_SwitchDefault::rewrite(rview kc_current_view_base)
{
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_statement_1 == statement_1))
	return this;
    else {
	impl_switchCase_SwitchDefault* kc_result= SwitchDefault(l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCase impl_switchCase_SwitchCase::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_switchCase_SwitchCase* kc_result= SwitchCase(l_expression_1, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCaseList impl_switchCaseList_SwitchCaseList::rewrite(rview kc_current_view_base)
{
    switchCase l_switchCase_1 =
	switchCase_1->rewrite(kc_current_view_base);
    switchCaseList l_switchCaseList_1 =
	switchCaseList_1->rewrite(kc_current_view_base);
    if ((l_switchCase_1 == switchCase_1) &&  (l_switchCaseList_1 == switchCaseList_1))
	return this;
    else {
	impl_switchCaseList_SwitchCaseList* kc_result= SwitchCaseList(l_switchCase_1, l_switchCaseList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCaseList impl_switchCaseList_EmptySwitchCaseList::rewrite(rview kc_current_view_base)
{
    return this;

}

} // namespace kc
