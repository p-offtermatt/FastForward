/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#define KC_UNPARSE

#include <stdio.h>
#include <string>
#include <stdlib.h>
#include "ast-system-k.h"
#include "ast-system-unpk.h"


namespace kc {
base_uview_class base_uview;
out_class out;
temporal_class temporal;
internal_class internal;
buechi_class buechi;
ctl_class ctl;
ltl_class ltl;
toplevelboolean_class toplevelboolean;
compound_class compound;
problemwriter_class problemwriter;
orsAndAndsAndLength_class orsAndAndsAndLength;
hl_staticanalysis_class hl_staticanalysis;
countdeadlock_class countdeadlock;

impl_uviews uviews[] = {
    {"base_uview",&base_uview},
    {"out",&out},
    {"temporal",&temporal},
    {"internal",&internal},
    {"buechi",&buechi},
    {"ctl",&ctl},
    {"ltl",&ltl},
    {"toplevelboolean",&toplevelboolean},
    {"compound",&compound},
    {"problemwriter",&problemwriter},
    {"orsAndAndsAndLength",&orsAndAndsAndLength},
    {"hl_staticanalysis",&hl_staticanalysis},
    {"countdeadlock",&countdeadlock},
    {0,0}
};

} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 19 "Frontend/Parser/formula_unparse.k"
// LCOV_EXCL_START
/*!
\brief printer-function for Kimiwtu's output on stdout

To use an unparser in Kimwitu++, a function with this signature needs to be
passed to the unparse() function.

\param[in] s  string to print

\note This function is not "found" by the code coverage detection and is hence
hidden from it.
*/
void myprinter(const char *s, kc::uview)
{
    printf("%s", s);
}
// LCOV_EXCL_STOP

/// result string for stringprinter
std::string unparsed;

// LCOV_EXCL_START
/*!
\brief printer-function for Kimiwtu's output to a string object

To use an unparser in Kimwitu++, a function with this signature needs to be
passed to the unparse() function.

\param[in] s  string to add

\note This function is not "found" by the code coverage detection and is hence
hidden from it.
\post Output is written to string unparsed which can be accessed wherever an
unparser can be used. You need to clear the string after use to avoid keeping
old data.
*/
void stringprinter(const char *s, kc::uview)
{
    unparsed += s;
}
// LCOV_EXCL_STOP

bool *place_in_formula = NULL;
unsigned int places_mentioned = 0;
unsigned int unique_places_mentioned = 0;

#line  102 "ast-system-unpk.cc"
#line 736 "Frontend/Parser/formula_unparse.k"
#include <config.h>
#include <Core/Dimensions.h>
#include <Formula/StatePredicate/AtomicStatePredicate.h>
#include <Formula/StatePredicate/ConjunctionStatePredicate.h>
#include <Formula/StatePredicate/DisjunctionStatePredicate.h>
#include <Formula/StatePredicate/FalsePredicate.h>
#include <Formula/StatePredicate/StatePredicate.h>
#include <Formula/StatePredicate/TruePredicate.h>
#include <Net/Marking.h>
#include <Net/Net.h>

#include <map>
#include <vector>
#include <stack>

// mapping from node ids to factors
std::map<int, int> current;

// mapping from tree node ids to list of intermediate formulas
std::map<int, std::vector<StatePredicate *> > formulas;

// invariant: top is always my parent
std::stack<size_t> id_stack;

// next free id
size_t nextId = 0;

#line  131 "ast-system-unpk.cc"
#line 1066 "Frontend/Parser/formula_unparse.k"
std::map<uint32_t, std::vector<std::pair<uint32_t,uint32_t> > > transitions ;
std::set<uint32_t> acceptingset;
std::map<uint32_t, StatePredicate*> predicates;
std::map<uint32_t, uint32_t> states_to_interal;

uint32_t get_state_number(uint32_t state){
    if (states_to_interal.find(state) == states_to_interal.end()){
	// get a new state number
	uint32_t new_state_number = states_to_interal.size();
	states_to_interal[state] = new_state_number;
	return new_state_number;
    }
    return states_to_interal[state];
}

#line  148 "ast-system-unpk.cc"
#line 1178 "Frontend/Parser/formula_unparse.k"

#include <Core/Dimensions.h>
#include <Exploration/StatePredicateProperty.h>
#include <Formula/CTL/AUFormula.h>
#include <Formula/CTL/AXFormula.h>
#include <Formula/CTL/AtomicFormula.h>
#include <Formula/CTL/CTLFormula.h>
#include <Formula/CTL/ConjunctionFormula.h>
#include <Formula/CTL/DisjunctionFormula.h>
#include <Formula/CTL/EUFormula.h>
#include <Formula/CTL/EXFormula.h>
#include <Formula/CTL/NotFormula.h>
#include <Net/Net.h>

#include <map>
#include <vector>
#include <stack>

// mapping from node ids to factors
std::map<int, int> ctl_current;

// mapping from tree node ids to list of intermediate formulas
std::map<int, std::vector<CTLFormula_p> > ctl_formulas;

// invariant: top is always my parent
std::stack<size_t> ctl_id_stack;

// next free id
size_t ctl_nextId = 0;

// needs dfs-storage;
size_t ctl_dfs_id = 0;

// needs cached results id
size_t ctl_result_cache_id = 0;

// temporal storage to be able to include the LessEqualStatePredicate into an AtomicFormula
StatePredicateProperty* spp;

#line  189 "ast-system-unpk.cc"
#line 1379 "Frontend/Parser/formula_unparse.k"
#include <Core/Runtime.h>
#include <Frontend/Parser/ast-system-rk.h>
#include <vector>

std::vector<LTLTree_p> ltlstack;

#line  197 "ast-system-unpk.cc"
#line 1524 "Frontend/Parser/formula_unparse.k"
#include <Core/Runtime.h>
#include <Frontend/Parser/ast-system-rk.h>
#include <vector>
#include <Planning/Task.h>
#include <Planning/ConjunctionTask.h>
#include <Planning/DisjunctionTask.h>
#include <Planning/LeafTask.h>

#line  207 "ast-system-unpk.cc"
#line 1582 "Frontend/Parser/formula_unparse.k"
#include <Core/Runtime.h>
#include <Frontend/Parser/ast-system-rk.h>
#include <vector>
#include <Planning/Task.h>
#include <Planning/CompoundTask.h>
#include <Planning/LeafTask.h>

#line  216 "ast-system-unpk.cc"
#line 1634 "Frontend/Parser/formula_unparse.k"
#include <Core/Runtime.h>
#include <Net/Net.h>

#ifndef __cplusplus11
inline std::string int_to_string(int i) {
    std::stringstream s;
    s << i;
    return s.str();
}
#endif

bool is_first = false;

#line  231 "ast-system-unpk.cc"
#line 1857 "Frontend/Parser/formula_unparse.k"

#line  234 "ast-system-unpk.cc"
/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif

void
impl_abstract_phylum::unparse(printer_function opf, uview uv)
{
    printer_functor_function_wrapper pf(opf);
    do_unparse(pf, uv);
}

// Everything given as a pointer is expected to have an unparse-method (we
// believe it's a phylum), unless there's a specialisation for it

void
unparse(abstract_phylum kc_p, printer_functor kc_printer, uview kc_current_view)
{
    kc_p->unparse(kc_printer, kc_current_view);
}

void
unparse(void *kc_p, printer_functor kc_printer, uview kc_current_view)
{
    // MPi: 20020628 there shouldn't be any left
    assertionFailed("Unparse called for untyped pointer");
    // MPi: cast should be unnecessary, but there are still void*
    reinterpret_cast<impl_abstract_phylum*>(kc_p)->unparse(kc_printer, kc_current_view);
}

void
unparse(int kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_char_t kc_string[200];
    kc_print_integer(kc_string, kc_v);
    kc_printer(kc_string, kc_current_view);
}

void
unparse(double kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_char_t kc_string[200];
    kc_print_real(kc_string, kc_v);
    kc_printer(kc_string, kc_current_view);
}

void
unparse(kc_char_t *kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_printer(kc_v, kc_current_view);
}

void
unparse(kc_string_t kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_printer(kc_v.c_str(), kc_current_view);
}

#line  297 "ast-system-unpk.cc"
void
impl_abstract_phylum::default_unparse(printer_functor kc_printer, uview kc_current_view)
{
    register int no_sons = operator_info[prod_sel()].no_sons;
    for (int i=0; i < no_sons; i++)
    subphylum(i)->unparse(kc_printer, kc_current_view);
}

void
impl_casestring__Str::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(name, kc_printer, kc_current_view);
}

void
impl_nocasestring_NoCaseStr::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(name, kc_printer, kc_current_view);
}

void
impl_integer__Int::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(value, kc_printer, kc_current_view);
}

void
impl_real__Real::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(value, kc_printer, kc_current_view);
}

void
impl_voidptr__VoidPtr::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(pointer, kc_printer, kc_current_view);
}


#line  337 "ast-system-unpk.cc"
void
impl_tFormula_Compound::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2415 "Frontend/Parser/formula_unparse.k"
		const tFormula x = this->tFormula_1;
#line 2415 "Frontend/Parser/formula_unparse.k"
		const tFormula y = this->tFormula_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2415 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock + y -> containsDeadlock;
#line  353 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1591 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1591 "Frontend/Parser/formula_unparse.k"
		const tFormula x = this->tFormula_1;
#line 1591 "Frontend/Parser/formula_unparse.k"
		const tFormula y = this->tFormula_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1592 "Frontend/Parser/formula_unparse.k"

		f->task = new CompoundTask(x->task,y->task);

#line  372 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 278 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 278 "Frontend/Parser/formula_unparse.k"
		const tFormula x = this->tFormula_1;
#line 278 "Frontend/Parser/formula_unparse.k"
		const tFormula y = this->tFormula_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 279 "Frontend/Parser/formula_unparse.k"

		f -> type = FORMULA_COMPOUND; 
		f -> cannotcompute = x -> cannotcompute || y -> cannotcompute;

#line  392 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 85 "Frontend/Parser/formula_unparse.k"
		const tFormula x = this->tFormula_1;
#line 85 "Frontend/Parser/formula_unparse.k"
		const tFormula y = this->tFormula_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" : "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  410 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  423 "ast-system-unpk.cc"
void
impl_tFormula_ComputeBound::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_LessEqualAtomicProposition)) {
#line 2416 "Frontend/Parser/formula_unparse.k"
		const tTerm x = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(this->tAtomicProposition_1)->tTerm_1;
#line 2416 "Frontend/Parser/formula_unparse.k"
		const tTerm y = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(this->tAtomicProposition_1)->tTerm_2;
#line 2416 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  437 "ast-system-unpk.cc"
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1597 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1598 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  451 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_LessEqualAtomicProposition) && (phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(this->tAtomicProposition_1)->tTerm_2->prod_sel() == sel_Number)) {
#line 1007 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1007 "Frontend/Parser/formula_unparse.k"
		const tTerm x = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(this->tAtomicProposition_1)->tTerm_1;
#line 1007 "Frontend/Parser/formula_unparse.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(this->tAtomicProposition_1)->tTerm_2)->integer_1;
#line 1008 "Frontend/Parser/formula_unparse.k"


		current.clear();
		formulas.clear();
		while (not id_stack.empty())
		id_stack.pop();
		nextId = 0;
		id_stack.push(nextId++);

#line  474 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 1018 "Frontend/Parser/formula_unparse.k"

		arrayindex_t factors_positive = 0;
		arrayindex_t factors_negative = 0;


		for (std::map<int, int>::const_iterator it = current.begin(); it != current.end(); ++it)
		{
		    if (it->second > 0)
		    {
			factors_positive++;
		    }
		    else if (it->second < 0)
		    {
			factors_negative++;
		    }
		}


		StatePredicate *g = new AtomicStatePredicate(factors_positive, factors_negative, y->value);
		arrayindex_t position_pos = 0;
		arrayindex_t position_neg = 0;


		for (std::map<int, int>::const_iterator it = current.begin(); it != current.end(); ++it)
		{
		    if (it->second > 0)
		    {
			((AtomicStatePredicate*)g)->addPos(position_pos++, it->first, it->second);
		    }
		    else if (it->second < 0)
		    {
			((AtomicStatePredicate*)g)->addNeg(position_neg++, it->first, -it->second);
		    }
		}


		current.clear();


		f -> formula = g;

#line  518 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 284 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 284 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 285 "Frontend/Parser/formula_unparse.k"

		f -> type = FORMULA_BOUND; 
		f -> cannotcompute = false;

#line  535 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_LessEqualAtomicProposition)) {
#line 86 "Frontend/Parser/formula_unparse.k"
		const tTerm x = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(this->tAtomicProposition_1)->tTerm_1;
#line 86 "Frontend/Parser/formula_unparse.k"
		const tTerm y = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(this->tAtomicProposition_1)->tTerm_2;
		{ kc_printer(kc_t("MAX("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" - "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    } else
		    goto kc_unparsing_default;
	    break;
	}

#line  556 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  570 "ast-system-unpk.cc"
void
impl_tFormula_StatePredicateFormula::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2414 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2414 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  583 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1859 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1859 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1859 "Frontend/Parser/formula_unparse.k"


		f -> length = x -> length;
		f -> number_of_and = x -> number_of_and;
		f -> number_of_or = x -> number_of_or;
		f -> number_of_or_dnf = x -> number_of_or_dnf;
		f -> only_fireable = x -> only_fireable;


#line  605 "ast-system-unpk.cc"
	    }
	    break;
	}
	case problemwriter_enum: {
	    problemwriter_class& kc_current_view=static_cast<problemwriter_class&>(kc_current_view_base);
	    if ((this->tStatePredicate_1->prod_sel() == sel_AtomicProposition)) {
#line 1648 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(this->tStatePredicate_1)->tAtomicProposition_1;
		{ kc_printer(kc_t("PROBLEM saraProblem:\n"), kc_current_view); }
		{ kc_printer(kc_t("GOAL REACHABILITY;\n"), kc_current_view); }
		{ kc_printer(kc_t("FILE "), kc_current_view); }
#line 1652 "Frontend/Parser/formula_unparse.k"
		kc_printer(RT::args.inputs[0], kc_current_view); 
#line  619 "ast-system-unpk.cc"
			{ kc_printer(kc_t(" TYPE LOLA;\n"), kc_current_view); }
		{ kc_printer(kc_t("INITIAL "), kc_current_view); }
#line 1655 "Frontend/Parser/formula_unparse.k"

		is_first = false;
		for (arrayindex_t i = 0; i < Net::Card[PL]; i++)
		{
		    if (Marking::Initial[i] > 0)
		    {
			if (!is_first)
			{
			    kc_printer(kc_t(Net::Name[PL][i]), kc_current_view);
#ifdef __cplusplus11                    
			    kc_printer((":" + std::to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#else
			    kc_printer((":" + int_to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#endif
			    is_first = true;
			}
			else
			{
			    kc_printer(",", kc_current_view);
			    kc_printer(kc_t(Net::Name[PL][i]), kc_current_view);
#ifdef __cplusplus11                    
			    kc_printer((":" + std::to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#else
			    kc_printer((":" + int_to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#endif
			}
		    }
		}

#line  656 "ast-system-unpk.cc"
		{ kc_printer(kc_t(";\n"), kc_current_view); }
		{ kc_printer(kc_t("FINAL COVER;\n"), kc_current_view); }
		{ kc_printer(kc_t("CONSTRAINTS "), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";"), kc_current_view); }
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ConjunctionList)) {
#line 1692 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = phylum_cast<const impl_tStatePredicate_ConjunctionList*>(this->tStatePredicate_1)->tConjunction_list_1;
		{ kc_printer(kc_t("PROBLEM saraProblem:\n"), kc_current_view); }
		{ kc_printer(kc_t("GOAL REACHABILITY;\n"), kc_current_view); }
		{ kc_printer(kc_t("FILE "), kc_current_view); }
#line 1696 "Frontend/Parser/formula_unparse.k"
		kc_printer(RT::args.inputs[0], kc_current_view); 
#line  671 "ast-system-unpk.cc"
			{ kc_printer(kc_t(" TYPE LOLA;\n"), kc_current_view); }
		{ kc_printer(kc_t("INITIAL "), kc_current_view); }
#line 1699 "Frontend/Parser/formula_unparse.k"

		for (arrayindex_t i = 0; i < Net::Card[PL]; i++)
		{
		    if (Marking::Initial[i] > 0)
		    {
			if (!is_first)
			{
			    kc_printer(kc_t(Net::Name[PL][i]), kc_current_view);
#ifdef __cplusplus11                    
			    kc_printer((":" + std::to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#else
			    kc_printer((":" + int_to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#endif
			    is_first = true;
			}
			else
			{
			    kc_printer(",", kc_current_view);
			    kc_printer(kc_t(Net::Name[PL][i]), kc_current_view);
#ifdef __cplusplus11                    
			    kc_printer((":" + std::to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#else
			    kc_printer((":" + int_to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#endif
			}
		    }
		}

#line  707 "ast-system-unpk.cc"
		{ kc_printer(kc_t(";\n"), kc_current_view); }
		{ kc_printer(kc_t("FINAL COVER;\n"), kc_current_view); }
		{ kc_printer(kc_t("CONSTRAINTS "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";"), kc_current_view); }
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_DisjunctionList)) {
#line 1741 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = phylum_cast<const impl_tStatePredicate_DisjunctionList*>(this->tStatePredicate_1)->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1596 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1598 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  731 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1533 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1533 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1534 "Frontend/Parser/formula_unparse.k"

		f->task = x->task;

#line  747 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1387 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1387 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1389 "Frontend/Parser/formula_unparse.k"


		f->ltl_tree = bin_simpler(push_negation(tl_nn(NOT, ltlstack.back(), NULL)));


#line  765 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1244 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1244 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1244 "Frontend/Parser/formula_unparse.k"

		f->unparse(myprinter, kc::temporal);

		ctl_id_stack.push(ctl_nextId++);

#line  782 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 1250 "Frontend/Parser/formula_unparse.k"

		ctl_nextId = ctl_id_stack.top();
		ctl_id_stack.pop();


		assert(ctl_nextId == 0);
		f->ctl_formula = ctl_formulas[0][0];
		f->ctl_formula->payloadsize = ctl_dfs_id*SIZEOF_STATENUMBER_T + (2*ctl_result_cache_id+7)/8;

#line  794 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 764 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 764 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 764 "Frontend/Parser/formula_unparse.k"


		current.clear();
		formulas.clear();
		while (not id_stack.empty())
		id_stack.pop();
		nextId = 0;
		id_stack.push(nextId++);

#line  815 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 774 "Frontend/Parser/formula_unparse.k"

		nextId = id_stack.top();
		id_stack.pop();

		assert(nextId == 0);
		assert(formulas[0].size() == 1);
		f->formula = formulas[0][0];

#line  826 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 291 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 291 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 292 "Frontend/Parser/formula_unparse.k"

		f -> type = x -> type; 
		f -> cannotcompute = x -> cannotcompute || 
		(! x -> validLTLFormula) || (! x -> validCTLStateFormula);

#line  844 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 84 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  858 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  872 "ast-system-unpk.cc"
void
impl_tStatePredicate_DisjunctionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2448 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
#line 2448 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = l -> containsDeadlock;
#line  885 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 841 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
#line 841 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  898 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 845 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new DisjunctionStatePredicate(l->length());

		for (int i = 0; i < l->length(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((DisjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  916 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 117 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  932 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  945 "ast-system-unpk.cc"
void
impl_tStatePredicate_ConjunctionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2443 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
#line 2443 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = l -> containsDeadlock;
#line  958 "ast-system-unpk.cc"
	    }
	    break;
	}
	case problemwriter_enum: {
	    problemwriter_class& kc_current_view=static_cast<problemwriter_class&>(kc_current_view_base);
	    {
#line 1734 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 802 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
#line 802 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  980 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 806 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new ConjunctionStatePredicate(l->length());

		for (int i = 0; i < l->length(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((ConjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  998 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 113 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1014 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1027 "ast-system-unpk.cc"
void
impl_tStatePredicate_EX::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2439 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2439 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  1040 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1623 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1053 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1568 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1066 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1339 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1339 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  1079 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 1343 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		EXFormula* exf = new EXFormula(ctl_formulas[myId][0]);

		ctl_formulas[ctl_id_stack.top()].push_back(exf);

#line  1092 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 696 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 696 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 697 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		} 

#line  1116 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 109 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EX("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1132 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1145 "ast-system-unpk.cc"
void
impl_tStatePredicate_AX::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2438 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2438 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  1158 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1622 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1171 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1567 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1184 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1305 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1305 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  1197 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 1309 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		AXFormula* axf = new AXFormula(ctl_formulas[myId][0]);

		ctl_formulas[ctl_id_stack.top()].push_back(axf);

#line  1210 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 709 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 709 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 710 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		if (x -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		    f->cannotcompute = false;
		}
		else
		{
		    f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		    if(!f->cannotcompute)
		    {
			f->type = FORMULA_CTL;
		    }  
		}

#line  1242 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 108 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AX("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1258 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1271 "ast-system-unpk.cc"
void
impl_tStatePredicate_EG::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2441 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2441 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  1284 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1625 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1297 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1570 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1310 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 696 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 696 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 697 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		} 

#line  1334 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 111 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EG("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1350 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1363 "ast-system-unpk.cc"
void
impl_tStatePredicate_AG::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2437 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2437 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  1376 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1621 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1389 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1566 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1402 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 709 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 709 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 710 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		if (x -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		    f->cannotcompute = false;
		}
		else
		{
		    f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		    if(!f->cannotcompute)
		    {
			f->type = FORMULA_CTL;
		    }  
		}

#line  1434 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 107 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AG("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1450 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1463 "ast-system-unpk.cc"
void
impl_tStatePredicate_EF::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2440 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2440 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  1476 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1624 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1489 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1569 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1502 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 696 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 696 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 697 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		} 

#line  1526 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 110 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EF("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1542 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1555 "ast-system-unpk.cc"
void
impl_tStatePredicate_AF::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2436 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2436 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  1568 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1620 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1581 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1565 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1594 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 709 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 709 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 710 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		if (x -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		    f->cannotcompute = false;
		}
		else
		{
		    f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		    if(!f->cannotcompute)
		    {
			f->type = FORMULA_CTL;
		    }  
		}

#line  1626 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 106 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AF("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1642 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1655 "ast-system-unpk.cc"
void
impl_tStatePredicate_ER::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2434 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2434 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2434 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock + y -> containsDeadlock;
#line  1671 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1618 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1684 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1563 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1697 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 662 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 662 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 662 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 663 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || y -> cannotcompute || ! x->validCTLStateFormula || ! y->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		} 

#line  1724 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 104 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 104 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("E("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1744 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1757 "ast-system-unpk.cc"
void
impl_tStatePredicate_AR::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2433 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2433 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2433 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock + y -> containsDeadlock;
#line  1773 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1617 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1786 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1562 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1799 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 675 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 675 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 675 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 676 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		if (x -> validLTLFormula && y -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		    f->cannotcompute = false;
		}
		else
		{
		    f->cannotcompute = (x->cannotcompute || y -> cannotcompute || ! x->validCTLStateFormula || ! y->validCTLStateFormula);
		    if(!f->cannotcompute)
		    {
			f->type = FORMULA_CTL;
		    }  
		}

#line  1834 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 103 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 103 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("A("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1854 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1867 "ast-system-unpk.cc"
void
impl_tStatePredicate_EU::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2432 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2432 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2432 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock + y -> containsDeadlock;
#line  1883 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1616 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1896 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1561 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1909 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1354 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1354 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 1354 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);
		const size_t myDFSId = ctl_dfs_id++;
		const size_t myCacheId = ctl_result_cache_id++;

#line  1926 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 1360 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 2);
		EUFormula* euf = new EUFormula(ctl_formulas[myId][0], ctl_formulas[myId][1]);
		euf->index = 2 * myCacheId;
		euf->dfsindex = myDFSId * SIZEOF_STATENUMBER_T;

		ctl_formulas[ctl_id_stack.top()].push_back(euf);

#line  1942 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 662 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 662 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 662 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 663 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || y -> cannotcompute || ! x->validCTLStateFormula || ! y->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		} 

#line  1969 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 102 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 102 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("E("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1989 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2002 "ast-system-unpk.cc"
void
impl_tStatePredicate_AU::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2435 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2435 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2435 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock + y -> containsDeadlock;
#line  2018 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1619 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2031 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1564 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2044 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1320 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1320 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 1320 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);
		const size_t myDFSId = ctl_dfs_id++;
		const size_t myCacheId = ctl_result_cache_id++;

#line  2061 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 1326 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 2);
		AUFormula* auf = new AUFormula(ctl_formulas[myId][0], ctl_formulas[myId][1]);
		auf->index = 2 * myCacheId;
		auf->dfsindex = myDFSId * SIZEOF_STATENUMBER_T;

		ctl_formulas[ctl_id_stack.top()].push_back(auf);

#line  2077 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 675 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 675 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 675 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 676 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		if (x -> validLTLFormula && y -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		    f->cannotcompute = false;
		}
		else
		{
		    f->cannotcompute = (x->cannotcompute || y -> cannotcompute || ! x->validCTLStateFormula || ! y->validCTLStateFormula);
		    if(!f->cannotcompute)
		    {
			f->type = FORMULA_CTL;
		    }  
		}

#line  2112 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 105 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 105 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("A("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2132 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2145 "ast-system-unpk.cc"
void
impl_tStatePredicate_Release::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2431 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 2431 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 2431 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = phi->containsDeadlock + psi -> containsDeadlock;
#line  2161 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1965 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1965 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate l = this->tStatePredicate_1;
#line 1965 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate r = this->tStatePredicate_2;
		kc::unparse(l, kc_printer, kc_current_view);
		kc::unparse(r, kc_printer, kc_current_view);
#line 1965 "Frontend/Parser/formula_unparse.k"


		f -> length = l -> length + r -> length;
		f -> number_of_and = l -> number_of_and + r -> number_of_and;
		f -> number_of_or = (l -> number_of_or ) + (r -> number_of_or );
		f -> only_fireable = l -> only_fireable && r -> only_fireable;


#line  2185 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1615 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2198 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1560 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2211 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1452 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 1452 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 1455 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(V_OPER, b, a)));

#line  2232 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 647 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 647 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 647 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 648 "Frontend/Parser/formula_unparse.k"

		f->cannotcompute = ( x -> cannotcompute || y -> cannotcompute || !((x->validLTLFormula && y -> validLTLFormula)||(x->validCTLStateFormula && y->validCTLStateFormula)));
		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);
		if((not f->cannotcompute) && f->validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}

#line  2259 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 101 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 101 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(phi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(psi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2279 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2292 "ast-system-unpk.cc"
void
impl_tStatePredicate_Until::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2430 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 2430 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 2430 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = phi -> containsDeadlock + psi -> containsDeadlock;
#line  2308 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1956 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1956 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate l = this->tStatePredicate_1;
#line 1956 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate r = this->tStatePredicate_2;
		kc::unparse(l, kc_printer, kc_current_view);
		kc::unparse(r, kc_printer, kc_current_view);
#line 1956 "Frontend/Parser/formula_unparse.k"


		f -> length = l -> length + r -> length;
		f -> number_of_and = l -> number_of_and + f -> number_of_and;
		f -> number_of_or = (l -> number_of_or ) + (r -> number_of_or );
		f -> only_fireable = l -> only_fireable && r -> only_fireable;


#line  2332 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1614 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2345 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1559 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2358 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1440 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 1440 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 1443 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(U_OPER, b, a)));

#line  2379 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 647 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 647 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 647 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 648 "Frontend/Parser/formula_unparse.k"

		f->cannotcompute = ( x -> cannotcompute || y -> cannotcompute || !((x->validLTLFormula && y -> validLTLFormula)||(x->validCTLStateFormula && y->validCTLStateFormula)));
		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);
		if((not f->cannotcompute) && f->validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}

#line  2406 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 100 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 100 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(phi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(psi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2426 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2439 "ast-system-unpk.cc"
void
impl_tStatePredicate_NextState::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2429 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2429 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  2452 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1947 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1947 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1947 "Frontend/Parser/formula_unparse.k"


		f -> length = x -> length;
		f -> number_of_and = x -> number_of_and;
		f -> number_of_or = x -> number_of_or;
		f -> only_fireable = x -> only_fireable;


#line  2473 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1613 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2486 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1558 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2499 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1432 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1434 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(NEXT, a, NULL)));

#line  2515 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 634 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 634 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 635 "Frontend/Parser/formula_unparse.k"

		f->cannotcompute = (x -> cannotcompute || !(x->validLTLFormula || x->validCTLStateFormula));
		if((not f->cannotcompute)&& x->validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}
		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = x->validCTLStateFormula;
		f->validLTLFormula = x->validLTLFormula;

#line  2539 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 99 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("X ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2555 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2568 "ast-system-unpk.cc"
void
impl_tStatePredicate_Eventually::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2428 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2428 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  2581 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1938 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1938 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1938 "Frontend/Parser/formula_unparse.k"


		f -> length = x -> length;
		f -> number_of_and = x -> number_of_and;
		f -> number_of_or = x -> number_of_or;
		f -> only_fireable = x -> only_fireable;


#line  2602 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1612 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2615 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1557 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2628 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1416 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1418 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(U_OPER, tl_nn(TRUE, NULL, NULL), a)));

#line  2644 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    if ((this->tStatePredicate_1->prod_sel() == sel_Always)) {
#line 504 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 504 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 504 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 505 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_STABILIZATION;
		    f -> cannotcompute = false;
		    f -> validLTLFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || ! y -> validLTLFormula);
		    f -> validLTLFormula = y -> validLTLFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_LTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validCTLStateFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;

#line  2680 "ast-system-unpk.cc"
	    } else
	    {
#line 527 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 527 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 528 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_EVENTUALLY;
		    f -> cannotcompute = false;
		    f -> validLTLFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || ((!y -> validLTLFormula) && !(y -> validCTLStateFormula)));
		    f -> validLTLFormula = y -> validLTLFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_LTL; 
		    }
		}
		f -> validCTLPathFormula = y -> validCTLStateFormula;
		f -> validCTLStateFormula = false;
		f -> containsTemporal = true;

#line  2709 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 98 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("F ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2725 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2738 "ast-system-unpk.cc"
void
impl_tStatePredicate_Always::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2427 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2427 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  2751 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1929 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1929 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1929 "Frontend/Parser/formula_unparse.k"


		f -> length = x -> length;
		f -> number_of_and = x -> number_of_and;
		f -> number_of_or = x -> number_of_or;
		f -> only_fireable = x -> only_fireable;


#line  2772 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1611 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2785 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1556 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2798 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1424 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1426 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(V_OPER, tl_nn(FALSE, NULL, NULL), a)));

#line  2814 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    if ((this->tStatePredicate_1->prod_sel() == sel_Eventually)) {
#line 481 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 481 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 481 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 482 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_FAIRNESS;
		    f -> cannotcompute = false;
		    f -> validLTLFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || ! y -> validLTLFormula);
		    f -> validLTLFormula = y -> validLTLFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_LTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validCTLStateFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;

#line  2850 "ast-system-unpk.cc"
	    } else
	    {
#line 634 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 634 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 635 "Frontend/Parser/formula_unparse.k"

		f->cannotcompute = (x -> cannotcompute || !(x->validLTLFormula || x->validCTLStateFormula));
		if((not f->cannotcompute)&& x->validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}
		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = x->validCTLStateFormula;
		f->validLTLFormula = x->validLTLFormula;

#line  2870 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 97 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("G ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2886 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2899 "ast-system-unpk.cc"
void
impl_tStatePredicate_ExPath::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2426 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2426 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  2912 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1920 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1920 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1920 "Frontend/Parser/formula_unparse.k"


		f -> length = x -> length;
		f -> number_of_and = x -> number_of_and;
		f -> number_of_or = x -> number_of_or;
		f -> only_fireable = x -> only_fireable;


#line  2933 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1610 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2946 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1555 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2959 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    if ((this->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) {
#line 349 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 349 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 349 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 349 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate i = phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 349 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate j = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 349 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate k = phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 349 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 350 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_EGAGEF;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || !y -> validCTLStateFormula);
		    f -> validCTLStateFormula = y -> validCTLStateFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_CTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = true;
		i -> containsTemporal = true;
		j -> containsTemporal = true;
		k -> containsTemporal = true;

#line  3007 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) {
#line 298 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 298 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 298 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 299 "Frontend/Parser/formula_unparse.k"

		f -> type = FORMULA_DEADLOCK;
		f -> cannotcompute = false;
		f -> validCTLStateFormula = true;
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = false;

#line  3027 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) {
#line 376 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 376 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 376 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 376 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate i = phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 376 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 377 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_EFAG;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || ! y -> validCTLStateFormula);
		    f -> validCTLStateFormula = y -> validCTLStateFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_CTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = true;
		i -> containsTemporal = true;

#line  3065 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Eventually)) {
#line 426 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 426 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 426 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 427 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_REACHABLE;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || !y -> validCTLStateFormula);
		    f -> validCTLStateFormula = y -> validCTLStateFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_CTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;

#line  3097 "ast-system-unpk.cc"
	    } else
	    {
#line 621 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 621 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 622 "Frontend/Parser/formula_unparse.k"

		f->cannotcompute = (x -> cannotcompute || !(x->validCTLPathFormula));
		if(! f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		}
		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  3117 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 96 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("E"), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3132 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3145 "ast-system-unpk.cc"
void
impl_tStatePredicate_AllPath::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2425 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2425 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  3158 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1911 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1911 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1911 "Frontend/Parser/formula_unparse.k"


		f -> length = x -> length;
		f -> number_of_and = x -> number_of_and;
		f -> number_of_or = x -> number_of_or;
		f -> only_fireable = x -> only_fireable;


#line  3179 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1609 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3192 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1554 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3205 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    if ((this->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) {
#line 322 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 322 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 322 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 322 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate i = phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 322 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate j = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 322 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate k = phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 322 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 323 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_AGEFAG;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || !y -> validCTLStateFormula);
		    f -> validCTLStateFormula = y -> validCTLStateFormula;
		    if( ! f -> cannotcompute)
		    {
			f -> type = FORMULA_CTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = true;
		i -> containsTemporal = true;
		j -> containsTemporal = true;
		k -> containsTemporal = true;

#line  3253 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) {
#line 310 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 310 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 310 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 311 "Frontend/Parser/formula_unparse.k"

		f -> type = FORMULA_NODEADLOCK;
		f -> cannotcompute = false;
		f -> validCTLStateFormula = true;
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = false;

#line  3273 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) {
#line 401 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 401 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 401 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 401 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate i = phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 401 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 402 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_LIVENESS;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || !y -> validCTLStateFormula);
		    f -> validCTLStateFormula = y -> validCTLStateFormula;
		    if(! f -> cannotcompute)
		    {
			f -> type = FORMULA_CTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = true;
		i -> containsTemporal = true;

#line  3311 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Always)) {
#line 449 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 449 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 449 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 450 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_INVARIANT;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		    f -> validLTLFormula = y -> validLTLFormula;
		}
		else
		{   
		    if (y -> validLTLFormula)
		    {
			f -> type = FORMULA_LTL;
			f -> cannotcompute = false;
		    }
		    else
		    {
			f -> cannotcompute = (y->cannotcompute || !y -> validCTLStateFormula);
			f -> validCTLStateFormula = y -> validCTLStateFormula;
			if(! f -> cannotcompute)
			{
			    f -> type = FORMULA_CTL; 
			}
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;

#line  3352 "ast-system-unpk.cc"
	    } else
	    {
#line 601 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 601 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 602 "Frontend/Parser/formula_unparse.k"

		if (x -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}
		else
		{
		    f->cannotcompute = (x -> cannotcompute || !(x->validCTLPathFormula));
		    if(! f->cannotcompute)
		    {
			f->type = FORMULA_CTL;
		    }
		}
		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  3379 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 95 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("A"), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3394 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3407 "ast-system-unpk.cc"
void
impl_tStatePredicate_Equivalence::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2424 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2424 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2424 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock + y -> containsDeadlock;
#line  3423 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1608 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3436 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1553 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3449 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1505 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1505 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1508 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(EQUIV, a, b)));

#line  3470 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 94 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 94 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" <-> "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3490 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3503 "ast-system-unpk.cc"
void
impl_tStatePredicate_Implication::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2423 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2423 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2423 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock + y -> containsDeadlock;
#line  3519 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1607 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3532 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1552 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3545 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1494 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1494 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1497 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(IMPLIES, a, b)));

#line  3566 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 93 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 93 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" -> "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3586 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3599 "ast-system-unpk.cc"
void
impl_tStatePredicate_ExclusiveDisjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2422 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2422 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2422 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock + y -> containsDeadlock;
#line  3615 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1606 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3628 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1551 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3641 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 92 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 92 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" XOR "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3661 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3674 "ast-system-unpk.cc"
void
impl_tStatePredicate_Disjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2421 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2421 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2421 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock + y -> containsDeadlock;
#line  3690 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1901 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1901 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate l = this->tStatePredicate_1;
#line 1901 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate r = this->tStatePredicate_2;
		kc::unparse(l, kc_printer, kc_current_view);
		kc::unparse(r, kc_printer, kc_current_view);
#line 1901 "Frontend/Parser/formula_unparse.k"


		f -> length = l -> length + r -> length;
		f -> number_of_or_dnf = l -> number_of_or + r -> number_of_or + 1;
		f -> number_of_and = l -> number_of_and + r -> number_of_and;
		f -> number_of_or = (l -> number_of_or ) + (r -> number_of_or ) + 1;
		f -> only_fireable = l -> only_fireable && r -> only_fireable;


#line  3715 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this/**/->type == FORMULA_INITIAL), "Frontend/Parser/formula_unparse.k", 1605, this))) {
#line 1605 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3728 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this/**/->type != FORMULA_INITIAL), "Frontend/Parser/formula_unparse.k", 1542, this))) {
#line 1542 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1542 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1542 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1543 "Frontend/Parser/formula_unparse.k"

		f->task = new DisjunctionTask(x->task,y->task);

#line  3748 "ast-system-unpk.cc"
	    } else
		if ((KC_TRACE_PROVIDED((this/**/->type == FORMULA_INITIAL), "Frontend/Parser/formula_unparse.k", 1550, this))) {
#line 1550 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3757 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1483 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1483 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1486 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(OR, a, b)));

#line  3779 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((not this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 1221, this))) {
#line 1221 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1222 "Frontend/Parser/formula_unparse.k"





		{
#line 1227 "Frontend/Parser/formula_unparse.k"
		    tFormula kc_selvar_0_1 = phylum_cast<tFormula>(StatePredicateFormula(f));
#line 1234 "Frontend/Parser/formula_unparse.k"
		    if ((kc_selvar_0_1->prod_sel() == sel_StatePredicateFormula)) {
#line 1234 "Frontend/Parser/formula_unparse.k"
#line 1233 "Frontend/Parser/formula_unparse.k"
			const tFormula x = kc_selvar_0_1;
#line 1234 "Frontend/Parser/formula_unparse.k"


			x->unparse(myprinter, kc::internal);
			AtomicFormula* af = new AtomicFormula();
			af->inner = new StatePredicateProperty(x->formula);
			ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  3810 "ast-system-unpk.cc"
		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}
#line 1242 "Frontend/Parser/formula_unparse.k"

#line  3816 "ast-system-unpk.cc"
	    } else
		if ((KC_TRACE_PROVIDED((this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 1290, this))) {
#line 1290 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1290 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1290 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 1290 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  3829 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 1294 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		DisjunctionFormula *df = new DisjunctionFormula(ctl_formulas[myId]);
		ctl_formulas[ctl_id_stack.top()].push_back(df);

#line  3841 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 822 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 822 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 822 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  3857 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 826 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t  myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new DisjunctionStatePredicate(formulas[myId].size());
		for (size_t i = 0; i < formulas[myId].size(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((DisjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  3875 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 580 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 580 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 580 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 581 "Frontend/Parser/formula_unparse.k"

		if(not (x->containsTemporal || y->containsTemporal))
		{
		    f->type = FORMULA_INITIAL;
		}
		else
		{
		    f->type = FORMULA_BOOLEAN;
		}
		f->cannotcompute=x->cannotcompute || y -> cannotcompute;
		if(f->cannotcompute)
		{
		    f->type = FORMULA_MODELCHECKING;
		}
		f->containsTemporal = (x->containsTemporal || y->containsTemporal);
		f->validCTLStateFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validCTLPathFormula = false;
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);

#line  3910 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 91 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 91 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" OR "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3930 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3944 "ast-system-unpk.cc"
void
impl_tStatePredicate_Conjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2420 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2420 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2420 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock + y -> containsDeadlock;
#line  3960 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1890 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1890 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate l = this->tStatePredicate_1;
#line 1890 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate r = this->tStatePredicate_2;
		kc::unparse(l, kc_printer, kc_current_view);
		kc::unparse(r, kc_printer, kc_current_view);
#line 1890 "Frontend/Parser/formula_unparse.k"


		f -> length = (l -> length) * (r -> number_of_or + 1) + (r -> length) * (l -> number_of_or + 1);
		f -> number_of_or_dnf = ((l -> number_of_or + 1)*(r -> number_of_or + 1) -1);
		f -> number_of_and = l -> number_of_and + r -> number_of_and + 1;
		f -> number_of_or = (l -> number_of_or ) + (r -> number_of_or );
		f -> only_fireable = l -> only_fireable && r -> only_fireable;


#line  3985 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this/**/->type == FORMULA_INITIAL), "Frontend/Parser/formula_unparse.k", 1604, this))) {
#line 1604 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3998 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this/**/->type != FORMULA_INITIAL), "Frontend/Parser/formula_unparse.k", 1537, this))) {
#line 1537 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1537 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1537 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1538 "Frontend/Parser/formula_unparse.k"

		f->task = new ConjunctionTask(x->task,y->task);

#line  4018 "ast-system-unpk.cc"
	    } else
		if ((KC_TRACE_PROVIDED((this/**/->type == FORMULA_INITIAL), "Frontend/Parser/formula_unparse.k", 1549, this))) {
#line 1549 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  4027 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1472 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1472 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1475 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(AND, a, b)));

#line  4049 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((not this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 1220, this))) {
#line 1220 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1222 "Frontend/Parser/formula_unparse.k"





		{
#line 1227 "Frontend/Parser/formula_unparse.k"
		    tFormula kc_selvar_0_1 = phylum_cast<tFormula>(StatePredicateFormula(f));
#line 1234 "Frontend/Parser/formula_unparse.k"
		    if ((kc_selvar_0_1->prod_sel() == sel_StatePredicateFormula)) {
#line 1234 "Frontend/Parser/formula_unparse.k"
#line 1233 "Frontend/Parser/formula_unparse.k"
			const tFormula x = kc_selvar_0_1;
#line 1234 "Frontend/Parser/formula_unparse.k"


			x->unparse(myprinter, kc::internal);
			AtomicFormula* af = new AtomicFormula();
			af->inner = new StatePredicateProperty(x->formula);
			ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  4080 "ast-system-unpk.cc"
		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}
#line 1242 "Frontend/Parser/formula_unparse.k"

#line  4086 "ast-system-unpk.cc"
	    } else
		if ((KC_TRACE_PROVIDED((this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 1277, this))) {
#line 1277 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1277 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1277 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 1277 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  4099 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 1281 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		ConjunctionFormula *cf = new ConjunctionFormula(ctl_formulas[myId]);
		ctl_formulas[ctl_id_stack.top()].push_back(cf);

#line  4111 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 783 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 783 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 783 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  4127 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 787 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new ConjunctionStatePredicate(formulas[myId].size());
		for (size_t i = 0; i < formulas[myId].size(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((ConjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  4145 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 580 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 580 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 580 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 581 "Frontend/Parser/formula_unparse.k"

		if(not (x->containsTemporal || y->containsTemporal))
		{
		    f->type = FORMULA_INITIAL;
		}
		else
		{
		    f->type = FORMULA_BOOLEAN;
		}
		f->cannotcompute=x->cannotcompute || y -> cannotcompute;
		if(f->cannotcompute)
		{
		    f->type = FORMULA_MODELCHECKING;
		}
		f->containsTemporal = (x->containsTemporal || y->containsTemporal);
		f->validCTLStateFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validCTLPathFormula = false;
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);

#line  4180 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 90 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 90 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" AND "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  4200 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  4214 "ast-system-unpk.cc"
void
impl_tStatePredicate_Negation::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2419 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2419 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  4227 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1880 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1880 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1880 "Frontend/Parser/formula_unparse.k"


		f -> length = x -> length;
		f -> number_of_and = x -> number_of_and;
		f -> number_of_or = x -> number_of_or;
		f -> number_of_or_dnf = x -> number_of_or_dnf;
		f -> only_fireable = x -> only_fireable;


#line  4249 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1603 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  4262 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1548 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  4275 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1464 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1466 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(NOT, a, NULL)));

#line  4291 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1263 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1263 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  4304 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
#line 1267 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		NotFormula *nf = new NotFormula(ctl_formulas[myId][0]);
		ctl_formulas[ctl_id_stack.top()].push_back(nf);

#line  4316 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 559 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 559 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 560 "Frontend/Parser/formula_unparse.k"

		if(not x->containsTemporal)
		{
		    f->type = FORMULA_INITIAL;
		}
		else
		{
		    f->type = FORMULA_BOOLEAN;
		}
		f->cannotcompute=x->cannotcompute;
		if(f->cannotcompute)
		{
		    f->type = FORMULA_MODELCHECKING;
		}
		f->containsTemporal = x->containsTemporal;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = x->validLTLFormula;

#line  4348 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 89 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("!("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  4364 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  4377 "ast-system-unpk.cc"
void
impl_tStatePredicate_AtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2418 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2418 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock;
#line  4390 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1870 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1870 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1870 "Frontend/Parser/formula_unparse.k"


		f -> length = 1;
		f -> number_of_and = 0;
		f -> number_of_or = 0;
		f -> number_of_or_dnf = 0;
		f -> only_fireable = x -> only_fireable;


#line  4412 "ast-system-unpk.cc"
	    }
	    break;
	}
	case problemwriter_enum: {
	    problemwriter_class& kc_current_view=static_cast<problemwriter_class&>(kc_current_view_base);
	    {
#line 1840 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1602 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1626 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  4434 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1547 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1571 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  4447 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1395 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 1396 "Frontend/Parser/formula_unparse.k"


		kc::tFormula internalFormula = StatePredicateFormula(AtomicProposition(x));
		internalFormula->unparse(myprinter, kc::internal);
		StatePredicate* result = internalFormula->formula;


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = (AtomicStatePredicate*)result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  4475 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((not this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 1222, this))) {
#line 1222 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1222 "Frontend/Parser/formula_unparse.k"





		{
#line 1227 "Frontend/Parser/formula_unparse.k"
		    tFormula kc_selvar_0_1 = phylum_cast<tFormula>(StatePredicateFormula(f));
#line 1234 "Frontend/Parser/formula_unparse.k"
		    if ((kc_selvar_0_1->prod_sel() == sel_StatePredicateFormula)) {
#line 1234 "Frontend/Parser/formula_unparse.k"
#line 1233 "Frontend/Parser/formula_unparse.k"
			const tFormula x = kc_selvar_0_1;
#line 1234 "Frontend/Parser/formula_unparse.k"


			x->unparse(myprinter, kc::internal);
			AtomicFormula* af = new AtomicFormula();
			af->inner = new StatePredicateProperty(x->formula);
			ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  4506 "ast-system-unpk.cc"
		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}
#line 1242 "Frontend/Parser/formula_unparse.k"

#line  4512 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 861 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition a = this->tAtomicProposition_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 549 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 550 "Frontend/Parser/formula_unparse.k"

		f->type = FORMULA_INITIAL;
		f->cannotcompute=false;
		f->containsTemporal = false;
		f->validCTLPathFormula = false;
		f->validCTLStateFormula = true;
		f->validLTLFormula = true;

#line  4540 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 88 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  4554 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_tConjunction_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2446 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 2446 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
#line 2446 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = h -> containsDeadlock + l -> containsDeadlock;
#line  4585 "ast-system-unpk.cc"
	    }
	    break;
	}
	case problemwriter_enum: {
	    problemwriter_class& kc_current_view=static_cast<problemwriter_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 1736 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 1738 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 1738 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(","), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 114 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 115 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 115 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" AND "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  4626 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		for (tConjunction_list iterator_ = this; iterator_->tConjunction_list_1 != 0; iterator_ = iterator_->tConjunction_list_1)
		    iterator_->tStatePredicate_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_tConjunction_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2445 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  4649 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  4654 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}

void
impl_tDisjunction_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2450 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 2450 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
#line 2450 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = h -> containsDeadlock + l -> containsDeadlock;
#line  4684 "ast-system-unpk.cc"
	    }
	    break;
	}
	case problemwriter_enum: {
	    problemwriter_class& kc_current_view=static_cast<problemwriter_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 1744 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		{ kc_printer(kc_t("PROBLEM saraProblem:\n"), kc_current_view); }
		{ kc_printer(kc_t("GOAL REACHABILITY;\n"), kc_current_view); }
		{ kc_printer(kc_t("FILE "), kc_current_view); }
#line 1748 "Frontend/Parser/formula_unparse.k"
		kc_printer(RT::args.inputs[0], kc_current_view); 
#line  4698 "ast-system-unpk.cc"
			{ kc_printer(kc_t(" TYPE LOLA;\n"), kc_current_view); }
		{ kc_printer(kc_t("INITIAL "), kc_current_view); }
#line 1751 "Frontend/Parser/formula_unparse.k"



		is_first = false;
		for (arrayindex_t i = 0; i < Net::Card[PL]; i++)
		{
		    if (Marking::Initial[i] > 0)
		    {
			if (!is_first)
			{
			    kc_printer(kc_t(Net::Name[PL][i]), kc_current_view);
#ifdef __cplusplus11                    
			    kc_printer((":" + std::to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#else
			    kc_printer((":" + int_to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#endif
			    is_first = true;
			}
			else
			{
			    kc_printer(",", kc_current_view);
			    kc_printer(kc_t(Net::Name[PL][i]), kc_current_view);
#ifdef __cplusplus11                    
			    kc_printer((":" + std::to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#else
			    kc_printer((":" + int_to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#endif
			}
		    }
		}

#line  4737 "ast-system-unpk.cc"
		{ kc_printer(kc_t(";\n"), kc_current_view); }
		{ kc_printer(kc_t("FINAL COVER;\n"), kc_current_view); }
		{ kc_printer(kc_t("CONSTRAINTS "), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";"), kc_current_view); }
	    } else
	    {
#line 1791 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 1791 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		{ kc_printer(kc_t("PROBLEM saraProblem:\n"), kc_current_view); }
		{ kc_printer(kc_t("GOAL REACHABILITY;\n"), kc_current_view); }
		{ kc_printer(kc_t("FILE "), kc_current_view); }
#line 1795 "Frontend/Parser/formula_unparse.k"
		kc_printer(RT::args.inputs[0], kc_current_view); 
#line  4754 "ast-system-unpk.cc"
			{ kc_printer(kc_t(" TYPE LOLA;\n"), kc_current_view); }
		{ kc_printer(kc_t("INITIAL "), kc_current_view); }
#line 1798 "Frontend/Parser/formula_unparse.k"


		is_first = false;
		for (arrayindex_t i = 0; i < Net::Card[PL]; i++)
		{
		    if (Marking::Initial[i] > 0)
		    {

			if (!is_first)
			{
			    kc_printer(kc_t(Net::Name[PL][i]), kc_current_view);
#ifdef __cplusplus11                    
			    kc_printer((":" + std::to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#else
			    kc_printer((":" + int_to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#endif

			    is_first = true;
			}
			else
			{
			    kc_printer(",", kc_current_view);
			    kc_printer(kc_t(Net::Name[PL][i]), kc_current_view);
#ifdef __cplusplus11       
			    kc_printer((":" + std::to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#else
			    kc_printer((":" + int_to_string(Marking::Initial[i])).c_str(), 
				kc_current_view);
#endif

			}
		    }
		}

#line  4795 "ast-system-unpk.cc"
		{ kc_printer(kc_t(";\n"), kc_current_view); }
		{ kc_printer(kc_t("FINAL COVER;\n"), kc_current_view); }
		{ kc_printer(kc_t("CONSTRAINTS "), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\n\n"), kc_current_view); }
		{ kc_printer(kc_t("RESULT OR formula;\n\n"), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 118 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 119 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 119 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" OR "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  4825 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		for (tDisjunction_list iterator_ = this; iterator_->tDisjunction_list_1 != 0; iterator_ = iterator_->tDisjunction_list_1)
		    iterator_->tStatePredicate_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_tDisjunction_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2449 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  4848 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  4853 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  4866 "ast-system-unpk.cc"
void
impl_tAtomicProposition_Unfireable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2465 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 2465 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  4878 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 981 "Frontend/Parser/formula_unparse.k"
		const integer t = this->integer_1;
#line 981 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new FireablePredicate(t->value,false);

		formulas[id_stack.top()].push_back(f);    

#line  4893 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 134 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		{ kc_printer(kc_t("! FIREABLE("), kc_current_view); }
#line 134 "Frontend/Parser/formula_unparse.k"
		kc_printer(kc_t(Net::Name[TR][x->value]), kc_current_view); 
#line  4905 "ast-system-unpk.cc"
			{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  4911 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  4924 "ast-system-unpk.cc"
void
impl_tAtomicProposition_Fireable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2464 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 2464 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  4936 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 975 "Frontend/Parser/formula_unparse.k"
		const integer t = this->integer_1;
#line 975 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new FireablePredicate(t->value,true);

		formulas[id_stack.top()].push_back(f);    

#line  4951 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 133 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		{ kc_printer(kc_t("FIREABLE("), kc_current_view); }
#line 133 "Frontend/Parser/formula_unparse.k"
		kc_printer(kc_t(Net::Name[TR][x->value]), kc_current_view); 
#line  4963 "ast-system-unpk.cc"
			{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  4969 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  4982 "ast-system-unpk.cc"
void
impl_tAtomicProposition_Initial::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2461 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  4992 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1992 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition f = this/**/;
#line 1992 "Frontend/Parser/formula_unparse.k"


		f -> only_fireable = false;


#line  5007 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("INITIAL"), kc_current_view); }
	    }
	    break;
	}

#line  5019 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5031 "ast-system-unpk.cc"
void
impl_tAtomicProposition_Deadlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2462 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 1;
#line  5041 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1986 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition f = this/**/;
#line 1986 "Frontend/Parser/formula_unparse.k"


		f -> only_fireable = false;


#line  5056 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 969 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new DeadlockPredicate(true);

		formulas[id_stack.top()].push_back(f);    

#line  5069 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("DEADLOCK"), kc_current_view); }
	    }
	    break;
	}

#line  5081 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5093 "ast-system-unpk.cc"
void
impl_tAtomicProposition_NoDeadlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2463 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 1;
#line  5103 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 987 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new DeadlockPredicate(false);

		formulas[id_stack.top()].push_back(f);    

#line  5116 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("! DEADLOCK"), kc_current_view); }
	    }
	    break;
	}

#line  5128 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5140 "ast-system-unpk.cc"
void
impl_tAtomicProposition_False::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2460 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  5150 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 963 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new FalsePredicate();

		formulas[id_stack.top()].push_back(f);    

#line  5163 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("FALSE"), kc_current_view); }
	    }
	    break;
	}

#line  5175 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5187 "ast-system-unpk.cc"
void
impl_tAtomicProposition_True::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2459 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  5197 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 957 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new TruePredicate();

		formulas[id_stack.top()].push_back(f);    

#line  5210 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("TRUE"), kc_current_view); }
	    }
	    break;
	}

#line  5222 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5234 "ast-system-unpk.cc"
void
impl_tAtomicProposition_LessEqualAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2458 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 2458 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
#line 2458 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  5248 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1980 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition f = this/**/;
#line 1980 "Frontend/Parser/formula_unparse.k"
		const tTerm l = this->tTerm_1;
#line 1980 "Frontend/Parser/formula_unparse.k"
		const tTerm r = this->tTerm_2;
#line 1980 "Frontend/Parser/formula_unparse.k"


		f -> only_fireable = false;


#line  5267 "ast-system-unpk.cc"
	    }
	    break;
	}
	case problemwriter_enum: {
	    problemwriter_class& kc_current_view=static_cast<problemwriter_class&>(kc_current_view_base);
	    {
#line 1842 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 1842 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" < "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    if ((this->tTerm_2->prod_sel() == sel_Number)) {
#line 863 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 863 "Frontend/Parser/formula_unparse.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(this->tTerm_2)->integer_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 863 "Frontend/Parser/formula_unparse.k"

		arrayindex_t factors_positive = 0;
		arrayindex_t factors_negative = 0;


		for (std::map<int, int>::const_iterator it = current.begin(); it != current.end(); ++it)
		{
		    if (it->second > 0)
		    {
			factors_positive++;
		    }
		    else if (it->second < 0)
		    {
			factors_negative++;
		    }
		}


		StatePredicate *f = new AtomicStatePredicate(factors_positive, factors_negative, y->value);
		arrayindex_t position_pos = 0;
		arrayindex_t position_neg = 0;


		for (std::map<int, int>::const_iterator it = current.begin(); it != current.end(); ++it)
		{
		    if (it->second > 0)
		    {
			((AtomicStatePredicate*)f)->addPos(position_pos++, it->first, it->second);
		    }
		    else if (it->second < 0)
		    {
			((AtomicStatePredicate*)f)->addNeg(position_neg++, it->first, -it->second);
		    }
		}


		((AtomicStatePredicate*)f)->reduceFactors();


		current.clear();


		formulas[id_stack.top()].push_back(f);

#line  5337 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 127 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 127 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" <= "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5356 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5370 "ast-system-unpk.cc"
void
impl_tAtomicProposition_LessAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2457 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 2457 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
#line 2457 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  5384 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 126 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 126 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" < "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5402 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5415 "ast-system-unpk.cc"
void
impl_tAtomicProposition_GreaterEqualAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2456 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 2456 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
#line 2456 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  5429 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 125 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 125 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" >= "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5447 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5460 "ast-system-unpk.cc"
void
impl_tAtomicProposition_GreaterAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2455 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 2455 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
#line 2455 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  5474 "ast-system-unpk.cc"
	    }
	    break;
	}
	case orsAndAndsAndLength_enum: {
	    orsAndAndsAndLength_class& kc_current_view=static_cast<orsAndAndsAndLength_class&>(kc_current_view_base);
	    {
#line 1974 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition f = this/**/;
#line 1974 "Frontend/Parser/formula_unparse.k"
		const tTerm l = this->tTerm_1;
#line 1974 "Frontend/Parser/formula_unparse.k"
		const tTerm r = this->tTerm_2;
#line 1974 "Frontend/Parser/formula_unparse.k"


		f -> only_fireable = false;


#line  5493 "ast-system-unpk.cc"
	    }
	    break;
	}
	case problemwriter_enum: {
	    problemwriter_class& kc_current_view=static_cast<problemwriter_class&>(kc_current_view_base);
	    if ((this->tTerm_2->prod_sel() == sel_Number)) {
#line 1843 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 1843 "Frontend/Parser/formula_unparse.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(this->tTerm_2)->integer_1;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" > "), kc_current_view); }
#line 1843 "Frontend/Parser/formula_unparse.k"
		y -> value = y -> value + 1;
#line  5508 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 1843 "Frontend/Parser/formula_unparse.k"
		y -> value = y -> value - 1;
#line  5512 "ast-system-unpk.cc"
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    if ((this->tTerm_2->prod_sel() == sel_Number)) {
#line 908 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 908 "Frontend/Parser/formula_unparse.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(this->tTerm_2)->integer_1;
#line 909 "Frontend/Parser/formula_unparse.k"


#line  5527 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 912 "Frontend/Parser/formula_unparse.k"

		arrayindex_t factors_positive = 0;
		arrayindex_t factors_negative = 0;


		for (std::map<int, int>::const_iterator it = current.begin(); it != current.end(); ++it)
		{
		    if (it->second > 0)
		    {
			factors_positive++;
		    }
		    else if (it->second < 0)
		    {
			factors_negative++;
		    }
		}


		StatePredicate *f = new AtomicStatePredicate(factors_negative, factors_positive, (- y->value) -1);
		arrayindex_t position_pos = 0;
		arrayindex_t position_neg = 0;


		for (std::map<int, int>::const_iterator it = current.begin(); it != current.end(); ++it)
		{
		    if (it->second < 0) 
		    {
			((AtomicStatePredicate*)f)->addPos(position_pos++, it->first, -it->second);
		    }
		    else if (it->second > 0) 
		    {
			((AtomicStatePredicate*)f)->addNeg(position_neg++, it->first, it->second);
		    }
		}


		((AtomicStatePredicate*)f)->reduceFactors();


		current.clear();


		formulas[id_stack.top()].push_back(f);

#line  5574 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 124 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 124 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" > "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5593 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5607 "ast-system-unpk.cc"
void
impl_tAtomicProposition_NotEqualsAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2454 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 2454 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
#line 2454 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  5621 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 123 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 123 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" != "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5639 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5652 "ast-system-unpk.cc"
void
impl_tAtomicProposition_EqualsAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
#line 2453 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 2453 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
#line 2453 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = 0;
#line  5666 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 122 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 122 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5684 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5697 "ast-system-unpk.cc"
void
impl_tTerm_ProductList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  5703 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5716 "ast-system-unpk.cc"
void
impl_tTerm_Product::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case problemwriter_enum: {
	    problemwriter_class& kc_current_view=static_cast<problemwriter_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this->integer_1->value == 1), "Frontend/Parser/formula_unparse.k", 1847, this))) {
#line 1847 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 1847 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_1;
		kc::unparse(y, kc_printer, kc_current_view);
	    } else
		if ((KC_TRACE_PROVIDED((this->integer_1->value == -1), "Frontend/Parser/formula_unparse.k", 1848, this))) {
#line 1848 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 1848 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_1;
		{ kc_printer(kc_t("-1"), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    } else
	    {
#line 1849 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 1849 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_1;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    if ((this->tTerm_1->prod_sel() == sel_Node)) {
#line 993 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 993 "Frontend/Parser/formula_unparse.k"
		const integer p = phylum_cast<const impl_tTerm_Node*>(this->tTerm_1)->integer_1;
#line 993 "Frontend/Parser/formula_unparse.k"

		current[p->value] += x->value;


		if (place_in_formula[p->value] == false)
		{
		    unique_places_mentioned++;
		    place_in_formula[p->value] = true;
		}
		places_mentioned++;

#line  5773 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this->integer_1->value == 1), "Frontend/Parser/formula_unparse.k", 144, this))) {
#line 144 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 144 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_1;
		kc::unparse(y, kc_printer, kc_current_view);
	    } else
		if ((KC_TRACE_PROVIDED((this->integer_1->value == -1), "Frontend/Parser/formula_unparse.k", 145, this))) {
#line 145 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 145 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_1;
		{ kc_printer(kc_t("-"), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    } else
	    {
#line 146 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 146 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_1;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t("*"), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5807 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5821 "ast-system-unpk.cc"
void
impl_tTerm_Difference::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 143 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 143 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" - "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5846 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5859 "ast-system-unpk.cc"
void
impl_tTerm_Sum::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 142 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 142 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" + "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5884 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5897 "ast-system-unpk.cc"
void
impl_tTerm_Number::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case problemwriter_enum: {
	    problemwriter_class& kc_current_view=static_cast<problemwriter_class&>(kc_current_view_base);
	    {
#line 1846 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this->integer_1->value == -FINITE), "Frontend/Parser/formula_unparse.k", 137, this))) {
#line 137 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		{ kc_printer(kc_t("-finite"), kc_current_view); }
	    } else
		if ((KC_TRACE_PROVIDED((this->integer_1->value == FINITE), "Frontend/Parser/formula_unparse.k", 138, this))) {
#line 138 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		{ kc_printer(kc_t("finite"), kc_current_view); }
	    } else
		if ((KC_TRACE_PROVIDED((this->integer_1->value == -OMEGA), "Frontend/Parser/formula_unparse.k", 139, this))) {
#line 139 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		{ kc_printer(kc_t("-oo"), kc_current_view); }
	    } else
		if ((KC_TRACE_PROVIDED((this->integer_1->value == OMEGA), "Frontend/Parser/formula_unparse.k", 140, this))) {
#line 140 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		{ kc_printer(kc_t("oo"), kc_current_view); }
	    } else
	    {
#line 141 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5953 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5966 "ast-system-unpk.cc"
void
impl_tTerm_Node::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case problemwriter_enum: {
	    problemwriter_class& kc_current_view=static_cast<problemwriter_class&>(kc_current_view_base);
	    {
#line 1844 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 1844 "Frontend/Parser/formula_unparse.k"
		kc_printer(kc_t(Net::Name[PL][x->value]), kc_current_view); 
#line  5984 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 136 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 136 "Frontend/Parser/formula_unparse.k"
		kc_printer(kc_t(Net::Name[PL][x->value]), kc_current_view); 
#line  5995 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6000 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_tProduct_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case problemwriter_enum: {
	    problemwriter_class& kc_current_view=static_cast<problemwriter_class&>(kc_current_view_base);
	    if ((this->tTerm_1->prod_sel() == sel_Product) && (this->tProduct_list_1->prod_sel() == sel_ConstProduct_list) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Product*>(this->tTerm_1)->integer_1->value < 0), "Frontend/Parser/formula_unparse.k", 1851, this))) {
#line 1851 "Frontend/Parser/formula_unparse.k"
		const tTerm h = this->tTerm_1;
#line 1851 "Frontend/Parser/formula_unparse.k"
		const integer x = phylum_cast<const impl_tTerm_Product*>(this->tTerm_1)->integer_1;
#line 1851 "Frontend/Parser/formula_unparse.k"
		const tProduct_list l = this->tProduct_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" + "), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
		if ((this->tProduct_list_1->prod_sel() == sel_NiltProduct_list)) {
#line 1850 "Frontend/Parser/formula_unparse.k"
		const tTerm h = this->tTerm_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 1852 "Frontend/Parser/formula_unparse.k"
		const tTerm h = this->tTerm_1;
#line 1852 "Frontend/Parser/formula_unparse.k"
		const tProduct_list l = this->tProduct_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" + "), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tTerm_1->prod_sel() == sel_Product) && (this->tProduct_list_1->prod_sel() == sel_ConstProduct_list) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Product*>(this->tTerm_1)->integer_1->value < 0), "Frontend/Parser/formula_unparse.k", 148, this))) {
#line 148 "Frontend/Parser/formula_unparse.k"
		const tTerm h = this->tTerm_1;
#line 148 "Frontend/Parser/formula_unparse.k"
		const integer x = phylum_cast<const impl_tTerm_Product*>(this->tTerm_1)->integer_1;
#line 148 "Frontend/Parser/formula_unparse.k"
		const tProduct_list l = this->tProduct_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" + "), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
		if ((this->tProduct_list_1->prod_sel() == sel_NiltProduct_list)) {
#line 147 "Frontend/Parser/formula_unparse.k"
		const tTerm h = this->tTerm_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 149 "Frontend/Parser/formula_unparse.k"
		const tTerm h = this->tTerm_1;
#line 149 "Frontend/Parser/formula_unparse.k"
		const tProduct_list l = this->tProduct_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" + "), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  6084 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		for (tProduct_list iterator_ = this; iterator_->tProduct_list_1 != 0; iterator_ = iterator_->tProduct_list_1)
		    iterator_->tTerm_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_tProduct_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case countdeadlock_enum: {
	    countdeadlock_class& kc_current_view=static_cast<countdeadlock_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  6108 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6120 "ast-system-unpk.cc"
void
impl_tBuechiAutomata_BuechiNull::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 1083 "Frontend/Parser/formula_unparse.k"
		const tBuechiAutomata b = this/**/;
#line 1083 "Frontend/Parser/formula_unparse.k"
		RT::rep->message("NULL BUECHI"); b->automata = 0; 
#line  6132 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  6143 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6155 "ast-system-unpk.cc"
void
impl_tBuechiAutomata_BuechiAutomaton::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 1084 "Frontend/Parser/formula_unparse.k"
		const tBuechiAutomata b = this/**/;
#line 1084 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 1084 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
#line 1087 "Frontend/Parser/formula_unparse.k"




		uint32_t number_of_states = states_to_interal.size();


		b->automata = new BuechiAutomata();
		b->automata->cardStates = number_of_states;



		b->automata->cardAtomicPropositions = predicates.size();
		b->automata->atomicPropositions = new StatePredicateProperty*[predicates.size()]();
		b->automata->atomicPropotions_backlist = new arrayindex_t[predicates.size()]();
		for (uint32_t i = 0; i < predicates.size(); i++)
		b->automata->atomicPropositions[i] = new StatePredicateProperty(predicates[i]);	




		b->automata->cardTransitions = new uint32_t[number_of_states]();
		b->automata->transitions = new uint32_t**[number_of_states]();
		b->automata->cardEnabled = new arrayindex_t[number_of_states]();
		for (uint32_t i = 0; i < number_of_states; i++){
		    b->automata->cardTransitions[i] = transitions[i].size();
		    b->automata->transitions[i] = new uint32_t*[transitions[i].size()]();
		    for (uint32_t j = 0; j < transitions[i].size(); j++){

			b->automata->transitions[i][j] = new uint32_t[2]();
			b->automata->transitions[i][j][0] = transitions[i][j].first;
			b->automata->transitions[i][j][1] = transitions[i][j].second;
			b->automata->atomicPropotions_backlist[transitions[i][j].first] = i;
		    }
		}



		b->automata->isStateAccepting = new bool[number_of_states]();
		for (__typeof__(acceptingset.begin()) i = acceptingset.begin(); i != acceptingset.end(); i++)
		b->automata->isStateAccepting[*i] = true;

#line  6214 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 152 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 152 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  6232 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6245 "ast-system-unpk.cc"
void
impl_tBuechiRules_BuechiRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 1155 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules lrules = this->tBuechiRules_1;
#line 1155 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules rrules = this->tBuechiRules_2;
		kc::unparse(lrules, kc_printer, kc_current_view);
		kc::unparse(rrules, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 158 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 158 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("&"), kc_current_view); }
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  6276 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6289 "ast-system-unpk.cc"
void
impl_tBuechiRules_ExpandedBuechiRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 1132 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 1132 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 1132 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
#line 1133 "Frontend/Parser/formula_unparse.k"


		formula->unparse(myprinter, kc::internal);
		StatePredicate* result = formula->formula;






		uint32_t formula_number = (uint32_t)(predicates.size());
		predicates[formula_number] = result;

		uint32_t from_number = get_state_number(from->value);
		uint32_t to_number = get_state_number(to->value);

		transitions[from_number].push_back(std::make_pair(formula_number, to_number));

#line  6322 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 157 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 157 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 157 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(from, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(formula, kc_printer, kc_current_view);
		{ kc_printer(kc_t(") -> "), kc_current_view); }
		kc::unparse(to, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}

#line  6345 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6358 "ast-system-unpk.cc"
void
impl_tBuechiRules_BuechiRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 156 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 156 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		{ kc_printer(kc_t("STATE"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  6377 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6390 "ast-system-unpk.cc"
void
impl_tBuechiRules_EmptyBuechiRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  6408 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6420 "ast-system-unpk.cc"
void
impl_tTransitionRules_TransitionRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 162 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 162 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("&"), kc_current_view); }
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  6439 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6452 "ast-system-unpk.cc"
void
impl_tTransitionRules_TransitionRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 161 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 161 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  6471 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6484 "ast-system-unpk.cc"
void
impl_tTransitionRules_EmptyTransitionRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  6496 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6508 "ast-system-unpk.cc"
void
impl_tAcceptingSet_AcceptingSet::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 1166 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet set1 = this->tAcceptingSet_1;
#line 1166 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet set2 = this->tAcceptingSet_2;
		kc::unparse(set1, kc_printer, kc_current_view);
		kc::unparse(set2, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  6532 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6545 "ast-system-unpk.cc"
void
impl_tAcceptingSet_AcceptingState::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 1160 "Frontend/Parser/formula_unparse.k"
		const integer state = this->integer_1;
#line 1161 "Frontend/Parser/formula_unparse.k"

		acceptingset.insert(get_state_number(state->value));

#line  6559 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  6570 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6583 "ast-system-unpk.cc"
void
impl_tAcceptingSet_EmptyAcceptingSet::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  6601 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6613 "ast-system-unpk.cc"
void
impl_net_Net::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2004 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2004 "Frontend/Parser/formula_unparse.k"
		const definitionsList d = this->definitionsList_1;
#line 2004 "Frontend/Parser/formula_unparse.k"
		const placeblocklist p = this->placeblocklist_1;
#line 2004 "Frontend/Parser/formula_unparse.k"
		const marking m = this->marking_1;
#line 2004 "Frontend/Parser/formula_unparse.k"
		const transition t = this->transition_1;
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(d, kc_printer, kc_current_view);
		kc::unparse(p, kc_printer, kc_current_view);
		kc::unparse(m, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  6640 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6653 "ast-system-unpk.cc"
void
impl_definitionsList_DefinitionsList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2007 "Frontend/Parser/formula_unparse.k"
		const definitionsList l = this->definitionsList_1;
#line 2007 "Frontend/Parser/formula_unparse.k"
		const definitions d = this->definitions_1;
		kc::unparse(l, kc_printer, kc_current_view);
		kc::unparse(d, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  6671 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6684 "ast-system-unpk.cc"
void
impl_definitionsList_EmptyDefinitionsList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  6696 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6708 "ast-system-unpk.cc"
void
impl_definitions_Function::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2032 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 2032 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2032 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 2032 "Frontend/Parser/formula_unparse.k"
		const functionParametersList f = this->functionParametersList_1;
#line 2032 "Frontend/Parser/formula_unparse.k"
		const block b = this->block_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
#line 2033 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = t;

#line  6732 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(f, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 2037 "Frontend/Parser/formula_unparse.k"





#line  6742 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6747 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6760 "ast-system-unpk.cc"
void
impl_definitions_Sort::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2023 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 2023 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2023 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
#line 2024 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = t;

#line  6780 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
#line 2028 "Frontend/Parser/formula_unparse.k"



#line  6786 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6791 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6804 "ast-system-unpk.cc"
void
impl_definitions_Constant::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2009 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 2009 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2009 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 2009 "Frontend/Parser/formula_unparse.k"
		const expression e = this->expression_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(e, kc_printer, kc_current_view);
#line 2010 "Frontend/Parser/formula_unparse.k"


		if(! (e->is_constant))
		{

		}






#line  6837 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6842 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6855 "ast-system-unpk.cc"
void
impl_type_TypeBlack::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2120 "Frontend/Parser/formula_unparse.k"

		is_finite = true;
		is_scalar = true;
		size = 1;

#line  6869 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6874 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6886 "ast-system-unpk.cc"
void
impl_type_TypeArray::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6892 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6905 "ast-system-unpk.cc"
void
impl_type_TypeMultiset::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2108 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
		kc::unparse(t, kc_printer, kc_current_view);
#line 2109 "Frontend/Parser/formula_unparse.k"

		if(! (t->is_finite))
		{

		}
		is_finite = false;
		is_scalar = false;
		size = 0; 

#line  6926 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6931 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6944 "ast-system-unpk.cc"
void
impl_type_TypeInt::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2102 "Frontend/Parser/formula_unparse.k"

		is_finite = false;
		is_scalar = true;
		size = 0; 

#line  6958 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6963 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6975 "ast-system-unpk.cc"
void
impl_type_TypeStruct::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2094 "Frontend/Parser/formula_unparse.k"
		const structTypeList s = this->structTypeList_1;
		kc::unparse(s, kc_printer, kc_current_view);
#line 2095 "Frontend/Parser/formula_unparse.k"

		size = s -> size;
		is_finite = s -> is_finite;
		is_scalar = false;

#line  6992 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6997 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7010 "ast-system-unpk.cc"
void
impl_type_TypeIntInterval::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2073 "Frontend/Parser/formula_unparse.k"
		const expression e = this->expression_1;
#line 2073 "Frontend/Parser/formula_unparse.k"
		const expression f = this->expression_2;
		kc::unparse(e, kc_printer, kc_current_view);
		kc::unparse(f, kc_printer, kc_current_view);
#line 2074 "Frontend/Parser/formula_unparse.k"

		if(!(e->is_constant && f->is_constant))
		{

		}
		if(!(e -> is_scalar && f -> is_scalar))
		{

		}
		arrayindex_t left = *(reinterpret_cast<arrayindex_t *>(e->value));
		arrayindex_t right = *(reinterpret_cast<arrayindex_t *>(f->value));
		if(right < left)
		{

		}
		is_finite = true;
		is_scalar = true;
		size = right - left +1;

#line  7044 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7049 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7062 "ast-system-unpk.cc"
void
impl_type_TypeIdent::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2066 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2067 "Frontend/Parser/formula_unparse.k"




#line  7077 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7082 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7095 "ast-system-unpk.cc"
void
impl_type_TypeEnum::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2053 "Frontend/Parser/formula_unparse.k"
		const identList i = this->identList_1;
		kc::unparse(i, kc_printer, kc_current_view);
#line 2054 "Frontend/Parser/formula_unparse.k"

		size = i -> nrvalues;
		if(size == 0)
		{

		}
		is_finite = true;
		is_scalar = true;


#line  7117 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7122 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7135 "ast-system-unpk.cc"
void
impl_type_TypeBool::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2045 "Frontend/Parser/formula_unparse.k"

		size = 2;
		is_finite = true;
		is_scalar = true;


#line  7150 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7155 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7167 "ast-system-unpk.cc"
void
impl_optionalNumber_OptNumber::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2134 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 2135 "Frontend/Parser/formula_unparse.k"

		value = i-> value;
		set = true;

#line  7182 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7187 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7200 "ast-system-unpk.cc"
void
impl_optionalNumber_EmptyOptNumber::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2128 "Frontend/Parser/formula_unparse.k"

		value = ARRAYINDEX_T_MAX;
		set = false;

#line  7213 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7218 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7230 "ast-system-unpk.cc"
void
impl_identList_IdentList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2148 "Frontend/Parser/formula_unparse.k"
		const identList i = this->identList_1;
#line 2148 "Frontend/Parser/formula_unparse.k"
		const idents d = this->idents_1;
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(d, kc_printer, kc_current_view);
#line 2149 "Frontend/Parser/formula_unparse.k"

		nrvalues = i -> nrvalues + 1;
		if(d -> value <= i -> maxvalue)
		{

		}
		if(!(d -> set))
		{
		    d -> value = i -> maxvalue + 1;
		}

		maxvalue = d -> value;


#line  7259 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7264 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7277 "ast-system-unpk.cc"
void
impl_identList_EmptyIdentList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2142 "Frontend/Parser/formula_unparse.k"

		maxvalue = 0;
		nrvalues = 0;

#line  7290 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7295 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7307 "ast-system-unpk.cc"
void
impl_idents_Idents::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2165 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2165 "Frontend/Parser/formula_unparse.k"
		const optionalNumber o = this->optionalNumber_1;
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(o, kc_printer, kc_current_view);
#line 2166 "Frontend/Parser/formula_unparse.k"

		value = o -> value;
		set = o -> set;

#line  7326 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7331 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7344 "ast-system-unpk.cc"
void
impl_structTypeList_StructTypeList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2179 "Frontend/Parser/formula_unparse.k"
		const structTypeList l = this->structTypeList_1;
#line 2179 "Frontend/Parser/formula_unparse.k"
		const structType s = this->structType_1;
		kc::unparse(l, kc_printer, kc_current_view);
		kc::unparse(s, kc_printer, kc_current_view);
#line 2180 "Frontend/Parser/formula_unparse.k"

		size = l -> size * s -> size;
		nrcomponents = l -> nrcomponents + 1;
		is_finite = (l -> is_finite) && (s -> is_finite);

#line  7364 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7369 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7382 "ast-system-unpk.cc"
void
impl_structTypeList_EmptyStructTypeList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2173 "Frontend/Parser/formula_unparse.k"

		size = 0;
		nrcomponents = 0;
		is_finite = true;

#line  7396 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7401 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7413 "ast-system-unpk.cc"
void
impl_structType_StructType::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2187 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 2187 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2187 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
#line 2188 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = t;

#line  7433 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
#line 2192 "Frontend/Parser/formula_unparse.k"

		size = t -> size * a -> nrelements;
		is_finite = t -> is_finite;
		is_scalar = false;

#line  7441 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7446 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7459 "ast-system-unpk.cc"
void
impl_varOrArray_VarOrArray::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2199 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2199 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 2200 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = inherited_type;

#line  7475 "ast-system-unpk.cc"
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(a, kc_printer, kc_current_view);
#line 2204 "Frontend/Parser/formula_unparse.k"

		type = a -> type;

#line  7482 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7487 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7500 "ast-system-unpk.cc"
void
impl_arrayList_ArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2217 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 2217 "Frontend/Parser/formula_unparse.k"
		const expression e = this->expression_1;
#line 2218 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = inherited_type;

#line  7516 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(e, kc_printer, kc_current_view);
#line 2222 "Frontend/Parser/formula_unparse.k"

		if(!(e -> is_constant))
		{

		}
		if(e -> value == 0)
		{

		}
		nrdimensions = a -> nrdimensions + 1;


		type -> size = nrelements * a -> type -> size;
		type -> is_finite = a -> type -> is_finite;
		type -> is_scalar = false;


#line  7537 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7542 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7555 "ast-system-unpk.cc"
void
impl_arrayList_EmptyArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2211 "Frontend/Parser/formula_unparse.k"

		nrdimensions = 0;
		nrelements = 1;
		type = inherited_type;

#line  7569 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  7574 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7586 "ast-system-unpk.cc"
void
impl_functionParametersList_FunctionParametersList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7592 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7605 "ast-system-unpk.cc"
void
impl_functionParametersList_EmptyFunctionParametersList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7611 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7623 "ast-system-unpk.cc"
void
impl_functionParameters_FunctionParameters::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7629 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7642 "ast-system-unpk.cc"
void
impl_expression_ExprAll::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7648 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7661 "ast-system-unpk.cc"
void
impl_expression_ExprOtherIf::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7667 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7680 "ast-system-unpk.cc"
void
impl_expression_ExprCommaSeparated::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7686 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7699 "ast-system-unpk.cc"
void
impl_expression_FunctionCall::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7705 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7718 "ast-system-unpk.cc"
void
impl_expression_ExprGreaterOrEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7724 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7737 "ast-system-unpk.cc"
void
impl_expression_ExprLessOrEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7743 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7756 "ast-system-unpk.cc"
void
impl_expression_ExprGreaterThan::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7762 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7775 "ast-system-unpk.cc"
void
impl_expression_ExprLessThan::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7781 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7794 "ast-system-unpk.cc"
void
impl_expression_ExprNotEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7800 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7813 "ast-system-unpk.cc"
void
impl_expression_ExprEquivalent::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7819 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7832 "ast-system-unpk.cc"
void
impl_expression_ExprFalse::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7838 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7850 "ast-system-unpk.cc"
void
impl_expression_ExprTrue::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7856 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7868 "ast-system-unpk.cc"
void
impl_expression_ExprOr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7874 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7887 "ast-system-unpk.cc"
void
impl_expression_ExprAnd::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7893 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7906 "ast-system-unpk.cc"
void
impl_expression_NotExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7912 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7925 "ast-system-unpk.cc"
void
impl_expression_ExprNumber::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7931 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7944 "ast-system-unpk.cc"
void
impl_expression_ExprModulo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7950 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7963 "ast-system-unpk.cc"
void
impl_expression_ExprDivision::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7969 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7982 "ast-system-unpk.cc"
void
impl_expression_ExprMultiplication::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7988 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8001 "ast-system-unpk.cc"
void
impl_expression_ExprSubtraction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8007 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8020 "ast-system-unpk.cc"
void
impl_expression_ExprAddition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8026 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8039 "ast-system-unpk.cc"
void
impl_expression_NegativeExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8045 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8058 "ast-system-unpk.cc"
void
impl_expression_PositiveExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8064 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8077 "ast-system-unpk.cc"
void
impl_expression_ValDecrement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8083 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8096 "ast-system-unpk.cc"
void
impl_expression_ValIncrement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8102 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8115 "ast-system-unpk.cc"
void
impl_expression_DecrementVal::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8121 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8134 "ast-system-unpk.cc"
void
impl_expression_IncrementVal::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8140 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8153 "ast-system-unpk.cc"
void
impl_expression_AssignMod::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8159 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8172 "ast-system-unpk.cc"
void
impl_expression_AssignDivide::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8178 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8191 "ast-system-unpk.cc"
void
impl_expression_AssignTimes::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8197 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8210 "ast-system-unpk.cc"
void
impl_expression_AssignMinus::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8216 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8229 "ast-system-unpk.cc"
void
impl_expression_AssignPlus::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8235 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8248 "ast-system-unpk.cc"
void
impl_expression_AssignEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8254 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8267 "ast-system-unpk.cc"
void
impl_expression_ExprInitializerList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8273 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8286 "ast-system-unpk.cc"
void
impl_expression_ExprLeftvalue::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8292 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8305 "ast-system-unpk.cc"
void
impl_leftvalue_LeftValDot::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8311 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8324 "ast-system-unpk.cc"
void
impl_leftvalue_LeftValBrackets::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8330 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8343 "ast-system-unpk.cc"
void
impl_leftvalue_LeftValIdent::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8349 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8362 "ast-system-unpk.cc"
void
impl_expressionlist_ExpressionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8368 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8381 "ast-system-unpk.cc"
void
impl_expressionlist_EmptyExpressionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8387 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8399 "ast-system-unpk.cc"
void
impl_initializerList_ExprInBracesColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8405 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8418 "ast-system-unpk.cc"
void
impl_initializerList_ExprInBraces::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8424 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8437 "ast-system-unpk.cc"
void
impl_expressionListColon_ExpressionListColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8443 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8456 "ast-system-unpk.cc"
void
impl_expressionListColon_EmptyExpressionListColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8462 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8474 "ast-system-unpk.cc"
void
impl_placeblocklist_PlaceBlockList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8480 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8493 "ast-system-unpk.cc"
void
impl_placeblocklist_EmptyPlaceBlockList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8499 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8511 "ast-system-unpk.cc"
void
impl_optSafe_Safe::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8517 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8530 "ast-system-unpk.cc"
void
impl_optSafe_EmptySafe::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8536 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8548 "ast-system-unpk.cc"
void
impl_place_Place::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8554 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8567 "ast-system-unpk.cc"
void
impl_placelist_PlaceList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8573 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8586 "ast-system-unpk.cc"
void
impl_placelist_EmptyPlaceList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8592 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8604 "ast-system-unpk.cc"
void
impl_placeblock_PlaceBlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8610 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8623 "ast-system-unpk.cc"
void
impl_marking_Marking::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8629 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8642 "ast-system-unpk.cc"
void
impl_marking_EmptyMarking::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8648 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8660 "ast-system-unpk.cc"
void
impl_transition_Transition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8666 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8679 "ast-system-unpk.cc"
void
impl_transition_EmptyTransition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8685 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8697 "ast-system-unpk.cc"
void
impl_fairness_StrongFair::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8703 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8715 "ast-system-unpk.cc"
void
impl_fairness_WeakFair::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8721 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8733 "ast-system-unpk.cc"
void
impl_fairness_EmptyFairness::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8739 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8751 "ast-system-unpk.cc"
void
impl_variable_Variable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8757 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8770 "ast-system-unpk.cc"
void
impl_variable_EmptyVariable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8776 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8788 "ast-system-unpk.cc"
void
impl_varOrArrayList_VarOrArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8794 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8807 "ast-system-unpk.cc"
void
impl_varOrArrayList_EmptyVarOrArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8813 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8825 "ast-system-unpk.cc"
void
impl_guard_Guard::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8831 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8844 "ast-system-unpk.cc"
void
impl_identExprList_IdentExprList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8850 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8863 "ast-system-unpk.cc"
void
impl_identExprList_EmptyIdentExprList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8869 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8881 "ast-system-unpk.cc"
void
impl_block_Block::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8887 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8900 "ast-system-unpk.cc"
void
impl_declarationOrStatement_DeclOrStatemStatement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8906 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8919 "ast-system-unpk.cc"
void
impl_declarationOrStatement_DeclOrStatemDeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8925 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8938 "ast-system-unpk.cc"
void
impl_declarationOrStatement_EmptyDeclarationOrStatement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8944 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8956 "ast-system-unpk.cc"
void
impl_declaration_Declaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8962 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8975 "ast-system-unpk.cc"
void
impl_statement_StatementSkip::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8981 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8993 "ast-system-unpk.cc"
void
impl_statement_StatementReturn::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8999 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9012 "ast-system-unpk.cc"
void
impl_statement_StatementContinue::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9018 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  9030 "ast-system-unpk.cc"
void
impl_statement_StatementBreak::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9036 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  9048 "ast-system-unpk.cc"
void
impl_statement_StatementSwitch::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9054 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9067 "ast-system-unpk.cc"
void
impl_statement_StatementForAll::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9073 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9086 "ast-system-unpk.cc"
void
impl_statement_StatementForIdentColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9092 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9105 "ast-system-unpk.cc"
void
impl_statement_StatementForTypeExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9111 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9124 "ast-system-unpk.cc"
void
impl_statement_StatementForExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9130 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9143 "ast-system-unpk.cc"
void
impl_statement_StatementDoWhile::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9149 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9162 "ast-system-unpk.cc"
void
impl_statement_StatementWhile::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9168 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9181 "ast-system-unpk.cc"
void
impl_statement_StatementIf::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9187 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9200 "ast-system-unpk.cc"
void
impl_statement_StatementExprSemicolon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9206 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9219 "ast-system-unpk.cc"
void
impl_statement_StatementBlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9225 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9238 "ast-system-unpk.cc"
void
impl_switchCase_SwitchDefault::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9244 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9257 "ast-system-unpk.cc"
void
impl_switchCase_SwitchCase::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9263 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9276 "ast-system-unpk.cc"
void
impl_switchCaseList_SwitchCaseList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9282 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9295 "ast-system-unpk.cc"
void
impl_switchCaseList_EmptySwitchCaseList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9301 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


} // namespace kc
